<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>ScanX • Orbit OS</title>
  <style>
    :root {
      color-scheme: light;
      --bg:#f4f6ff;
      --panel:#ffffff;
      --ink:#13224d;
      --muted:#5c678a;
      --accent:#3c7dff;
      --border:#c7d4f5;
      --success:#1e7e34;
      --error:#b71c1c;
    }
    * { box-sizing:border-box; }
    body {
      margin:0;
      font-family:"Segoe UI", system-ui, sans-serif;
      background:var(--bg);
      color:var(--ink);
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    .scanx-shell {
      width:100%;
      max-width:960px;
      background:var(--panel);
      border:2px solid var(--border);
      border-radius:16px;
      box-shadow:0 18px 48px rgba(19,34,77,0.18);
      padding:28px;
      display:flex;
      flex-direction:column;
      gap:24px;
    }
    header h1 {
      margin:0;
      font-size:28px;
      letter-spacing:0.04em;
    }
    header p {
      margin:6px 0 0 0;
      color:var(--muted);
      font-size:15px;
    }
    .upload-row {
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      align-items:center;
    }
    .upload-row input[type="file"] {
      flex:1 1 260px;
      padding:10px;
      border:1px dashed var(--border);
      border-radius:10px;
      background:#f9fbff;
    }
    button {
      font:600 15px "Segoe UI", system-ui, sans-serif;
      border-radius:10px;
      border:1px solid transparent;
      padding:10px 18px;
      cursor:pointer;
      transition:transform 0.15s ease, box-shadow 0.15s ease, opacity 0.2s ease;
      background:linear-gradient(145deg, var(--accent), #1d4bd8);
      color:#fff;
      box-shadow:0 8px 20px rgba(60,125,255,0.24);
      min-width:150px;
    }
    button:disabled {
      opacity:0.55;
      cursor:not-allowed;
      box-shadow:none;
      transform:none;
    }
    button.secondary {
      background:#fff;
      color:var(--ink);
      border-color:var(--border);
      box-shadow:0 4px 12px rgba(19,34,77,0.08);
    }
    .actions {
      display:flex;
      flex-wrap:wrap;
      gap:12px;
    }
    .status {
      padding:14px 16px;
      border-radius:12px;
      background:#eef3ff;
      border:1px solid var(--border);
      font-size:15px;
      line-height:1.5;
    }
    .status.success {
      background:rgba(30,126,52,0.12);
      border-color:rgba(30,126,52,0.4);
      color:var(--success);
    }
    .status.error {
      background:rgba(183,28,28,0.12);
      border-color:rgba(183,28,28,0.4);
      color:var(--error);
    }
    .status.processing {
      background:rgba(60,125,255,0.12);
      border-color:rgba(60,125,255,0.4);
    }
    .summary {
      display:grid;
      grid-template-columns:repeat(auto-fit,minmax(240px,1fr));
      gap:16px;
    }
    .page-card {
      border:1px solid var(--border);
      border-radius:12px;
      padding:14px 16px;
      background:#f9fbff;
      box-shadow:0 4px 14px rgba(19,34,77,0.08);
    }
    .page-card h3 {
      margin:0 0 8px 0;
      font-size:18px;
    }
    .page-card p {
      margin:0;
      color:var(--muted);
      font-size:14px;
      line-height:1.5;
    }
    .page-card .page-preview {
      margin:10px 0 12px 0;
    }
    .page-card .page-meta {
      margin:0 0 6px 0;
      color:var(--accent);
      font-weight:600;
      font-size:14px;
    }
    .page-card .page-margins {
      margin:0 0 10px 0;
      color:var(--muted);
      font-size:13px;
    }
    .page-thumb {
      position:relative;
      width:100%;
      aspect-ratio:3 / 4;
      min-height:140px;
      background:#fff;
      border-radius:10px;
      border:1px solid rgba(19,34,77,0.12);
      overflow:hidden;
      box-shadow:inset 0 0 0 1px rgba(19,34,77,0.04);
    }
    .page-thumb__content {
      position:absolute;
      inset:8% 6%;
      border:1px dashed rgba(19,34,77,0.18);
      border-radius:8px;
      background:linear-gradient(180deg, rgba(60,125,255,0.05) 0%, rgba(60,125,255,0.05) 60%, transparent 100%);
      overflow:hidden;
    }
    .page-thumb__content[data-style] {
      inset:auto;
    }
    .page-thumb__column {
      position:absolute;
      background:repeating-linear-gradient(180deg, rgba(60,125,255,0.16), rgba(60,125,255,0.16) 6%, rgba(60,125,255,0.08) 6%, rgba(60,125,255,0.08) 12%);
      border-radius:6px;
      box-shadow:0 2px 4px rgba(19,34,77,0.08);
    }
    .page-thumb__column::after {
      content:'';
      position:absolute;
      inset:8% 10%;
      border-radius:4px;
      background:repeating-linear-gradient(180deg, rgba(19,34,77,0.08), rgba(19,34,77,0.08) 6%, transparent 6%, transparent 12%);
      opacity:0.9;
    }
    .page-thumb--empty {
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--muted);
      font-size:12px;
      text-align:center;
      padding:12px;
    }
    .meta-row {
      display:flex;
      flex-wrap:wrap;
      gap:12px;
      font-size:14px;
      color:var(--muted);
    }
    @media (max-width:640px) {
      body { padding:12px; }
      .scanx-shell { padding:20px; }
      button { flex:1 1 100%; min-width:0; }
      .upload-row input[type="file"] { flex:1 1 100%; }
    }
  </style>
</head>
<body>
  <main class="scanx-shell">
    <header>
      <h1>ScanX Publishing Studio</h1>
      <p>Transform source PDFs into publication-ready Docu Monster layouts with one click.</p>
    </header>
    <section class="upload-row">
      <input type="file" id="pdfInput" accept="application/pdf" />
      <button id="analyzeBtn" disabled>Analyze PDF</button>
    </section>
    <section class="meta-row" id="metaRow" hidden>
      <span id="metaFile"></span>
      <span id="metaPages"></span>
      <span id="metaLayout"></span>
    </section>
    <section class="status" id="statusPanel">Select a PDF to begin.</section>
    <section class="actions">
      <button id="downloadBtn" class="secondary" disabled>Download .dx</button>
      <button id="saveLocalBtn" class="secondary" disabled>Save to Local Storage</button>
      <button id="openDocBtn" disabled>Open in Docu Monster</button>
    </section>
    <section class="summary" id="summary"></section>
  </main>
  <script>
    const PDFJS_SOURCES = [
      {
        script: '../../shared/vendor/scanx/pdfjs-lite.js'
      },
      {
        script: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.2.67/build/pdf.min.js',
        worker: 'https://cdn.jsdelivr.net/npm/pdfjs-dist@4.2.67/build/pdf.worker.min.js'
      },
      {
        script: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.min.js',
        worker: 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/4.2.67/pdf.worker.min.js'
      }
    ];

    function loadScript(src) {
      return new Promise((resolve, reject) => {
        const script = document.createElement('script');
        script.src = src;
        script.async = true;
        script.onload = () => resolve();
        script.onerror = () => reject(new Error('Failed to load script: ' + src));
        document.head.appendChild(script);
      });
    }

    function configurePdfJs(source) {
      try {
        if (window.pdfjsLib && source.worker) {
          window.pdfjsLib.GlobalWorkerOptions.workerSrc = source.worker;
        }
      } catch (err) {
        console.warn('Unable to configure PDF.js worker', err);
      }
    }

    async function ensurePdfJsLoaded() {
      if (window.pdfjsLib) {
        configurePdfJs(PDFJS_SOURCES[0]);
        return window.pdfjsLib;
      }
      for (const source of PDFJS_SOURCES) {
        try {
          await loadScript(source.script);
          if (window.pdfjsLib) {
            configurePdfJs(source);
            return window.pdfjsLib;
          }
        } catch (err) {
          console.warn('PDF.js source failed', source.script, err);
        }
      }
      throw new Error('PDF.js library could not be loaded');
    }

    let pdfjsReadyPromise = null;

    const STORAGE_KEY = 'documonster-studiopro-autosave-v0-1';
    const DX_MIME = 'application/vnd.orbit-documonster+json';
    const DX_EXTENSION = '.dx';

    const pdfInput = document.getElementById('pdfInput');
    const analyzeBtn = document.getElementById('analyzeBtn');
    const statusPanel = document.getElementById('statusPanel');
    const downloadBtn = document.getElementById('downloadBtn');
    const saveLocalBtn = document.getElementById('saveLocalBtn');
    const openDocBtn = document.getElementById('openDocBtn');
    const summaryEl = document.getElementById('summary');
    const metaRow = document.getElementById('metaRow');
    const metaFile = document.getElementById('metaFile');
    const metaPages = document.getElementById('metaPages');
    const metaLayout = document.getElementById('metaLayout');

    let working = false;
    let currentDoc = null;
    let currentFileName = '';

    function setStatus(message, mode = 'info') {
      statusPanel.textContent = message;
      statusPanel.classList.remove('success', 'error', 'processing');
      if (mode === 'success') statusPanel.classList.add('success');
      else if (mode === 'error') statusPanel.classList.add('error');
      else if (mode === 'processing') statusPanel.classList.add('processing');
    }

    function initializePdfEngine() {
      if (!pdfjsReadyPromise) {
        pdfjsReadyPromise = ensurePdfJsLoaded();
      }
      pdfjsReadyPromise.catch(err => {
        console.error('ScanX PDF engine failed to load', err);
        setStatus('ScanX could not load its PDF engine. Check your connection and reload.', 'error');
      });
      return pdfjsReadyPromise;
    }

    function toggleWorking(state) {
      working = state;
      analyzeBtn.disabled = state || !pdfInput.files.length;
      downloadBtn.disabled = state || !currentDoc;
      saveLocalBtn.disabled = state || !currentDoc;
      openDocBtn.disabled = state || !currentDoc;
      pdfInput.disabled = state;
      if (state) {
        setStatus('Analyzing PDF… this may take a moment.', 'processing');
      }
    }

    function escapeHtml(input) {
      return input.replace(/[&<>"']/g, ch => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
      })[ch]);
    }

    const POINT_TO_MM = 25.4 / 72;
    const LOREM_SOURCE = 'Lorem ipsum dolor sit amet consectetur adipiscing elit sed do eiusmod tempor incididunt ut labore et dolore magna aliqua Vivamus feugiat ligula at fringilla pharetra mauris neque fermentum velit eu consequat augue magna a magna Donec aliquet orci ut turpis imperdiet a tincidunt erat fermentum Praesent suscipit varius nulla nec vehicula nisl pharetra vitae';
    const LOREM_WORDS = LOREM_SOURCE.split(/\s+/).filter(Boolean);

    function loremWords(count) {
      const safe = Math.max(12, Math.round(count || 0));
      const words = [];
      for (let i = 0; i < safe; i++) {
        words.push(LOREM_WORDS[i % LOREM_WORDS.length]);
      }
      return words;
    }

    function buildLoremParagraph(wordEstimate) {
      const words = loremWords(Math.max(wordEstimate, 35));
      const sentences = [];
      const chunkSize = 18;
      for (let i = 0; i < words.length; i += chunkSize) {
        const slice = words.slice(i, i + chunkSize);
        if (!slice.length) continue;
        const sentence = slice.join(' ');
        sentences.push(sentence.charAt(0).toUpperCase() + sentence.slice(1) + '.');
      }
      return sentences.join(' ');
    }

    function extractTextBoxes(textContent, viewport) {
      const boxes = [];
      const items = textContent.items || [];
      const height = viewport.height;
      items.forEach(item => {
        const raw = typeof item.str === 'string' ? item.str.replace(/\s+/g, ' ') : '';
        const text = raw.trim();
        if (!text) return;
        const transform = item.transform || [1, 0, 0, 1, 0, 0];
        let glyphMatrix = transform;
        try {
          glyphMatrix = pdfjsLib.Util.transform(viewport.transform, transform);
        } catch (err) {
          // fallback to item transform if Util.transform is unavailable
        }
        const x = glyphMatrix[4];
        const y = glyphMatrix[5];
        const width = (item.width || 0) * viewport.scale;
        const heightPx = Math.max(Math.hypot(glyphMatrix[1], glyphMatrix[3]) || Math.abs(glyphMatrix[3]) || 0, 0.1);
        const top = height - y;
        boxes.push({
          text,
          left: x,
          right: x + width,
          top,
          bottom: top + heightPx,
          width,
          height: heightPx,
          center: x + width / 2
        });
      });
      return boxes;
    }

    function clusterColumns(boxes, pageWidth) {
      if (!boxes.length) return [];
      const sorted = boxes.slice().sort((a, b) => a.left - b.left);
      const threshold = Math.max(pageWidth * 0.08, 24);
      const columns = [];
      sorted.forEach(box => {
        let assigned = null;
        for (const column of columns) {
          const distance = Math.abs(box.center - column.center);
          if (distance <= threshold) {
            assigned = column;
            break;
          }
        }
        if (!assigned) {
          assigned = {
            boxes: [],
            left: box.left,
            right: box.right,
            top: box.top,
            bottom: box.bottom,
            center: box.center
          };
          columns.push(assigned);
        }
        assigned.boxes.push(box);
        assigned.left = Math.min(assigned.left, box.left);
        assigned.right = Math.max(assigned.right, box.right);
        assigned.top = Math.min(assigned.top, box.top);
        assigned.bottom = Math.max(assigned.bottom, box.bottom);
        assigned.center = (assigned.left + assigned.right) / 2;
      });
      columns.sort((a, b) => a.left - b.left);
      while (columns.length > 4) {
        let mergeIndex = 0;
        let smallestGap = Infinity;
        for (let i = 0; i < columns.length - 1; i++) {
          const gap = columns[i + 1].left - columns[i].right;
          if (gap < smallestGap) {
            smallestGap = gap;
            mergeIndex = i;
          }
        }
        const target = columns[mergeIndex];
        const neighbor = columns[mergeIndex + 1];
        target.boxes.push(...neighbor.boxes);
        target.left = Math.min(target.left, neighbor.left);
        target.right = Math.max(target.right, neighbor.right);
        target.top = Math.min(target.top, neighbor.top);
        target.bottom = Math.max(target.bottom, neighbor.bottom);
        target.center = (target.left + target.right) / 2;
        columns.splice(mergeIndex + 1, 1);
      }
      if (columns.length > 1) {
        const totalBoxes = boxes.length;
        for (let i = columns.length - 1; i >= 0; i--) {
          const col = columns[i];
          const share = col.boxes.length / totalBoxes;
          const widthShare = (col.right - col.left) / pageWidth;
          if (share < 0.08 || widthShare < 0.08) {
            const neighbor = i === 0 ? columns[1] : columns[i - 1];
            neighbor.boxes.push(...col.boxes);
            neighbor.left = Math.min(neighbor.left, col.left);
            neighbor.right = Math.max(neighbor.right, col.right);
            neighbor.top = Math.min(neighbor.top, col.top);
            neighbor.bottom = Math.max(neighbor.bottom, col.bottom);
            neighbor.center = (neighbor.left + neighbor.right) / 2;
            columns.splice(i, 1);
          }
        }
      }
      columns.forEach(col => col.boxes.sort((a, b) => a.top - b.top || a.left - b.left));
      return columns;
    }

    function buildColumnPlaceholder(column) {
      if (!column.boxes.length) {
        return {
          html: `<p>${escapeHtml(buildLoremParagraph(40))}</p>`,
          height: column.bottom - column.top
        };
      }
      const heights = column.boxes.map(box => box.height);
      const avgHeight = heights.reduce((sum, value) => sum + value, 0) / heights.length || 0;
      const gapThreshold = Math.max(avgHeight * 1.6, 14);
      const paragraphs = [];
      let current = [];
      let lastBottom = null;
      column.boxes.forEach(box => {
        if (lastBottom !== null && (box.top - lastBottom) > gapThreshold) {
          if (current.length) paragraphs.push(current);
          current = [];
        }
        current.push(box);
        lastBottom = box.bottom;
      });
      if (current.length) paragraphs.push(current);
      const html = paragraphs.map(group => {
        const original = group.map(item => item.text).join(' ');
        const words = original.split(/\s+/).filter(Boolean).length;
        return `<p>${escapeHtml(buildLoremParagraph(Math.max(words, 35)))}</p>`;
      }).join('') || `<p>${escapeHtml(buildLoremParagraph(40))}</p>`;
      return {
        html,
        height: column.bottom - column.top
      };
    }

    function buildPreviewText(boxes) {
      if (!boxes.length) return 'No textual content detected.';
      const ordered = boxes.slice().sort((a, b) => a.top - b.top || a.left - b.left);
      const combined = ordered.map(box => box.text).join(' ');
      return combined.length > 220 ? combined.slice(0, 220) + '…' : combined;
    }

    function clampPercent(value) {
      return Math.max(0, Math.min(100, value));
    }

    function safeNumber(value, fallback = 0) {
      return (typeof value === 'number' && Number.isFinite(value)) ? value : fallback;
    }

    function percentOf(value, total) {
      const safeTotal = total && Number.isFinite(total) && total !== 0 ? Math.abs(total) : 1;
      return clampPercent((safeNumber(value) / safeTotal) * 100);
    }

    function buildPageThumbnail(layout) {
      if (!layout || !layout.pageSizeMm) {
        return '<div class="page-thumb page-thumb--empty">No layout detected</div>';
      }
      const pageWidth = safeNumber(layout.pageSizeMm.width, 210);
      const pageHeight = safeNumber(layout.pageSizeMm.height, 297);
      const margins = layout.marginsMm || {};
      const marginStyles = {
        left: percentOf(margins.left, pageWidth),
        right: percentOf(margins.right, pageWidth),
        top: percentOf(margins.top, pageHeight),
        bottom: percentOf(margins.bottom, pageHeight)
      };
      const columns = Array.isArray(layout.columnsMm) ? layout.columnsMm : [];
      const columnMarkup = columns.length ? columns.map((col, idx) => {
        const left = percentOf(col.start, pageWidth);
        const width = Math.max(6, percentOf(col.width, pageWidth));
        const topValue = safeNumber(col.top, margins.top || 0);
        const bottomValue = safeNumber(col.bottom, pageHeight - safeNumber(margins.bottom, 0));
        const top = percentOf(topValue, pageHeight);
        const delta = bottomValue - topValue;
        const heightMm = delta > 0 ? delta : pageHeight * 0.6;
        const height = Math.max(8, percentOf(heightMm, pageHeight));
        return `<div class="page-thumb__column" style="left:${left}%;width:${width}%;top:${top}%;height:${height}%;"></div>`;
      }).join('') : '<div class="page-thumb__column" style="left:15%;width:70%;top:12%;height:76%;"></div>';
      const contentStyle = `left:${marginStyles.left}%;top:${marginStyles.top}%;right:${marginStyles.right}%;bottom:${marginStyles.bottom}%;`;
      return `
        <div class="page-thumb">
          <div class="page-thumb__content" data-style="true" style="${contentStyle}">
            ${columnMarkup}
          </div>
        </div>
      `;
    }

    function formatMeasurement(value) {
      if (typeof value !== 'number' || !Number.isFinite(value)) return null;
      const rounded = Math.round(value * 100) / 100;
      return Number.isInteger(rounded) ? String(rounded) : rounded.toFixed(2);
    }

    function analyzePageLayout(page, textContent) {
      const viewport = page.getViewport({ scale: 1 });
      const boxes = extractTextBoxes(textContent, viewport);
      const pageWidthPx = viewport.width;
      const pageHeightPx = viewport.height;
      const pageWidthMm = Number((pageWidthPx * POINT_TO_MM).toFixed(2));
      const pageHeightMm = Number((pageHeightPx * POINT_TO_MM).toFixed(2));

      if (!boxes.length) {
        const placeholder = `<p>${escapeHtml(buildLoremParagraph(80))}</p>`;
        return {
          columns: 1,
          windows: [placeholder],
          windowLayout: [{ width: Number((pageWidthMm * 0.7).toFixed(2)), height: Number((pageHeightMm * 0.6).toFixed(2)) }],
          html: placeholder,
          preview: 'No textual content detected.',
          metadata: {
            pageSizeMm: { width: pageWidthMm, height: pageHeightMm },
            marginsMm: { top: 15, right: 15, bottom: 15, left: 15 },
            columnsMm: [],
            averageGutterMm: 0
          }
        };
      }

      const columns = clusterColumns(boxes, pageWidthPx);
      const columnData = columns.map(col => {
        const placeholder = buildColumnPlaceholder(col);
        return {
          html: placeholder.html,
          widthMm: Number(((col.right - col.left) * POINT_TO_MM).toFixed(2)),
          heightMm: Number((placeholder.height * POINT_TO_MM).toFixed(2)),
          startMm: Number((col.left * POINT_TO_MM).toFixed(2)),
          topMm: Number((col.top * POINT_TO_MM).toFixed(2)),
          bottomMm: Number((col.bottom * POINT_TO_MM).toFixed(2))
        };
      });

      const windows = columnData.map(col => col.html);
      const windowLayout = columnData.map(col => ({ width: col.widthMm, height: col.heightMm }));
      const html = windows.join('');

      const contentLeft = Math.min(...boxes.map(box => box.left));
      const contentRight = Math.max(...boxes.map(box => box.right));
      const contentTop = Math.min(...boxes.map(box => box.top));
      const contentBottom = Math.max(...boxes.map(box => box.bottom));

      const marginsMm = {
        top: Number((contentTop * POINT_TO_MM).toFixed(2)),
        bottom: Number(((pageHeightPx - contentBottom) * POINT_TO_MM).toFixed(2)),
        left: Number((contentLeft * POINT_TO_MM).toFixed(2)),
        right: Number(((pageWidthPx - contentRight) * POINT_TO_MM).toFixed(2))
      };

      const gutters = [];
      for (let i = 0; i < columns.length - 1; i++) {
        gutters.push(columns[i + 1].left - columns[i].right);
      }
      const averageGutterMm = gutters.length
        ? Number(((gutters.reduce((acc, gap) => acc + gap, 0) / gutters.length) * POINT_TO_MM).toFixed(2))
        : 0;

      const metadata = {
        pageSizeMm: { width: pageWidthMm, height: pageHeightMm },
        marginsMm,
        columnsMm: columnData.map(col => ({
          start: col.startMm,
          width: col.widthMm,
          height: col.heightMm,
          top: col.topMm,
          bottom: col.bottomMm
        })),
        averageGutterMm
      };

      return {
        columns: columnData.length || 1,
        windows,
        windowLayout,
        html,
        preview: buildPreviewText(boxes),
        metadata
      };
    }

    function buildDocument(pages, sourceName, summaries) {
      const timestamp = new Date();
      const averageColumns = summaries.length
        ? (summaries.reduce((total, entry) => total + (entry.columns || 0), 0) / summaries.length)
        : 0;
      const gutterSamples = summaries
        .map(entry => (typeof entry.gutter === 'number' && Number.isFinite(entry.gutter)) ? entry.gutter : null)
        .filter(value => value !== null);
      const averageGutter = gutterSamples.length
        ? gutterSamples.reduce((total, value) => total + value, 0) / gutterSamples.length
        : null;
      return {
        version: '1.0.0',
        docVersion: '1.0.0',
        codename: 'ScanX Publishing Studio',
        docName: 'Docu Monster Studio Pro',
        releaseNotes: [
          `Generated by ScanX from ${sourceName} on ${timestamp.toLocaleString()}.`,
          'Each page has been rebuilt for publishing-ready refinement in Docu Monster.'
        ],
        pages,
        analysis: {
          source: sourceName,
          generatedAt: timestamp.toISOString(),
          pageCount: pages.length,
          averageColumns: Number.isFinite(averageColumns) ? Number(averageColumns.toFixed(2)) : 0,
          averageGutterMm: averageGutter !== null ? Number(averageGutter.toFixed(2)) : null,
          pages: summaries.map(entry => ({
            index: entry.index,
            columns: entry.columns || 0,
            marginsMm: entry.margins || null,
            averageGutterMm: typeof entry.gutter === 'number' ? entry.gutter : null
          }))
        }
      };
    }

    async function analyzePdf(file) {
      try {
        await initializePdfEngine();
      } catch (err) {
        setStatus('ScanX could not load its PDF engine. Check your connection and reload.', 'error');
        return;
      }
      toggleWorking(true);
      summaryEl.innerHTML = '';
      metaRow.hidden = true;
      try {
        const arrayBuffer = await file.arrayBuffer();
        const loadingTask = pdfjsLib.getDocument({ data: arrayBuffer });
        const pdf = await loadingTask.promise;
        const pages = [];
        const summaries = [];
        for (let pageIndex = 1; pageIndex <= pdf.numPages; pageIndex++) {
          const page = await pdf.getPage(pageIndex);
          const textContent = await page.getTextContent();
          const layout = analyzePageLayout(page, textContent);
          pages.push({
            title: `ScanX Page ${pageIndex}`,
            subtitle: '',
            deck: '',
            theme: 'standard',
            elements: [{
              type: 'columns',
              columns: layout.columns,
              windows: layout.windows,
              windowLayout: layout.windowLayout,
              style: 'standard',
              html: layout.html
            }],
            footerLeft: 'Docu Monster Studio Pro',
            footerRight: 'Page {{page}} of {{total}}',
            layout: layout.metadata
          });
          summaries.push({
            index: pageIndex,
            preview: layout.preview,
            columns: layout.columns,
            margins: layout.metadata?.marginsMm || null,
            gutter: typeof layout.metadata?.averageGutterMm === 'number' ? layout.metadata.averageGutterMm : null,
            layout: layout.metadata
          });
        }
        const averageColumns = summaries.length
          ? summaries.reduce((total, entry) => total + (entry.columns || 0), 0) / summaries.length
          : null;
        const gutterSamples = summaries
          .map(entry => (typeof entry.gutter === 'number' && Number.isFinite(entry.gutter)) ? entry.gutter : null)
          .filter(value => value !== null);
        const averageGutter = gutterSamples.length
          ? gutterSamples.reduce((total, value) => total + value, 0) / gutterSamples.length
          : null;
        currentDoc = buildDocument(pages, file.name, summaries);
        currentFileName = file.name;
        renderSummary(summaries);
        metaFile.textContent = `Source: ${file.name}`;
        metaPages.textContent = `Pages detected: ${pages.length}`;
        if (metaLayout) {
          const parts = [];
          const columnValue = averageColumns && averageColumns > 0 ? formatMeasurement(averageColumns) : null;
          if (columnValue) parts.push(`Avg columns: ${columnValue}`);
          const gutterValue = averageGutter !== null ? formatMeasurement(averageGutter) : null;
          if (gutterValue) parts.push(`Avg gutter: ${gutterValue} mm`);
          metaLayout.textContent = parts.length ? parts.join(' • ') : 'Layout analysis ready.';
        }
        metaRow.hidden = false;
        const statusParts = [];
        const statusColumns = averageColumns && averageColumns > 0 ? formatMeasurement(averageColumns) : null;
        if (statusColumns) statusParts.push(`${statusColumns} avg columns`);
        const statusGutter = averageGutter !== null ? formatMeasurement(averageGutter) : null;
        if (statusGutter) statusParts.push(`~${statusGutter} mm gutters`);
        const statusDetail = statusParts.length ? ` Detected ${statusParts.join(' • ')}.` : '';
        setStatus(`Scan complete. ${pages.length} page${pages.length === 1 ? '' : 's'} ready for Docu Monster.${statusDetail}`, 'success');
      } catch (err) {
        console.error('ScanX failed', err);
        currentDoc = null;
        setStatus('ScanX could not analyze this PDF: ' + (err.message || err), 'error');
      } finally {
        toggleWorking(false);
      }
    }

    function renderSummary(entries) {
      summaryEl.innerHTML = entries.map(entry => {
        const columnLabel = entry.columns === 1 ? 'Single-column layout' : `${entry.columns}-column layout`;
        const gutterValue = formatMeasurement(entry.gutter);
        const gutterLabel = gutterValue ? ` • Avg. gutter ${gutterValue} mm` : '';
        let marginLabel = '';
        if (entry.margins) {
          const left = formatMeasurement(entry.margins.left);
          const top = formatMeasurement(entry.margins.top);
          const right = formatMeasurement(entry.margins.right);
          const bottom = formatMeasurement(entry.margins.bottom);
          if (left || top || right || bottom) {
            marginLabel = `Margins L:${left ?? '—'} mm • T:${top ?? '—'} mm • R:${right ?? '—'} mm • B:${bottom ?? '—'} mm`;
          }
        }
        const marginLine = marginLabel ? `<p class="page-margins">${escapeHtml(marginLabel)}</p>` : '';
        return `
        <article class="page-card">
          <h3>Page ${entry.index}</h3>
          <p class="page-meta">${escapeHtml(columnLabel + gutterLabel)}</p>
          ${marginLine}
          <div class="page-preview">${buildPageThumbnail(entry.layout)}</div>
          <p>${escapeHtml(entry.preview)}</p>
        </article>
      `;
      }).join('');
    }

    function makeFileBaseName() {
      const base = currentFileName ? currentFileName.replace(/\.[^.]+$/, '') : 'scanx-output';
      return base.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') || 'scanx-output';
    }

    function downloadDx() {
      if (!currentDoc) return;
      const blob = new Blob([JSON.stringify(currentDoc, null, 2)], { type: DX_MIME });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = `${makeFileBaseName()}${DX_EXTENSION}`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(a.href);
      setStatus('DX file downloaded to your disk.', 'success');
    }

    function saveToLocalStorage() {
      if (!currentDoc) return;
      try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(currentDoc));
        setStatus('Document stored in local Orbit OS storage for Docu Monster.', 'success');
      } catch (err) {
        console.error('Local save failed', err);
        setStatus('Unable to write to local storage: ' + (err.message || err), 'error');
      }
    }

    function openInDocuMonster() {
      if (!currentDoc) return;
      setStatus('Sending document to Docu Monster…', 'processing');
      try {
        const pageCount = Array.isArray(currentDoc?.pages) ? currentDoc.pages.length : 0;
        window.parent?.postMessage({
          type: 'scanx:open-document',
          payload: {
            document: currentDoc,
            name: `${makeFileBaseName()}${DX_EXTENSION}`,
            pageCount
          }
        }, '*');
      } catch (err) {
        console.error('Bridge failed', err);
        setStatus('Could not notify Docu Monster: ' + (err.message || err), 'error');
      }
    }

    pdfInput.addEventListener('change', () => {
      currentDoc = null;
      summaryEl.innerHTML = '';
      metaRow.hidden = true;
      if (metaFile) metaFile.textContent = '';
      if (metaPages) metaPages.textContent = '';
      if (metaLayout) metaLayout.textContent = '';
      downloadBtn.disabled = true;
      saveLocalBtn.disabled = true;
      openDocBtn.disabled = true;
      if (pdfInput.files.length) {
        analyzeBtn.disabled = false;
        setStatus('Ready to scan. Click “Analyze PDF” to continue.');
      } else {
        analyzeBtn.disabled = true;
        setStatus('Select a PDF to begin.');
      }
    });

    analyzeBtn.addEventListener('click', () => {
      const file = pdfInput.files[0];
      if (!file || working) return;
      analyzePdf(file);
    });

    downloadBtn.addEventListener('click', downloadDx);
    saveLocalBtn.addEventListener('click', saveToLocalStorage);
    openDocBtn.addEventListener('click', openInDocuMonster);

    initializePdfEngine();

    window.addEventListener('message', (event) => {
      const data = event.data;
      if (!data || typeof data !== 'object') return;
      if (data.type === 'scanx:documonster-confirm') {
        setStatus(`Docu Monster opened ${data.payload?.name || 'the document'} (${data.payload?.pageCount ?? '?'} pages).`, 'success');
      }
    });
  </script>
</body>
</html>
