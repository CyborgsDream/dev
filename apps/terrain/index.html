<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Terrain</title>
  <style>
    :root {
      --navy-900: #020817;
      --navy-800: #071127;
      --navy-700: #0b1a35;
      --frame-border: rgba(0, 0, 0, 0.45);
      --frame-border-light: rgba(255, 255, 255, 0.08);
      --text-white: #ffffff;
      --text-black: #050505;
      --accent-orange: #ff8b2f;
      --graph-grid: rgba(255, 255, 255, 0.18);
      --graph-fill: rgba(255, 139, 47, 0.18);
      --graph-line: #ff8b2f;
    }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      color: var(--text-white);
      font-family: 'Trebuchet MS', 'Lucida Sans', 'Geneva', sans-serif;
    }
    body {
      position: relative;
      background:
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.06), transparent 45%),
        radial-gradient(circle at 80% 30%, rgba(255, 139, 47, 0.08), transparent 55%),
        var(--navy-900);
      background-size: cover;
    }
    #scene-shell {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      pointer-events: none;
      box-sizing: border-box;
    }
    #canvas-wrap {
      position: relative;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #canvas-wrap::before,
    #canvas-wrap::after {
      content: '';
      position: absolute;
      inset: -4%;
      opacity: 0;
      pointer-events: none;
    }
    #canvas-wrap.vhs-glitch {
      animation: vhs-warp 0.6s ease-out;
      filter: saturate(1.2) contrast(1.1);
    }
    #canvas-wrap.vhs-glitch::before {
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255, 139, 47, 0.2) 0px,
          rgba(255, 139, 47, 0.2) 2px,
          transparent 2px,
          transparent 4px
        ),
        linear-gradient(90deg, rgba(255, 0, 90, 0.18), rgba(0, 240, 255, 0.18));
      mix-blend-mode: screen;
      animation: vhs-noise 0.6s ease-out forwards;
    }
    #canvas-wrap.vhs-glitch::after {
      background: linear-gradient(0deg, rgba(255, 255, 255, 0.06), transparent 60%);
      mix-blend-mode: lighten;
      animation: vhs-color 0.6s ease-out forwards;
    }
    canvas {
      display: block;
      border: 2px solid var(--frame-border);
      background: #000;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.45);
      max-width: 100%;
      max-height: 100%;
      image-rendering: pixelated;
    }
    body.terrain-fallback-mode #control-pad,
    body.terrain-fallback-mode #fullscreen-btn,
    body.terrain-fallback-mode #fps {
      display: none;
    }
    body.terrain-fallback-mode #hud-overlay {
      opacity: 0.78;
    }
    .render-mode-btn.is-disabled {
      opacity: 0.45 !important;
      cursor: not-allowed;
    }
    #loader {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #09132a 0%, #020817 100%);
      color: var(--text-white);
      font-family: 'Lucida Sans', 'Geneva', sans-serif;
      font-size: 2em;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      z-index: 60;
    }
    #loader .loader-content {
      display: grid;
      justify-items: center;
      gap: 20px;
      text-align: center;
      padding: 28px 32px;
      border: none;
      background: none;
      box-shadow: none;
      backdrop-filter: none;
    }
    #loader .loader-icon {
      width: 192px;
      height: 144px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      box-shadow: none;
      position: relative;
      image-rendering: pixelated;
    }
    #loader .loader-icon::after {
      display: none;
    }
    #loader .loader-icon canvas {
      width: 100%;
      height: 100%;
      display: block;
      image-rendering: pixelated;
      background: transparent;
      border: none !important;
      box-shadow: none !important;
    }
    @media (max-width: 620px) {
      #loader .loader-icon {
        transform: scale(0.82);
      }
    }
    #loader .loader-text {
      font-size: 0.54em;
      letter-spacing: 0.28em;
    }
    #loader.is-error .loader-text {
      color: #ff5b5b;
    }
    #loader .loader-meta {
      font-size: 0.36em;
      letter-spacing: 0.3em;
      color: rgba(255, 255, 255, 0.68);
    }
    @media (prefers-reduced-motion: reduce) {
      #loader .loader-icon {
        transform: none;
      }
    }
    #loader #progress {
      color: var(--accent-orange);
    }
    #fps {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 40;
      pointer-events: none;
    }
    #fps-monitor {
      position: relative;
      display: grid;
      row-gap: 6px;
      padding: 12px;
      background: linear-gradient(160deg, var(--navy-800), var(--navy-700));
      border: 1px solid var(--frame-border);
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
      min-width: 180px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-white);
    }
    #fps-monitor .panel-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.7rem;
      color: var(--accent-orange);
      letter-spacing: 0.18em;
    }
    #fps-monitor .panel-title .label {
      color: var(--text-white);
      letter-spacing: 0.2em;
    }
    #fps-monitor .fps-readout {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-family: 'Lucida Console', 'Courier New', monospace;
      color: var(--text-white);
    }
    #fps-monitor .fps-label {
      font-size: 0.65rem;
      color: var(--accent-orange);
    }
    #fps-monitor .fps-value {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--text-white);
      min-width: 3.6em;
      text-shadow: 0 0 14px rgba(255, 139, 47, 0.3);
    }
    #fps-monitor canvas {
      width: 100%;
      height: 48px;
      border: 1px solid var(--frame-border);
      background: var(--navy-900);
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
    }
    #control-ui {
      position: fixed;
      top: 14px;
      right: 14px;
      background: rgba(7, 17, 39, 0.55);
      border: 1px solid var(--frame-border);
      box-shadow: inset 0 0 0 1px var(--frame-border-light), 0 12px 26px rgba(0, 0, 0, 0.38);
      padding: 14px 16px 18px;
      display: grid;
      row-gap: 12px;
      width: min(220px, 78vw);
      z-index: 34;
      font-family: 'Lucida Sans', 'Geneva', sans-serif;
      color: var(--text-white);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      backdrop-filter: blur(14px);
      transition: background 0.35s ease, border-color 0.35s ease;
    }
    #control-ui.folded {
      background: rgba(7, 17, 39, 0.38);
      border-color: rgba(255, 255, 255, 0.12);
    }
    #control-ui .ui-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    #control-ui h2 {
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.68rem;
      color: var(--accent-orange);
      letter-spacing: 0.2em;
    }
    #control-ui h2 span:last-child {
      color: var(--text-white);
      letter-spacing: 0.24em;
    }
    #ui-fold-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      background: rgba(2, 8, 23, 0.35);
      color: var(--text-white);
      font-size: 0.52rem;
      letter-spacing: 0.16em;
      padding: 5px 10px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    #ui-fold-btn:hover {
      background: rgba(255, 139, 47, 0.25);
      border-color: rgba(255, 139, 47, 0.6);
      transform: translateY(-1px);
    }
    #ui-fold-btn:active {
      transform: translateY(1px);
    }
    #ui-fold-btn .fold-icon {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.35s ease;
    }
    #ui-fold-btn .fold-icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
      transform-origin: center;
      transition: transform 0.35s ease;
      animation: fold-pulse 2.4s ease-in-out infinite;
    }
    #control-ui.folded #ui-fold-btn .fold-icon svg {
      transform: rotate(-90deg);
    }
    .fold-body {
      display: grid;
      row-gap: 10px;
      max-height: 340px;
      overflow: hidden;
      transition: max-height 0.4s ease, opacity 0.3s ease;
    }
    #control-ui.folded .fold-body {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .ui-icon {
      width: 22px;
      height: 22px;
      display: grid;
      place-items: center;
      perspective: 400px;
    }
    .ui-icon svg {
      width: 100%;
      height: 100%;
      fill: var(--text-white);
      transform-origin: center;
      animation: icon-spin 6s linear infinite;
      filter: drop-shadow(0 0 6px rgba(255, 139, 47, 0.35));
    }
    @keyframes icon-spin {
      0% { transform: rotateX(0deg) rotateY(0deg); }
      50% { transform: rotateX(18deg) rotateY(180deg); }
      100% { transform: rotateX(0deg) rotateY(360deg); }
    }
    @keyframes fold-pulse {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.12); }
    }
    @keyframes vhs-warp {
      0% { transform: translate3d(0, 0, 0) skewX(0deg); filter: saturate(1.1) contrast(1.05); }
      20% { transform: translate3d(-4px, 0, 0) skewX(-1.5deg); filter: saturate(1.4) contrast(1.25); }
      45% { transform: translate3d(3px, 0, 0) skewX(1deg); filter: saturate(1.25) contrast(1.18); }
      70% { transform: translate3d(-2px, 0, 0) skewX(-0.6deg); filter: saturate(1.15) contrast(1.12); }
      100% { transform: translate3d(0, 0, 0) skewX(0deg); filter: saturate(1.1) contrast(1.05); }
    }
    @keyframes vhs-noise {
      0% { opacity: 0.55; transform: translate3d(-8px, 0, 0); }
      25% { opacity: 0.7; transform: translate3d(6px, 0, 0); }
      50% { opacity: 0.45; transform: translate3d(-3px, 0, 0); }
      75% { opacity: 0.35; transform: translate3d(2px, 0, 0); }
      100% { opacity: 0; transform: translate3d(0, 0, 0); }
    }
    @keyframes vhs-color {
      0% { opacity: 0.45; transform: translate3d(2px, 0, 0); }
      30% { opacity: 0.35; transform: translate3d(-3px, 0, 0); }
      60% { opacity: 0.2; transform: translate3d(2px, 0, 0); }
      100% { opacity: 0; transform: translate3d(0, 0, 0); }
    }
    #canvas-wrap .vhs-line {
      --shift-start: 0px;
      --shift-mid: 0px;
      --shift-end: 0px;
      --shift-clear: 0px;
      --skew-start: 0deg;
      --skew-mid: 0deg;
      --skew-end: 0deg;
      --line-opacity: 0.6;
      --line-brightness: 1.1;
      --line-hue: 0deg;
      position: absolute;
      left: -8%;
      width: 116%;
      top: 50%;
      height: 8px;
      pointer-events: none;
      background:
        linear-gradient(90deg, rgba(255, 0, 90, 0.25), rgba(0, 240, 255, 0.32)),
        repeating-linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.75) 0px,
          rgba(255, 255, 255, 0.75) 6px,
          rgba(255, 255, 255, 0.05) 6px,
          rgba(255, 255, 255, 0.05) 12px
        );
      background-size: 180px 100%, 20px 100%;
      mix-blend-mode: screen;
      box-shadow: 0 0 24px rgba(255, 139, 47, 0.4);
      opacity: 0;
      transform: translateX(var(--shift-start)) skewX(var(--skew-start));
      animation: vhs-line-burst 0.55s cubic-bezier(0.25, 0.8, 0.45, 1) forwards;
      filter: hue-rotate(var(--line-hue)) saturate(1.6) brightness(var(--line-brightness));
    }
    #canvas-wrap .vhs-line::before,
    #canvas-wrap .vhs-line::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    #canvas-wrap .vhs-line::before {
      background:
        repeating-linear-gradient(
          0deg,
          rgba(255, 139, 47, 0.45) 0px,
          rgba(255, 139, 47, 0.45) 2px,
          rgba(0, 0, 0, 0) 2px,
          rgba(0, 0, 0, 0) 4px
        );
      opacity: 0.8;
    }
    #canvas-wrap .vhs-line::after {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.4), transparent);
      mix-blend-mode: overlay;
      opacity: 0.5;
    }
    #canvas-wrap .vhs-line--cluster {
      box-shadow: 0 0 28px rgba(0, 240, 255, 0.32);
    }
    #canvas-wrap .vhs-line--cluster::before {
      background:
        repeating-linear-gradient(
          0deg,
          rgba(0, 240, 255, 0.35) 0px,
          rgba(0, 240, 255, 0.35) var(--cluster-thickness, 3px),
          rgba(0, 0, 0, 0) var(--cluster-thickness, 3px),
          rgba(0, 0, 0, 0) calc(var(--cluster-thickness, 3px) * 2)
        );
      opacity: 0.9;
    }
    @keyframes vhs-line-burst {
      0% {
        opacity: 0;
        transform: translateX(var(--shift-start)) skewX(var(--skew-start));
      }
      14% {
        opacity: calc(var(--line-opacity) + 0.2);
      }
      38% {
        opacity: var(--line-opacity);
        transform: translateX(var(--shift-mid)) skewX(var(--skew-mid));
      }
      70% {
        opacity: calc(var(--line-opacity) * 0.45);
        transform: translateX(var(--shift-end)) skewX(var(--skew-end));
      }
      100% {
        opacity: 0;
        transform: translateX(var(--shift-clear)) skewX(0deg);
      }
    }
    #resolution-display {
      font-size: 0.74rem;
      font-weight: 700;
      color: var(--text-white);
      text-shadow: 0 0 12px rgba(255, 139, 47, 0.4);
    }
    label[for="resolution-select"] {
      font-size: 0.62rem;
      color: var(--text-white);
    }
    .select-wrap {
      position: relative;
    }
    .select-wrap::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 12px;
      width: 8px;
      height: 8px;
      border-right: 2px solid var(--accent-orange);
      border-bottom: 2px solid var(--accent-orange);
      transform: translateY(-50%) rotate(45deg);
      pointer-events: none;
    }
    #resolution-select {
      width: 100%;
      padding: 6px 28px 6px 10px;
      border-radius: 0;
      border: 1px solid var(--frame-border);
      background: rgba(2, 8, 23, 0.65);
      color: var(--text-white);
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      appearance: none;
      outline: none;
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
    }
    #resolution-select:focus {
      border-color: var(--accent-orange);
      box-shadow: 0 0 0 1px rgba(255, 139, 47, 0.35), 0 0 0 4px rgba(255, 139, 47, 0.15);
    }
    #fullscreen-btn {
      position: fixed;
      left: 50%;
      bottom: 32px;
      transform: translateX(-50%);
      padding: 8px 26px;
      background: linear-gradient(160deg, rgba(2, 8, 23, 0.85), rgba(11, 26, 53, 0.85));
      border: 1px solid var(--frame-border);
      color: var(--text-white);
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      cursor: pointer;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);
      text-transform: uppercase;
      transition: transform 0.15s ease;
      z-index: 48;
      display: none;
      border-radius: 999px;
      align-items: center;
      justify-content: center;
      gap: 10px;
      backdrop-filter: blur(10px);
    }
    #fullscreen-btn:hover {
      transform: translateX(-50%) translateY(-2px);
    }
    #fullscreen-btn:active {
      transform: translateX(-50%) translateY(2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.55);
    }
    #control-pad {
      position: fixed;
      bottom: 22px;
      right: 22px;
      display: grid;
      grid-template-columns: repeat(3, 44px);
      grid-template-rows: repeat(3, 44px);
      gap: 8px;
      z-index: 35;
    }
    #control-pad button,
    #control-pad span {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      border: 1px solid var(--frame-border);
      background: rgba(2, 8, 23, 0.72);
      color: var(--text-white);
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 10px 16px rgba(0, 0, 0, 0.42);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      text-shadow: 0 0 10px rgba(255, 139, 47, 0.35);
    }
    #control-pad span {
      cursor: default;
      opacity: 0;
      box-shadow: none;
      border: none;
      pointer-events: none;
    }
    #control-pad button:active {
      transform: translateY(2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
    }
    @media (max-width: 720px) {
      #control-pad {
        right: 14px;
        bottom: 14px;
        grid-template-columns: repeat(3, 40px);
        grid-template-rows: repeat(3, 40px);
        gap: 6px;
      }
      #control-pad button,
      #control-pad span {
        width: 40px;
        height: 40px;
      }
      #control-ui {
        right: 10px;
        top: 10px;
        padding: 12px 12px 14px;
        width: min(200px, 82vw);
      }
      #ui-fold-btn {
        padding: 4px 8px;
        letter-spacing: 0.12em;
      }
    }
    #hud-overlay {
      position: fixed;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      display: grid;
      gap: 6px;
      padding: 14px 20px;
      background: rgba(2, 8, 23, 0.42);
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08), 0 12px 24px rgba(0, 0, 0, 0.35);
      font-family: 'Lucida Console', 'Courier New', monospace;
      font-size: 0.64rem;
      color: var(--text-white);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      min-width: min(420px, 94vw);
      max-width: min(560px, 94vw);
      z-index: 42;
      backdrop-filter: blur(12px);
      pointer-events: auto;
    }
    #hud-overlay .hud-title {
      display: grid;
      gap: 2px;
      color: var(--accent-orange);
      letter-spacing: 0.18em;
      font-size: 0.6rem;
      text-align: center;
      pointer-events: none;
    }
    #hud-overlay .hud-title span:last-child {
      color: rgba(255, 255, 255, 0.78);
      letter-spacing: 0.16em;
    }
    #hud-overlay .hud-line {
      pointer-events: none;
    }
    .hud-render-modes {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(118px, 1fr));
      gap: 8px;
      justify-content: center;
      pointer-events: auto;
    }
    .hud-render-modes button {
      padding: 6px 10px;
      background: rgba(2, 8, 23, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.24);
      color: rgba(255, 255, 255, 0.82);
      font-family: 'Lucida Console', 'Courier New', monospace;
      font-size: 0.56rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
    }
    .hud-render-modes button:hover {
      border-color: var(--accent-orange);
    }
    .hud-render-modes button:focus-visible {
      outline: 2px solid var(--accent-orange);
      outline-offset: 2px;
    }
    .hud-render-modes button.is-active {
      border-color: var(--accent-orange);
      background: rgba(255, 139, 47, 0.25);
      color: var(--text-white);
      text-shadow: 0 0 8px rgba(255, 139, 47, 0.35);
    }
    #hud-overlay .hud-line {
      display: flex;
      justify-content: space-between;
      gap: 18px;
    }
    #hud-overlay .hud-value {
      color: rgba(255, 255, 255, 0.86);
    }
    #console-dock {
      position: fixed;
      bottom: 0;
      left: 0;
      width: min(520px, 92vw);
      max-height: 220px;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 8px;
      background: rgba(2, 8, 23, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.55);
      font-family: 'Lucida Console', 'Courier New', monospace;
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      overflow: hidden;
      backdrop-filter: blur(10px);
      z-index: 36;
    }
    #console-dock .console-headline {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 0.62rem;
      color: var(--accent-orange);
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }
    #console-dock .console-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #console-dock .console-status {
      color: rgba(255, 255, 255, 0.72);
      letter-spacing: 0.12em;
    }
    #console-fold-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: rgba(2, 8, 23, 0.45);
      color: var(--text-white);
      font-family: inherit;
      font-size: 0.52rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    #console-fold-btn:hover {
      background: rgba(255, 139, 47, 0.2);
      border-color: rgba(255, 139, 47, 0.55);
      transform: translateY(-1px);
    }
    #console-fold-btn:active {
      transform: translateY(1px);
    }
    #console-fold-btn .fold-icon {
      width: 14px;
      height: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.35s ease;
    }
    #console-fold-btn .fold-icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
      transform-origin: center;
      transition: transform 0.35s ease;
    }
    #console-dock.folded #console-fold-btn .fold-icon svg {
      transform: rotate(-90deg);
    }
    #console-dock #console-log {
      position: relative;
      inset: auto;
      width: 100%;
      max-height: 160px;
      padding: 8px 12px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      pointer-events: auto;
      transition: max-height 0.35s ease, opacity 0.3s ease;
    }
    #console-dock #console-log .console-line {
      margin-bottom: 4px;
      white-space: pre-wrap;
    }
    #console-dock.folded #console-log {
      max-height: 0;
      opacity: 0;
      padding-top: 0;
      padding-bottom: 0;
      border-color: rgba(255, 255, 255, 0.06);
      pointer-events: none;
      overflow: hidden;
    }
    body.is-mobile {
      --hud-offset: 56px;
    }
    body.is-mobile #fullscreen-btn {
      top: 14px;
      right: 14px;
      bottom: auto;
      left: auto;
      transform: none;
      padding: 8px 18px;
      gap: 8px;
      font-size: 0.58rem;
      letter-spacing: 0.14em;
      box-shadow: 0 12px 22px rgba(0, 0, 0, 0.45);
    }
    body.is-mobile #fullscreen-btn::before {
      content: '';
      width: 12px;
      height: 12px;
      border: 2px solid currentColor;
      border-radius: 3px;
      transform: translateZ(0);
    }
    body.is-mobile #control-ui {
      top: 110px;
      right: 14px;
      left: 14px;
      width: auto;
      padding: 12px 14px 16px;
      border-radius: 14px;
      background: rgba(7, 17, 39, 0.55);
      row-gap: 10px;
    }
    body.is-mobile #control-ui.folded {
      background: rgba(7, 17, 39, 0.45);
    }
    body.is-mobile #control-ui h2 {
      font-size: 0.62rem;
    }
    body.is-mobile #hud-overlay {
      top: calc(14px + var(--hud-offset));
      width: calc(100% - 28px);
      min-width: 0;
      font-size: 0.56rem;
      gap: 4px;
      padding: 10px 14px;
    }
    body.is-mobile #hud-overlay .hud-title {
      font-size: 0.52rem;
    }
    body.is-mobile #hud-overlay .hud-title span:last-child {
      display: none;
    }
    body.is-mobile .hud-render-modes {
      grid-template-columns: 1fr;
      gap: 6px;
    }
    body.is-mobile .hud-render-modes button {
      padding: 5px 8px;
      font-size: 0.52rem;
    }
    body.is-mobile #control-pad {
      right: 14px;
      bottom: 108px;
      grid-template-columns: repeat(3, 36px);
      grid-template-rows: repeat(3, 36px);
      gap: 6px;
    }
    body.is-mobile #control-pad button,
    body.is-mobile #control-pad span {
      width: 36px;
      height: 36px;
      font-size: 1.1rem;
    }
    body.is-mobile #fps {
      top: 14px;
      left: 14px;
      right: auto;
      bottom: auto;
    }
    body.is-mobile #console-dock {
      bottom: 14px;
      left: 14px;
      right: auto;
      width: min(320px, 74vw);
      max-height: 42vh;
      padding: 10px 12px;
      border-radius: 16px;
      gap: 6px;
      font-size: 0.6rem;
    }
    body.is-mobile #console-dock .console-headline {
      font-size: 0.54rem;
    }
    body.is-mobile #console-dock #console-log {
      max-height: 28vh;
    }
    body.is-mobile #console-dock.folded {
      width: auto;
      padding: 8px 12px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.5);
    }
    body.is-mobile #console-dock.folded #console-status,
    body.is-mobile #console-dock.folded #console-log {
      display: none;
    }
  </style>
</head>
<body>
  <div id="scene-shell">
    <div id="canvas-wrap"></div>
  </div>
  <div id="control-ui">
    <div class="ui-header">
      <h2>
        <span class="ui-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="presentation">
            <polygon points="12,2 22,7 22,17 12,22 2,17 2,7" opacity="0.4"></polygon>
            <polygon points="12,4.5 19.5,8.2 19.5,15.8 12,19.5 4.5,15.8 4.5,8.2" fill="currentColor"></polygon>
            <path d="M9 10h2v2H9zm4 0h2v2h-2zm-2 3h2v2h-2z" fill="var(--accent-orange)"></path>
          </svg>
        </span>
        <span>RESOLUTION</span>
      </h2>
        <button id="ui-fold-btn" type="button" aria-label="Collapse control panel" aria-expanded="true" aria-controls="ui-foldable">
          <span class="fold-icon" aria-hidden="true">
            <svg viewBox="0 0 16 16" role="presentation" focusable="false">
              <path d="M4.2 2.8a1 1 0 0 1 1.6 0l4 5a1 1 0 0 1 0 1.2l-4 5a1 1 0 0 1-1.6-1.2L7.7 8 4.2 4a1 1 0 0 1 0-1.2z"></path>
            </svg>
          </span>
        </button>
    </div>
    <div id="ui-foldable" class="fold-body">
      <div id="resolution-display">—</div>
      <label for="resolution-select">Resolution</label>
      <div class="select-wrap">
        <select id="resolution-select" aria-label="Resolution selector">
        <option value="256x192">ZX Spectrum — 256 × 192</option>
        <option value="320x200">Commodore 64 — 320 × 200</option>
        <option value="320x256">Amiga 500 (PAL Lowres) — 320 × 256</option>
        <option value="640x512">Amiga 500 (PAL HiRes) — 640 × 512</option>
        <option value="640x480">VGA Era — 640 × 480</option>
        <option value="800x600">SVGA Era — 800 × 600</option>
        <option value="640x360">EDTV 360p — 640 × 360</option>
        <option value="854x480">Wide 480p — 854 × 480</option>
        <option value="960x540">qHD 540p — 960 × 540</option>
        <option value="1024x576">WSVGA — 1024 × 576</option>
        <option value="1280x720" selected>HD 720p — 1280 × 720</option>
        <option value="1366x768">HD 768p — 1366 × 768</option>
        <option value="1600x900">HD+ — 1600 × 900</option>
        <option value="1920x1080">Full HD — 1920 × 1080</option>
        <option value="2560x1440">Quad HD — 2560 × 1440</option>
        <option value="3200x1800">QHD+ — 3200 × 1800</option>
        <option value="3840x2160">4K Ultra HD — 3840 × 2160</option>
        </select>
      </div>
    </div>
  </div>
  <button id="fullscreen-btn" type="button">Enter Fullscreen</button>
  <div id="control-pad">
    <span></span>
    <button data-key="ArrowUp" aria-label="Move forward">▲</button>
    <span></span>
    <button data-key="ArrowLeft" aria-label="Turn left">◀</button>
    <span></span>
    <button data-key="ArrowRight" aria-label="Turn right">▶</button>
    <span></span>
    <button data-key="ArrowDown" aria-label="Move backward">▼</button>
    <span></span>
  </div>
  <div id="hud-overlay" aria-live="polite">
    <div class="hud-title">
      <span>Terrain Telemetry Uplink // Horizon Sweep</span>
      <span>Orbital Metrics Stream — Vectors Locked</span>
    </div>
    <div class="hud-render-modes" role="group" aria-label="Rendering mode">
      <button type="button" class="render-mode-btn is-active" data-render-mode="default" aria-pressed="true">Default</button>
      <button type="button" class="render-mode-btn" data-render-mode="wire" aria-pressed="false">Wired Vectors</button>
      <button type="button" class="render-mode-btn" data-render-mode="zx" aria-pressed="false">ZX Spectrum</button>
      <button type="button" class="render-mode-btn" data-render-mode="petscii" aria-pressed="false">Commodore PETSCII</button>
      <button type="button" class="render-mode-btn" data-render-mode="signature" aria-pressed="false">Signature 8</button>
    </div>
    <div class="hud-line"><span>Position</span><span class="hud-value" data-hud="position">0, 0, 0</span></div>
    <div class="hud-line"><span>Heading</span><span class="hud-value" data-hud="heading">0° / 0°</span></div>
    <div class="hud-line"><span>Chunk</span><span class="hud-value" data-hud="chunk">0, 0</span></div>
    <div class="hud-line"><span>Speed</span><span class="hud-value" data-hud="speed">0 m/s</span></div>
  </div>
  <div id="fps"></div>
  <div id="console-dock" class="folded">
    <div class="console-headline">
      <span class="console-title">Console Log</span>
      <div class="console-actions">
        <span id="console-status" class="console-status">Folded</span>
        <button id="console-fold-btn" type="button" aria-label="Expand console log" aria-expanded="false" aria-controls="console-log">
          <span class="fold-icon" aria-hidden="true">
            <svg viewBox="0 0 16 16" role="presentation" focusable="false">
              <path d="M4.2 2.8a1 1 0 0 1 1.6 0l4 5a1 1 0 0 1 0 1.2l-4 5a1 1 0 0 1-1.6-1.2L7.7 8 4.2 4a1 1 0 0 1 0-1.2z"></path>
            </svg>
          </span>
        </button>
      </div>
    </div>
    <div id="console-log" role="log" aria-live="polite"></div>
  </div>
  <div id="loader">
    <div class="loader-content">
      <div class="loader-icon" aria-hidden="true">
        <canvas id="loader-canvas" width="192" height="144" role="presentation"></canvas>
      </div>
      <div class="loader-text">Loading <span id="progress">0%</span></div>
      <div class="loader-meta">© 2025 Cyborgs Dream</div>
    </div>
  </div>
  
  <script type="module">
  import { initConsoleLogs } from '../../shared/consolelogs.js';

  const loaderEl = document.getElementById('loader');
  const loaderProgressEl = document.getElementById('progress');
  const loaderTextEl = loaderEl?.querySelector('.loader-text');
  const loaderMetaEl = loaderEl?.querySelector('.loader-meta');

  let loaderProgressValue = 0;
  let loaderPhaseStart = 0;
  let loaderPhaseEnd = 100;
  let loaderStatusMessage = '';

  function refreshLoaderProgressText() {
    if (!loaderProgressEl) return;
    const percentText = `${Math.round(loaderProgressValue)}%`;
    loaderProgressEl.textContent = loaderStatusMessage
      ? `${percentText} (${loaderStatusMessage})`
      : percentText;
  }

  function setProgress(percent) {
    loaderProgressValue = Number.isFinite(percent)
      ? Math.max(0, Math.min(100, percent))
      : 0;
    refreshLoaderProgressText();
  }

  function setLoaderPhaseRange(start, end) {
    loaderPhaseStart = Number.isFinite(start) ? Math.max(0, Math.min(100, start)) : 0;
    loaderPhaseEnd = Number.isFinite(end)
      ? Math.max(loaderPhaseStart, Math.min(100, end))
      : loaderPhaseStart;
  }

  function reportLoaderPhaseProgress(fraction) {
    const span = loaderPhaseEnd - loaderPhaseStart;
    const clamped = Number.isFinite(fraction) ? Math.max(0, Math.min(1, fraction)) : 0;
    const percent = loaderPhaseStart + span * clamped;
    setProgress(percent);
  }

  function updateLoaderStatus(message) {
    loaderStatusMessage = typeof message === 'string' ? message.trim() : '';
    refreshLoaderProgressText();
  }

  function hideLoader(success = true) {
    if (!loaderEl) return;
    if (!success) {
      loaderEl.classList.add('is-error');
      if (loaderTextEl) loaderTextEl.textContent = 'Terrain offline mode';
      if (loaderMetaEl) loaderMetaEl.textContent = 'Fallback renderer active';
      return;
    }
    loaderEl.style.pointerEvents = 'none';
    loaderEl.style.transition = 'opacity 0.8s ease';
    loaderEl.style.opacity = '0';
    setTimeout(() => loaderEl.remove(), 900);
  }

  const RESOLUTIONS = [
    { label: 'ZX Spectrum', width: 256, height: 192 },
    { label: 'Commodore 64', width: 320, height: 200 },
    { label: 'Amiga 500 PAL Lowres', width: 320, height: 256 },
    { label: 'Amiga 500 PAL HiRes', width: 640, height: 512 },
    { label: 'VGA Era', width: 640, height: 480 },
    { label: 'SVGA Era', width: 800, height: 600 },
    { label: 'EDTV 360p', width: 640, height: 360 },
    { label: 'Wide 480p', width: 854, height: 480 },
    { label: 'qHD 540p', width: 960, height: 540 },
    { label: 'WSVGA', width: 1024, height: 576 },
    { label: 'HD 720p', width: 1280, height: 720 },
    { label: 'HD 768p', width: 1366, height: 768 },
    { label: 'HD+', width: 1600, height: 900 },
    { label: 'Full HD', width: 1920, height: 1080 },
    { label: 'Quad HD', width: 2560, height: 1440 },
    { label: 'QHD+', width: 3200, height: 1800 },
    { label: '4K Ultra HD', width: 3840, height: 2160 }
  ];

  const defaultResolution = RESOLUTIONS.find(r => r.width === 1280 && r.height === 720) || RESOLUTIONS[0];

  const retroPalettes = {
    zx: [
      0x000000, 0x0000d7, 0xd70000, 0xd700d7,
      0x00d700, 0x00d7d7, 0xd7d700, 0xd7d7d7,
      0x000000, 0x0000ff, 0xff0000, 0xff00ff,
      0x00ff00, 0x00ffff, 0xffff00, 0xffffff
    ],
    petscii: [
      0x000000, 0xffffff, 0x68372b, 0x70a4b2,
      0x6f3d86, 0x588d43, 0x352879, 0xb8c76f,
      0x6f4f25, 0x433900, 0x9a6759, 0x444444,
      0x6c6c6c, 0x9ad284, 0x6c5eb5, 0x959595
    ],
    signature: [
      0xda291c, 0xf6eb61, 0x00b140, 0x00a9e0,
      0x005eb8, 0xff6a13, 0xffffff, 0x000000
    ]
  };

  const renderModeFogColors = {
    default: [0.02, 0.08, 0.15],
    wire: [0.02, 0.08, 0.15],
    zx: [0.0, 0.0, 0.52],
    petscii: [0.0, 0.08, 0.05],
    signature: [0.0, 0.102, 0.2]
  };

  const renderModeCanvasBackgrounds = {
    default: '#020817',
    wire: '#020817',
    zx: '#0000d7',
    petscii: '#00140a',
    signature: '#001933'
  };

  let stopLoaderAnimation = () => {};
  {
    const loaderCanvas = document.getElementById('loader-canvas');
    if (loaderCanvas) {
      const ctx = loaderCanvas.getContext('2d', { alpha: true });
      if (ctx) {
        ctx.imageSmoothingEnabled = false;
        const width = loaderCanvas.width;
        const height = loaderCanvas.height;
        const centerX = width / 2;
        const centerY = height / 2;
        const tau = Math.PI * 2;
        let rafId = null;
        const faces = 20;
        const radius = Math.min(width, height) * 0.22;
        const baseHue = 208;
        const draw = (time) => {
          ctx.clearRect(0, 0, width, height);
          ctx.save();
          ctx.translate(centerX, centerY);
          ctx.rotate(time * 0.00035);
          for (let i = 0; i < faces; i++) {
            const angle = (i / faces) * tau;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            const hue = (baseHue + i * 9) % 360;
            const scale = 0.4 + (Math.sin(time * 0.001 + i * 1.3) + 1) * 0.3;
            ctx.save();
            ctx.translate(x, y);
            ctx.rotate(angle + time * 0.0005);
            ctx.scale(scale, scale);
            ctx.fillStyle = `hsla(${hue}, 72%, 62%, 0.85)`;
            ctx.beginPath();
            ctx.moveTo(0, -22);
            ctx.lineTo(18, 12);
            ctx.lineTo(-18, 12);
            ctx.closePath();
            ctx.fill();
            ctx.restore();
          }
          ctx.restore();
          rafId = requestAnimationFrame(draw);
        };
        rafId = requestAnimationFrame(draw);
        stopLoaderAnimation = () => {
          if (rafId !== null) {
            cancelAnimationFrame(rafId);
            rafId = null;
          }
        };
      }
    }
  }

  const fpsHolder = document.getElementById('fps');

  class FpsMonitor {
    constructor(container) {
      this.dom = document.createElement('div');
      this.dom.id = 'fps-monitor';

      const iconMarkup = `
        <span class="ui-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="presentation">
            <polygon points="12,2 22,7 22,17 12,22 2,17 2,7" opacity="0.35"></polygon>
            <polygon points="12,4.5 19.5,8.2 19.5,15.8 12,19.5 4.5,15.8 4.5,8.2" fill="currentColor"></polygon>
            <path d="M8 15h2.5V9H8zm5-6v8h-2.5V9zm2.5 0H18v10h-2.5z" fill="var(--accent-orange)"></path>
          </svg>
        </span>`;

      this.titleEl = document.createElement('div');
      this.titleEl.className = 'panel-title';
      this.titleEl.innerHTML = `${iconMarkup}<span class="label">Performance</span>`;
      this.dom.appendChild(this.titleEl);

      this.readoutEl = document.createElement('div');
      this.readoutEl.className = 'fps-readout';

      this.labelEl = document.createElement('div');
      this.labelEl.className = 'fps-label';
      this.labelEl.textContent = 'fps';

      this.valueEl = document.createElement('div');
      this.valueEl.className = 'fps-value';
      this.valueEl.textContent = '000';

      this.readoutEl.appendChild(this.labelEl);
      this.readoutEl.appendChild(this.valueEl);

      this.graphCanvas = document.createElement('canvas');
      this.graphCanvas.width = 160;
      this.graphCanvas.height = 60;
      this.graphCanvas.className = 'fps-graph';
      this.graphCtx = this.graphCanvas.getContext('2d');

      this.maxSamples = this.graphCanvas.width;
      this.samples = new Array(this.maxSamples).fill(0);
      this.referenceFps = 120;
      this.sampleWindow = 250;
      this.frameCount = 0;
      this.lastSample = performance.now();
      this.smoothed = 0;

      this.dom.appendChild(this.readoutEl);
      this.dom.appendChild(this.graphCanvas);
      container.appendChild(this.dom);

      this.drawGraph();
    }

    begin() {}

    end() {
      const now = performance.now();
      this.frameCount += 1;
      if (now - this.lastSample >= this.sampleWindow) {
        const elapsed = now - this.lastSample;
        const fps = (this.frameCount * 1000) / elapsed;
        this.frameCount = 0;
        this.lastSample = now;
        this.update(fps);
      }
    }

    update(rawFps) {
      const fps = Math.max(0, rawFps);
      this.smoothed = this.smoothed === 0 ? fps : (this.smoothed * 0.7 + fps * 0.3);
      const rounded = Math.max(0, Math.round(this.smoothed));
      this.valueEl.textContent = `${rounded.toString().padStart(3, '0')}`;
      this.samples.push(fps);
      if (this.samples.length > this.maxSamples) {
        this.samples.shift();
      }
      this.drawGraph();
    }

    drawGraph() {
      const ctx = this.graphCtx;
      const width = this.graphCanvas.width;
      const height = this.graphCanvas.height;
      ctx.clearRect(0, 0, width, height);

      const style = getComputedStyle(document.documentElement);
      const background = style.getPropertyValue('--navy-900').trim() || '#020817';
      const gridColor = style.getPropertyValue('--graph-grid').trim() || 'rgba(255, 255, 255, 0.18)';
      const fillColor = style.getPropertyValue('--graph-fill').trim() || 'rgba(255, 139, 47, 0.18)';
      const lineColor = style.getPropertyValue('--graph-line').trim() || '#ff8b2f';

      ctx.fillStyle = background;
      ctx.fillRect(0, 0, width, height);

      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      const gridLines = 4;
      for (let i = 1; i < gridLines; i++) {
        const y = Math.round((height / gridLines) * i) + 0.5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      const highestSample = this.samples.reduce((max, value) => Math.max(max, value), 0);
      const scaleMax = Math.max(this.referenceFps, highestSample, 30);
      const verticalPadding = 2;
      const usableHeight = height - verticalPadding * 2;

      ctx.beginPath();
      ctx.moveTo(0, height - verticalPadding);
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(width, height - verticalPadding);
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();

      ctx.beginPath();
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
      }
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  const fpsMonitor = new FpsMonitor(fpsHolder);

  const canvasWrap = document.getElementById('canvas-wrap');
  const canvas = document.createElement('canvas');
  canvas.id = 'terrain-canvas';
  canvasWrap.appendChild(canvas);

  const gl = canvas.getContext('webgl2', { antialias: true, alpha: false });
  if (!gl) {
    console.error('WebGL2 is required for the Terrain experience.');
    hideLoader(false);
    return;
  }

  const ZX_PALETTE = retroPalettes.zx.map(hex => [
    ((hex >> 16) & 255) / 255,
    ((hex >> 8) & 255) / 255,
    (hex & 255) / 255
  ]);
  const PET_PALETTE = retroPalettes.petscii.map(hex => [
    ((hex >> 16) & 255) / 255,
    ((hex >> 8) & 255) / 255,
    (hex & 255) / 255
  ]);
  const SIGNATURE_PALETTE = retroPalettes.signature.map(hex => [
    ((hex >> 16) & 255) / 255,
    ((hex >> 8) & 255) / 255,
    (hex & 255) / 255
  ]);

  const flattenedZX = new Float32Array(ZX_PALETTE.flat());
  const flattenedPET = new Float32Array(PET_PALETTE.flat());
  const flattenedSignature = new Float32Array(SIGNATURE_PALETTE.flat());

  function createShader(type, source) {
    const shader = gl.createShader(type);
    gl.shaderSource(shader, source);
    gl.compileShader(shader);
    if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
      const error = gl.getShaderInfoLog(shader) || 'Unknown shader compilation error';
      gl.deleteShader(shader);
      throw new Error(error);
    }
    return shader;
  }

  function createProgram(vertexSrc, fragmentSrc) {
    const program = gl.createProgram();
    gl.attachShader(program, createShader(gl.VERTEX_SHADER, vertexSrc));
    gl.attachShader(program, createShader(gl.FRAGMENT_SHADER, fragmentSrc));
    gl.linkProgram(program);
    if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
      const error = gl.getProgramInfoLog(program) || 'Unknown program link error';
      gl.deleteProgram(program);
      throw new Error(error);
    }
    return program;
  }

  function hash(ix, iz) {
    const s = Math.sin(ix * 127.1 + iz * 311.7) * 43758.5453123;
    return s - Math.floor(s);
  }

  function smooth(t) {
    return t * t * (3 - 2 * t);
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function noise2(x, z) {
    const ix = Math.floor(x);
    const iz = Math.floor(z);
    const fx = x - ix;
    const fz = z - iz;
    const a = hash(ix, iz);
    const b = hash(ix + 1, iz);
    const c = hash(ix, iz + 1);
    const d = hash(ix + 1, iz + 1);
    const ux = smooth(fx);
    const uz = smooth(fz);
    return lerp(lerp(a, b, ux), lerp(c, d, ux), uz);
  }

  function fbm(x, z, octaves = 5) {
    let amp = 1;
    let freq = 0.0045;
    let sum = 0;
    let norm = 0;
    for (let i = 0; i < octaves; i++) {
      sum += amp * noise2(x * freq, z * freq);
      norm += amp;
      amp *= 0.5;
      freq *= 2;
    }
    return sum / Math.max(1e-5, norm);
  }

  const waitForNextFrame = () => new Promise(resolve => requestAnimationFrame(resolve));

  async function generateTerrainGeometry(size, segments, onProgress) {
    const vertexCount = (segments + 1) * (segments + 1);
    const positions = new Float32Array(vertexCount * 3);
    const normals = new Float32Array(vertexCount * 3);
    const uvs = new Float32Array(vertexCount * 2);
    const heights = new Float32Array(vertexCount);
    const indices = new Uint32Array(segments * segments * 6);
    const halfSize = size / 2;
    const step = size / segments;
    const segmentsPlusOne = segments + 1;

    const notifyProgress = (value) => {
      if (typeof onProgress === 'function') {
        onProgress(Math.max(0, Math.min(1, value)));
      }
    };

    const yieldInterval = Math.max(1, Math.floor(segments / 12));

    let vertexIndex = 0;
    notifyProgress(0);
    for (let z = 0; z <= segments; z++) {
      const rowFraction = z / segmentsPlusOne;
      notifyProgress(rowFraction * 0.6);
      for (let x = 0; x <= segments; x++) {
        const worldX = -halfSize + x * step;
        const worldZ = -halfSize + z * step;
        const height = fbm(worldX, worldZ) * 120 - 36;
        const idx = vertexIndex * 3;
        positions[idx] = worldX;
        positions[idx + 1] = height;
        positions[idx + 2] = worldZ;
        heights[vertexIndex] = height;
        const uvIdx = vertexIndex * 2;
        uvs[uvIdx] = x / segments;
        uvs[uvIdx + 1] = z / segments;
        vertexIndex += 1;
      }
      if (z % yieldInterval === 0) {
        await waitForNextFrame();
      }
    }

    const sample = (ix, iz) => {
      const clampedX = Math.max(0, Math.min(segments, ix));
      const clampedZ = Math.max(0, Math.min(segments, iz));
      return heights[clampedZ * (segments + 1) + clampedX];
    };

    vertexIndex = 0;
    for (let z = 0; z <= segments; z++) {
      const normalRowFraction = z / segmentsPlusOne;
      notifyProgress(0.6 + 0.3 * normalRowFraction);
      for (let x = 0; x <= segments; x++) {
        const left = sample(x - 1, z);
        const right = sample(x + 1, z);
        const down = sample(x, z - 1);
        const up = sample(x, z + 1);
        const dx = (right - left) / (2 * step);
        const dz = (up - down) / (2 * step);
        const nx = -dx;
        const ny = 1;
        const nz = -dz;
        const length = Math.hypot(nx, ny, nz) || 1;
        const idx = vertexIndex * 3;
        normals[idx] = nx / length;
        normals[idx + 1] = ny / length;
        normals[idx + 2] = nz / length;
        vertexIndex += 1;
      }
      if (z % yieldInterval === 0) {
        await waitForNextFrame();
      }
    }

    let writeIndex = 0;
    for (let z = 0; z < segments; z++) {
      const indexRowFraction = segments > 0 ? z / segments : 1;
      notifyProgress(0.9 + 0.1 * indexRowFraction);
      for (let x = 0; x < segments; x++) {
        const a = z * (segments + 1) + x;
        const b = a + 1;
        const c = (z + 1) * (segments + 1) + x;
        const d = c + 1;
        indices[writeIndex++] = a;
        indices[writeIndex++] = c;
        indices[writeIndex++] = b;
        indices[writeIndex++] = b;
        indices[writeIndex++] = c;
        indices[writeIndex++] = d;
      }
      if (z % yieldInterval === 0) {
        await waitForNextFrame();
      }
    }

    notifyProgress(1);

    return { positions, normals, uvs, indices, heights, segments, size, step };
  }

  const vertexShaderSource = `#version 300 es
`
    + `precision highp float;
`
    + `layout(location = 0) in vec3 aPosition;
`
    + `layout(location = 1) in vec3 aNormal;
`
    + `layout(location = 2) in vec2 aUv;
`
    + `uniform mat4 uProjection;
`
    + `uniform mat4 uView;
`
    + `uniform mat4 uModel;
`
    + `out vec3 vNormal;
`
    + `out vec3 vWorldPos;
`
    + `out vec2 vUv;
`
    + `void main() {
`
    + `  vec4 worldPos = uModel * vec4(aPosition, 1.0);
`
    + `  vWorldPos = worldPos.xyz;
`
    + `  vNormal = mat3(uModel) * aNormal;
`
    + `  vUv = aUv;
`
    + `  gl_Position = uProjection * uView * worldPos;
`
    + `}`;

  const fragmentShaderSource = `#version 300 es
`
    + `precision highp float;
`
    + `in vec3 vNormal;
`
    + `in vec3 vWorldPos;
`
    + `in vec2 vUv;
`
    + `uniform vec3 uLightDir;
`
    + `uniform vec3 uFogColor;
`
    + `uniform vec3 uCameraPos;
`
    + `uniform float uFogNear;
`
    + `uniform float uFogFar;
`
    + `uniform float uGridSize;
`
    + `uniform int uRenderMode;
`
    + `uniform vec3 uZXPalette[16];
`
    + `uniform vec3 uPetsciiPalette[16];
`
    + `uniform vec3 uSignaturePalette[8];
`
    + `out vec4 outColor;
`
    + `float gridFactor(vec2 uv, float gridSize) {
`
    + `  vec2 scaled = fract(uv * gridSize);
`
    + `  vec2 dist = min(scaled, 1.0 - scaled);
`
    + `  float edge = min(dist.x, dist.y);
`
    + `  return smoothstep(0.0, 0.12, edge * 8.0);
`
    + `}
`
    + `vec3 quantize(vec3 color, vec3 palette[16]) {
`
    + `  float best = 1e9;
`
    + `  vec3 chosen = color;
`
    + `  for (int i = 0; i < 16; i++) {
`
    + `    vec3 p = palette[i];
`
    + `    float d = distance(color, p);
`
    + `    if (d < best) {
`
    + `      best = d;
`
    + `      chosen = p;
`
    + `    }
`
    + `  }
`
    + `  return chosen;
`
    + `}
`
    + `vec3 quantize8(vec3 color, vec3 palette[8]) {
`
    + `  float best = 1e9;
`
    + `  vec3 chosen = color;
`
    + `  for (int i = 0; i < 8; i++) {
`
    + `    vec3 p = palette[i];
`
    + `    float d = distance(color, p);
`
    + `    if (d < best) {
`
    + `      best = d;
`
    + `      chosen = p;
`
    + `    }
`
    + `  }
`
    + `  return chosen;
`
    + `}
`
    + `void main() {
`
    + `  vec3 normal = normalize(vNormal);
`
    + `  float diffuse = max(dot(normal, normalize(uLightDir)), 0.0);
`
    + `  float ambient = 0.25;
`
    + `  float lighting = ambient + diffuse * 0.85;
`
    + `  float h = clamp((vWorldPos.y + 48.0) / 160.0, 0.0, 1.0);
`
    + `  vec3 low = vec3(0.05, 0.15, 0.25);
`
    + `  vec3 mid = vec3(0.18, 0.38, 0.45);
`
    + `  vec3 high = vec3(0.82, 0.82, 0.78);
`
    + `  vec3 base = mix(low, mid, smoothstep(0.0, 0.55, h));
`
    + `  base = mix(base, high, smoothstep(0.45, 1.0, h));
`
    + `  vec3 color = base * lighting;
`
    + `  if (uRenderMode == 1) {
`
    + `    float grid = gridFactor(vUv, uGridSize);
`
    + `    vec3 wireBase = mix(vec3(0.03, 0.16, 0.28), vec3(0.4, 0.82, 1.0), grid);
`
    + `    color = mix(vec3(0.1, 0.22, 0.36), wireBase, lighting);
`
    + `  } else if (uRenderMode == 2) {
`
    + `    color = quantize(color, uZXPalette);
`
    + `  } else if (uRenderMode == 3) {
`
    + `    color = quantize(color, uPetsciiPalette);
`
    + `  } else if (uRenderMode == 4) {
`
    + `    color = quantize8(color, uSignaturePalette);
`
    + `  }
`
    + `  float dist = distance(uCameraPos, vWorldPos);
`
    + `  float fogFactor = clamp((uFogFar - dist) / (uFogFar - uFogNear), 0.0, 1.0);
`
    + `  vec3 finalColor = mix(uFogColor, color, fogFactor);
`
    + `  outColor = vec4(finalColor, 1.0);
`
    + `}`;

  const program = createProgram(vertexShaderSource, fragmentShaderSource);
  gl.useProgram(program);

  updateLoaderStatus('Generating terrain mesh…');
  setLoaderPhaseRange(10, 65);
  const geometry = await generateTerrainGeometry(600, 160, fraction => {
    reportLoaderPhaseProgress(fraction);
  });

  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);

  const positionBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, geometry.positions, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(0);
  gl.vertexAttribPointer(0, 3, gl.FLOAT, false, 0, 0);

  const normalBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, geometry.normals, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(1);
  gl.vertexAttribPointer(1, 3, gl.FLOAT, false, 0, 0);

  const uvBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, uvBuffer);
  gl.bufferData(gl.ARRAY_BUFFER, geometry.uvs, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(2);
  gl.vertexAttribPointer(2, 2, gl.FLOAT, false, 0, 0);

  const indexBuffer = gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, geometry.indices, gl.STATIC_DRAW);

  gl.bindVertexArray(null);

  const uniforms = {
    projection: gl.getUniformLocation(program, 'uProjection'),
    view: gl.getUniformLocation(program, 'uView'),
    model: gl.getUniformLocation(program, 'uModel'),
    lightDir: gl.getUniformLocation(program, 'uLightDir'),
    fogColor: gl.getUniformLocation(program, 'uFogColor'),
    fogNear: gl.getUniformLocation(program, 'uFogNear'),
    fogFar: gl.getUniformLocation(program, 'uFogFar'),
    cameraPos: gl.getUniformLocation(program, 'uCameraPos'),
    renderMode: gl.getUniformLocation(program, 'uRenderMode'),
    gridSize: gl.getUniformLocation(program, 'uGridSize'),
    zxPalette: gl.getUniformLocation(program, 'uZXPalette'),
    petsciiPalette: gl.getUniformLocation(program, 'uPetsciiPalette'),
    signaturePalette: gl.getUniformLocation(program, 'uSignaturePalette')
  };

  const identityMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]);
  gl.useProgram(program);
  gl.uniformMatrix4fv(uniforms.model, false, identityMatrix);
  gl.uniform3fv(uniforms.lightDir, new Float32Array([-0.35, 0.9, 0.32]));
  gl.uniform1f(uniforms.gridSize, geometry.segments);
  gl.uniform3fv(uniforms.zxPalette, flattenedZX);
  gl.uniform3fv(uniforms.petsciiPalette, flattenedPET);
  gl.uniform3fv(uniforms.signaturePalette, flattenedSignature);

  gl.enable(gl.DEPTH_TEST);
  gl.enable(gl.CULL_FACE);
  gl.cullFace(gl.BACK);

  function mat4Perspective(out, fovy, aspect, near, far) {
    const f = 1 / Math.tan(fovy / 2);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = (far + near) / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = (2 * far * near) / (near - far);
    out[15] = 0;
    return out;
  }

  function mat4LookAt(out, eye, center, up) {
    const fx = center[0] - eye[0];
    const fy = center[1] - eye[1];
    const fz = center[2] - eye[2];
    const fl = Math.hypot(fx, fy, fz) || 1;
    const f0 = fx / fl;
    const f1 = fy / fl;
    const f2 = fz / fl;

    const sx = f1 * up[2] - f2 * up[1];
    const sy = f2 * up[0] - f0 * up[2];
    const sz = f0 * up[1] - f1 * up[0];
    const sl = Math.hypot(sx, sy, sz) || 1;
    const s0 = sx / sl;
    const s1 = sy / sl;
    const s2 = sz / sl;

    const ux = s1 * f2 - s2 * f1;
    const uy = s2 * f0 - s0 * f2;
    const uz = s0 * f1 - s1 * f0;

    out[0] = s0; out[1] = ux; out[2] = -f0; out[3] = 0;
    out[4] = s1; out[5] = uy; out[6] = -f1; out[7] = 0;
    out[8] = s2; out[9] = uz; out[10] = -f2; out[11] = 0;
    out[12] = -(s0 * eye[0] + s1 * eye[1] + s2 * eye[2]);
    out[13] = -(ux * eye[0] + uy * eye[1] + uz * eye[2]);
    out[14] = f0 * eye[0] + f1 * eye[1] + f2 * eye[2];
    out[15] = 1;
    return out;
  }

  const viewMatrix = new Float32Array(16);
  const projectionMatrix = new Float32Array(16);

  const hudPosition = document.querySelector('[data-hud="position"]');
  const hudHeading = document.querySelector('[data-hud="heading"]');
  const hudChunk = document.querySelector('[data-hud="chunk"]');
  const hudSpeed = document.querySelector('[data-hud="speed"]');

  const camera = {
    target: new Float32Array([0, 0, 0]),
    position: new Float32Array([0, 0, 0]),
    yaw: Math.PI * 0.75,
    pitch: -0.55,
    minPitch: -1.25,
    maxPitch: -0.12,
    distance: 440,
    minDistance: 140,
    maxDistance: 820,
    verticalOffset: 42,
    speed: 82,
    turnSpeed: 1.4,
    smoothing: 8,
    heightSample: geometry,
    lastMoveTime: performance.now(),
    lastTarget: new Float32Array([0, 0, 0]),
    currentSpeed: 0
  };

  const keyState = Object.create(null);
  const pointerState = {
    active: false,
    id: null,
    lastX: 0,
    lastY: 0,
    pointerType: 'mouse'
  };

  function getHeightAt(x, z) {
    const { size, segments, step, heights } = geometry;
    const half = size / 2;
    const fx = (x + half) / step;
    const fz = (z + half) / step;
    const ix = Math.max(0, Math.min(segments, Math.floor(fx)));
    const iz = Math.max(0, Math.min(segments, Math.floor(fz)));
    const fracX = fx - ix;
    const fracZ = fz - iz;
    const base = iz * (segments + 1) + ix;
    const a = heights[base];
    const b = heights[base + 1] ?? a;
    const c = heights[base + segments + 1] ?? a;
    const d = heights[base + segments + 2] ?? a;
    const top = lerp(a, b, fracX);
    const bottom = lerp(c, d, fracX);
    return lerp(top, bottom, fracZ);
  }

  function updateCamera(dt) {
    const forward = [Math.sin(camera.yaw), 0, Math.cos(camera.yaw)];
    const right = [Math.cos(camera.yaw), 0, -Math.sin(camera.yaw)];
    let moveX = 0;
    let moveZ = 0;
    const forwardInput = (keyState['w'] || keyState['W'] || keyState['ArrowUp'] ? 1 : 0)
      - (keyState['s'] || keyState['S'] || keyState['ArrowDown'] ? 1 : 0);
    const strafeInput = (keyState['d'] || keyState['D'] ? 1 : 0)
      - (keyState['a'] || keyState['A'] ? 1 : 0);
    moveX += forward[0] * forwardInput + right[0] * strafeInput;
    moveZ += forward[2] * forwardInput + right[2] * strafeInput;

    if (keyState['ArrowLeft']) camera.yaw -= camera.turnSpeed * dt;
    if (keyState['ArrowRight']) camera.yaw += camera.turnSpeed * dt;

    const len = Math.hypot(moveX, moveZ);
    if (len > 0) {
      moveX /= len;
      moveZ /= len;
      const speed = camera.speed * dt;
      camera.target[0] += moveX * speed;
      camera.target[2] += moveZ * speed;
    }

    camera.yaw = (camera.yaw + Math.PI * 2) % (Math.PI * 2);

    const targetHeight = getHeightAt(camera.target[0], camera.target[2]);
    camera.target[1] = targetHeight + camera.verticalOffset;

    const cosPitch = Math.cos(camera.pitch);
    const sinPitch = Math.sin(camera.pitch);
    const distance = camera.distance;
    camera.position[0] = camera.target[0] + Math.sin(camera.yaw) * cosPitch * distance;
    camera.position[1] = camera.target[1] + sinPitch * distance;
    camera.position[2] = camera.target[2] + Math.cos(camera.yaw) * cosPitch * distance;

    const dx = camera.target[0] - camera.lastTarget[0];
    const dz = camera.target[2] - camera.lastTarget[2];
    const moveSpeed = Math.hypot(dx, dz) / Math.max(dt, 1e-5);
    camera.currentSpeed = camera.currentSpeed * 0.85 + moveSpeed * 0.15;
    camera.lastTarget[0] = camera.target[0];
    camera.lastTarget[1] = camera.target[1];
    camera.lastTarget[2] = camera.target[2];
  }

  function updateHud(dt) {
    if (hudPosition) {
      hudPosition.textContent = `${camera.target[0].toFixed(1)}, ${camera.target[1].toFixed(1)}, ${camera.target[2].toFixed(1)}`;
    }
    if (hudHeading) {
      const yawDeg = ((camera.yaw * 180 / Math.PI) % 360 + 360) % 360;
      const pitchDeg = camera.pitch * 180 / Math.PI;
      hudHeading.textContent = `${yawDeg.toFixed(0)}° / ${pitchDeg.toFixed(0)}°`;
    }
    if (hudChunk) {
      const chunkSize = geometry.step * 10;
      const cx = Math.round(camera.target[0] / chunkSize);
      const cz = Math.round(camera.target[2] / chunkSize);
      hudChunk.textContent = `${cx}, ${cz}`;
    }
    if (hudSpeed) {
      hudSpeed.textContent = `${(camera.currentSpeed).toFixed(1)} m/s`;
    }
  }

  function resizeViewport(width, height) {
    canvas.width = width;
    canvas.height = height;
    gl.viewport(0, 0, width, height);
    mat4Perspective(projectionMatrix, Math.PI / 3.4, width / height, 0.1, 2000);
    gl.useProgram(program);
    gl.uniformMatrix4fv(uniforms.projection, false, projectionMatrix);
  }

  resizeViewport(defaultResolution.width, defaultResolution.height);

  const upVector = [0, 1, 0];
  const renderModeKeys = ['default', 'wire', 'zx', 'petscii', 'signature'];
  let currentRenderMode = 0;
  let fogNear = 260;
  let fogFar = 980;
  const fogColor = new Float32Array(renderModeFogColors.default);

  function applyRenderMode(mode) {
    currentRenderMode = mode;
    const key = renderModeKeys[mode] ?? 'default';
    const color = renderModeFogColors[key];
    fogColor[0] = color[0];
    fogColor[1] = color[1];
    fogColor[2] = color[2];
    const isZx = key === 'zx';
    fogNear = isZx ? 180 : 260;
    fogFar = isZx ? 720 : 980;
    canvas.style.backgroundColor = renderModeCanvasBackgrounds[key];
  }

  applyRenderMode(0);

  const fps = fpsMonitor;
  const controls = {
    dragSensitivity: 0.0045,
    touchDragSensitivity: 0.0028
  };

  canvas.addEventListener('pointerdown', event => {
    pointerState.active = true;
    pointerState.id = event.pointerId;
    pointerState.lastX = event.clientX;
    pointerState.lastY = event.clientY;
    pointerState.pointerType = event.pointerType || 'mouse';
    canvas.setPointerCapture(event.pointerId);
    canvas.style.cursor = 'grabbing';
  });

  canvas.addEventListener('pointermove', event => {
    if (!pointerState.active || event.pointerId !== pointerState.id) return;
    const dx = event.clientX - pointerState.lastX;
    const dy = event.clientY - pointerState.lastY;
    pointerState.lastX = event.clientX;
    pointerState.lastY = event.clientY;
    const sensitivity = pointerState.pointerType === 'touch'
      ? controls.touchDragSensitivity
      : controls.dragSensitivity;
    camera.yaw -= dx * sensitivity;
    camera.pitch = Math.max(camera.minPitch, Math.min(camera.maxPitch, camera.pitch - dy * sensitivity));
  });

  const clearPointer = () => {
    pointerState.active = false;
    pointerState.id = null;
    canvas.style.cursor = 'grab';
  };

  canvas.addEventListener('pointerup', clearPointer);
  canvas.addEventListener('pointercancel', clearPointer);
  canvas.addEventListener('lostpointercapture', clearPointer);
  canvas.addEventListener('pointerleave', clearPointer);

  canvas.addEventListener('wheel', event => {
    const delta = Math.sign(event.deltaY);
    camera.distance = Math.max(camera.minDistance, Math.min(camera.maxDistance, camera.distance + delta * 36));
    event.preventDefault();
  }, { passive: false });

  window.addEventListener('keydown', event => {
    keyState[event.key] = true;
  });

  window.addEventListener('keyup', event => {
    keyState[event.key] = false;
  });

  window.addEventListener('blur', () => {
    for (const key of Object.keys(keyState)) keyState[key] = false;
    clearPointer();
  });

  function animate(now) {
    const dt = (now - (animate.lastTime || now)) / 1000;
    animate.lastTime = now;

    updateCamera(dt);
    updateHud(dt);

    gl.bindVertexArray(vao);
    gl.useProgram(program);
    mat4LookAt(viewMatrix, camera.position, camera.target, upVector);
    gl.uniformMatrix4fv(uniforms.view, false, viewMatrix);
    gl.uniform3fv(uniforms.cameraPos, camera.position);
    gl.uniform3fv(uniforms.fogColor, fogColor);
    gl.uniform1f(uniforms.fogNear, fogNear);
    gl.uniform1f(uniforms.fogFar, fogFar);
    gl.uniform1i(uniforms.renderMode, currentRenderMode);

    gl.clearColor(fogColor[0], fogColor[1], fogColor[2], 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.drawElements(gl.TRIANGLES, geometry.indices.length, gl.UNSIGNED_INT, 0);

    fps.begin();
    fps.end();

    requestAnimationFrame(animate);
  }

  setLoaderPhaseRange(70, 100);
  reportLoaderPhaseProgress(0.2);
  updateLoaderStatus('Calibrating viewport…');

  requestAnimationFrame(animate);
  setProgress(100);
  setTimeout(() => {
    stopLoaderAnimation();
    hideLoader(true);
  }, 260);

  const triggerVhsEffect = (() => {
    let timeoutId = null;
    return () => {
      canvasWrap.classList.remove('vhs-glitch');
      void canvasWrap.offsetWidth;
      canvasWrap.classList.add('vhs-glitch');
      if (timeoutId) clearTimeout(timeoutId);
      timeoutId = setTimeout(() => canvasWrap.classList.remove('vhs-glitch'), 650);
    };
  })();

  const renderModeButtons = document.querySelectorAll('[data-render-mode]');
  const renderModeMap = { default: 0, wire: 1, zx: 2, petscii: 3, signature: 4 };

  function setRenderModeByKey(key, announce = true) {
    const mode = renderModeMap[key] ?? 0;
    applyRenderMode(mode);
    gl.useProgram(program);
    gl.uniform1i(uniforms.renderMode, mode);
    renderModeButtons.forEach(btn => {
      const isActive = btn.dataset.renderMode === key;
      btn.classList.toggle('is-active', isActive);
      btn.setAttribute('aria-pressed', String(isActive));
    });
    if (announce) {
      console.log(`Render mode changed to ${key.toUpperCase()}.`);
    }
  }

  renderModeButtons.forEach(btn => {
    btn.addEventListener('click', () => {
      const mode = btn.dataset.renderMode;
      setRenderModeByKey(mode);
      triggerVhsEffect();
    });
  });

  const resolutionSelect = document.getElementById('resolution-select');
  const resolutionDisplay = document.getElementById('resolution-display');
  let currentResolution = defaultResolution;

  function updateCanvasLayout() {
    const aspect = currentResolution.width / currentResolution.height;
    const availableWidth = Math.max(100, window.innerWidth);
    const availableHeight = Math.max(100, window.innerHeight);
    let displayWidth = availableWidth;
    let displayHeight = displayWidth / aspect;
    if (displayHeight > availableHeight) {
      const scale = availableHeight / displayHeight;
      displayWidth = Math.floor(displayWidth * scale);
      displayHeight = availableHeight;
    }
    canvas.style.width = `${displayWidth}px`;
    canvas.style.height = `${displayHeight}px`;
    canvasWrap.style.width = `${displayWidth}px`;
    canvasWrap.style.height = `${displayHeight}px`;
  }

  function applyResolution(res) {
    currentResolution = res;
    resizeViewport(res.width, res.height);
    resolutionDisplay.textContent = `${res.label} — ${res.width} × ${res.height}`;
    updateCanvasLayout();
    console.log(`Resolution set to ${res.width}×${res.height} (${res.label}).`);
  }

  resolutionSelect.addEventListener('change', () => {
    const [w, h] = resolutionSelect.value.split('x').map(Number);
    const chosen = RESOLUTIONS.find(r => r.width === w && r.height === h) || defaultResolution;
    applyResolution(chosen);
    triggerVhsEffect();
  });

  const fullscreenBtn = document.getElementById('fullscreen-btn');

  const isFullscreenActive = () => Boolean(document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement);

  function updateFullscreenButton() {
    const isMobile = document.body.classList.contains('is-mobile');
    fullscreenBtn.textContent = isFullscreenActive()
      ? 'Exit Fullscreen'
      : (isMobile ? 'Fullscreen' : 'Enter Fullscreen');
    const shouldShow = isFullscreenActive() || window.innerWidth >= 720 || isMobile;
    fullscreenBtn.style.display = shouldShow ? 'inline-flex' : 'none';
  }

  fullscreenBtn.addEventListener('click', () => {
    if (isFullscreenActive()) {
      (document.exitFullscreen || document.webkitExitFullscreen || document.msExitFullscreen)?.call(document);
    } else {
      const target = document.documentElement;
      (target.requestFullscreen || target.webkitRequestFullscreen || target.msRequestFullscreen)?.call(target);
    }
  });

  ['fullscreenchange', 'webkitfullscreenchange', 'msfullscreenchange'].forEach(eventName => {
    document.addEventListener(eventName, () => {
      updateCanvasLayout();
      updateFullscreenButton();
    });
  });

  const controlPad = document.getElementById('control-pad');
  controlPad.querySelectorAll('button[data-key]').forEach(btn => {
    const key = btn.dataset.key;
    btn.addEventListener('pointerdown', event => {
      keyState[key] = true;
      btn.setPointerCapture?.(event.pointerId);
    });
    const end = () => { keyState[key] = false; };
    btn.addEventListener('pointerup', end);
    btn.addEventListener('pointerleave', end);
    btn.addEventListener('lostpointercapture', end);
    btn.addEventListener('pointercancel', end);
  });

  function updateResponsiveState() {
    const isMobile = window.innerWidth <= 720;
    document.body.classList.toggle('is-mobile', isMobile);
  }

  window.addEventListener('resize', () => {
    updateResponsiveState();
    updateCanvasLayout();
    updateFullscreenButton();
  });
  window.addEventListener('orientationchange', () => {
    updateResponsiveState();
    updateCanvasLayout();
    updateFullscreenButton();
  });

  const controlUi = document.getElementById('control-ui');
  const foldBtn = document.getElementById('ui-fold-btn');
  function setControlFolded(folded) {
    if (!controlUi) return;
    controlUi.classList.toggle('folded', folded);
    foldBtn?.setAttribute('aria-expanded', String(!folded));
    foldBtn?.setAttribute('aria-label', folded ? 'Expand control panel' : 'Collapse control panel');
  }
  foldBtn?.addEventListener('click', () => {
    const next = !controlUi.classList.contains('folded');
    setControlFolded(next);
    console.log(`Control interface ${next ? 'folded' : 'expanded'}.`);
  });

  const consoleDock = document.getElementById('console-dock');
  const consoleFoldBtn = document.getElementById('console-fold-btn');
  const consoleStatus = document.getElementById('console-status');
  const consoleLog = document.getElementById('console-log');
  initConsoleLogs({ container: consoleLog, removeAfter: 0 });

  function setConsoleFolded(folded) {
    consoleDock.classList.toggle('folded', folded);
    consoleFoldBtn?.setAttribute('aria-expanded', String(!folded));
    consoleFoldBtn?.setAttribute('aria-label', folded ? 'Expand console log' : 'Collapse console log');
    consoleStatus.textContent = folded ? 'Folded' : 'Live';
  }

  consoleFoldBtn?.addEventListener('click', () => {
    const next = !consoleDock.classList.contains('folded');
    setConsoleFolded(next);
  });

  setConsoleFolded(true);
  setControlFolded(false);
  updateResponsiveState();
  applyResolution(currentResolution);
  updateFullscreenButton();
  updateCanvasLayout();
  setRenderModeByKey('default', false);

  console.log('Terrain ready.');
  </script>

</body>
</html>
