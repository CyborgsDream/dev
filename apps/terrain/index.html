<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Terrain</title>
  <style>
    :root {
      --navy-900: #020817;
      --navy-800: #071127;
      --navy-700: #0b1a35;
      --frame-border: rgba(0, 0, 0, 0.45);
      --frame-border-light: rgba(255, 255, 255, 0.08);
      --text-white: #ffffff;
      --text-black: #050505;
      --accent-orange: #ff8b2f;
      --graph-grid: rgba(255, 255, 255, 0.18);
      --graph-fill: rgba(255, 139, 47, 0.18);
      --graph-line: #ff8b2f;
    }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      color: var(--text-white);
      font-family: 'Trebuchet MS', 'Lucida Sans', 'Geneva', sans-serif;
    }
    body {
      position: relative;
      background:
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.06), transparent 45%),
        radial-gradient(circle at 80% 30%, rgba(255, 139, 47, 0.08), transparent 55%),
        var(--navy-900);
      background-size: cover;
    }
    #scene-shell {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      pointer-events: none;
      box-sizing: border-box;
    }
    #canvas-wrap {
      position: relative;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      border: 2px solid var(--frame-border);
      background: #000;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.45);
      max-width: 100%;
      max-height: 100%;
      image-rendering: pixelated;
    }
    #loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(2, 8, 23, 0.92);
      color: var(--text-white);
      font-family: 'Lucida Sans', 'Geneva', sans-serif;
      font-size: 2em;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      z-index: 60;
    }
    #loader #progress {
      color: var(--accent-orange);
    }
    #fps {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 40;
      pointer-events: none;
    }
    #fps-monitor {
      position: relative;
      display: grid;
      row-gap: 10px;
      padding: 16px;
      background: linear-gradient(160deg, var(--navy-800), var(--navy-700));
      border: 1px solid var(--frame-border);
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
      min-width: 210px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-white);
    }
    #fps-monitor .panel-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.7rem;
      color: var(--accent-orange);
      letter-spacing: 0.18em;
    }
    #fps-monitor .panel-title .label {
      color: var(--text-white);
      letter-spacing: 0.2em;
    }
    #fps-monitor .fps-readout {
      display: flex;
      align-items: baseline;
      gap: 12px;
      font-family: 'Lucida Console', 'Courier New', monospace;
      color: var(--text-white);
    }
    #fps-monitor .fps-label {
      font-size: 0.65rem;
      color: var(--accent-orange);
    }
    #fps-monitor .fps-value {
      font-size: 1.6rem;
      font-weight: 700;
      color: var(--text-white);
      min-width: 4.5em;
      text-shadow: 0 0 14px rgba(255, 139, 47, 0.3);
    }
    #fps-monitor canvas {
      width: 100%;
      height: 64px;
      border: 1px solid var(--frame-border);
      background: var(--navy-900);
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
    }
    #control-ui {
      position: fixed;
      top: 18px;
      right: 18px;
      background: linear-gradient(150deg, var(--navy-800), var(--navy-700));
      border: 1px solid var(--frame-border);
      box-shadow: inset 0 0 0 1px var(--frame-border-light), 0 18px 32px rgba(0, 0, 0, 0.45);
      padding: 18px 20px 22px;
      display: grid;
      row-gap: 14px;
      width: min(240px, 80vw);
      z-index: 30;
      font-family: 'Lucida Sans', 'Geneva', sans-serif;
      color: var(--text-white);
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    #control-ui h2 {
      margin: 0;
      display: flex;
      align-items: center;
      gap: 12px;
      font-size: 0.76rem;
      color: var(--accent-orange);
      letter-spacing: 0.2em;
    }
    #control-ui h2 span:last-child {
      color: var(--text-white);
      letter-spacing: 0.24em;
    }
    .ui-icon {
      width: 26px;
      height: 26px;
      display: grid;
      place-items: center;
      perspective: 400px;
    }
    .ui-icon svg {
      width: 100%;
      height: 100%;
      fill: var(--text-white);
      transform-origin: center;
      animation: icon-spin 6s linear infinite;
      filter: drop-shadow(0 0 6px rgba(255, 139, 47, 0.35));
    }
    @keyframes icon-spin {
      0% { transform: rotateX(0deg) rotateY(0deg); }
      50% { transform: rotateX(18deg) rotateY(180deg); }
      100% { transform: rotateX(0deg) rotateY(360deg); }
    }
    #resolution-display {
      font-size: 0.85rem;
      font-weight: 700;
      color: var(--text-white);
      text-shadow: 0 0 12px rgba(255, 139, 47, 0.4);
    }
    label[for="resolution-select"] {
      font-size: 0.7rem;
      color: var(--text-white);
    }
    .select-wrap {
      position: relative;
    }
    .select-wrap::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 12px;
      width: 8px;
      height: 8px;
      border-right: 2px solid var(--accent-orange);
      border-bottom: 2px solid var(--accent-orange);
      transform: translateY(-50%) rotate(45deg);
      pointer-events: none;
    }
    #resolution-select {
      width: 100%;
      padding: 8px 32px 8px 12px;
      border-radius: 0;
      border: 1px solid var(--frame-border);
      background: rgba(2, 8, 23, 0.65);
      color: var(--text-white);
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      appearance: none;
      outline: none;
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
    }
    #resolution-select:focus {
      border-color: var(--accent-orange);
      box-shadow: 0 0 0 1px rgba(255, 139, 47, 0.35), 0 0 0 4px rgba(255, 139, 47, 0.15);
    }
    #fullscreen-btn {
      position: fixed;
      left: 50%;
      bottom: 32px;
      transform: translateX(-50%);
      padding: 10px 32px;
      background: linear-gradient(160deg, rgba(2, 8, 23, 0.85), rgba(11, 26, 53, 0.85));
      border: 1px solid var(--frame-border);
      color: var(--text-white);
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      cursor: pointer;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);
      text-transform: uppercase;
      transition: transform 0.15s ease;
      z-index: 35;
      display: none;
    }
    #fullscreen-btn:hover {
      transform: translateX(-50%) translateY(-2px);
    }
    #fullscreen-btn:active {
      transform: translateX(-50%) translateY(2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.55);
    }
    #control-pad {
      position: fixed;
      bottom: 28px;
      right: 28px;
      display: grid;
      grid-template-columns: repeat(3, 54px);
      grid-template-rows: repeat(3, 54px);
      gap: 10px;
      z-index: 35;
    }
    #control-pad button,
    #control-pad span {
      width: 54px;
      height: 54px;
      border-radius: 12px;
      border: 1px solid var(--frame-border);
      background: rgba(2, 8, 23, 0.72);
      color: var(--text-white);
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 12px 18px rgba(0, 0, 0, 0.45);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      text-shadow: 0 0 10px rgba(255, 139, 47, 0.35);
    }
    #control-pad span {
      cursor: default;
      opacity: 0;
      box-shadow: none;
      border: none;
      pointer-events: none;
    }
    #control-pad button:active {
      transform: translateY(2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
    }
    @media (max-width: 720px) {
      #control-pad {
        right: 16px;
        bottom: 16px;
        grid-template-columns: repeat(3, 48px);
        grid-template-rows: repeat(3, 48px);
        gap: 8px;
      }
      #control-pad button,
      #control-pad span {
        width: 48px;
        height: 48px;
      }
      #control-ui {
        right: 12px;
        top: 12px;
        padding: 16px 16px 18px;
        width: min(210px, 84vw);
      }
    }
  </style>
</head>
<body>
  <div id="scene-shell">
    <div id="canvas-wrap"></div>
  </div>
  <div id="control-ui">
    <h2>
      <span class="ui-icon" aria-hidden="true">
        <svg viewBox="0 0 24 24" role="presentation">
          <polygon points="12,2 22,7 22,17 12,22 2,17 2,7" opacity="0.4"></polygon>
          <polygon points="12,4.5 19.5,8.2 19.5,15.8 12,19.5 4.5,15.8 4.5,8.2" fill="currentColor"></polygon>
          <path d="M9 10h2v2H9zm4 0h2v2h-2zm-2 3h2v2h-2z" fill="var(--accent-orange)"></path>
        </svg>
      </span>
      <span>Games Mode</span>
    </h2>
    <div id="resolution-display">—</div>
    <label for="resolution-select">Resolution</label>
    <div class="select-wrap">
      <select id="resolution-select" aria-label="Resolution selector">
      <option value="256x144">144p — 256 × 144</option>
      <option value="426x240">240p — 426 × 240</option>
      <option value="640x360">360p — 640 × 360</option>
      <option value="854x480">480p — 854 × 480</option>
      <option value="1280x720" selected>720p — 1280 × 720</option>
      <option value="1920x1080">1080p — 1920 × 1080</option>
      <option value="2560x1440">1440p — 2560 × 1440</option>
      <option value="3840x2160">2160p — 3840 × 2160</option>
      </select>
    </div>
  </div>
  <button id="fullscreen-btn" type="button">Enter Fullscreen</button>
  <div id="control-pad">
    <span></span>
    <button data-key="ArrowUp" aria-label="Move forward">▲</button>
    <span></span>
    <button data-key="ArrowLeft" aria-label="Turn left">◀</button>
    <span></span>
    <button data-key="ArrowRight" aria-label="Turn right">▶</button>
    <span></span>
    <button data-key="ArrowDown" aria-label="Move backward">▼</button>
    <span></span>
  </div>
  <div id="fps"></div>
  <div id="loader">Loading <span id="progress">0%</span></div>
  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { initConsoleLogs } from '../../shared/consolelogs.js';

  initConsoleLogs({ removeAfter: null });

  const RESOLUTIONS = [
    { label: '144p', width: 256, height: 144 },
    { label: '240p', width: 426, height: 240 },
    { label: '360p', width: 640, height: 360 },
    { label: '480p', width: 854, height: 480 },
    { label: '720p', width: 1280, height: 720 },
    { label: '1080p', width: 1920, height: 1080 },
    { label: '1440p', width: 2560, height: 1440 },
    { label: '2160p', width: 3840, height: 2160 }
  ];

  const loaderEl = document.getElementById('loader');
  const progressEl = document.getElementById('progress');
  function setProgress(p){ progressEl.textContent = Math.round(p) + '%'; }

  const fpsHolder = document.getElementById('fps');

  class FpsMonitor {
    constructor(container) {
      this.dom = document.createElement('div');
      this.dom.id = 'fps-monitor';

      const iconMarkup = `
        <span class="ui-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="presentation">
            <polygon points="12,2 22,7 22,17 12,22 2,17 2,7" opacity="0.35"></polygon>
            <polygon points="12,4.5 19.5,8.2 19.5,15.8 12,19.5 4.5,15.8 4.5,8.2" fill="currentColor"></polygon>
            <path d="M8 15h2.5V9H8zm5-6v8h-2.5V9zm2.5 0H18v10h-2.5z" fill="var(--accent-orange)"></path>
          </svg>
        </span>`;

      this.titleEl = document.createElement('div');
      this.titleEl.className = 'panel-title';
      this.titleEl.innerHTML = `${iconMarkup}<span class="label">Performance</span>`;
      this.dom.appendChild(this.titleEl);

      this.styles = getComputedStyle(document.documentElement);

      this.readoutEl = document.createElement('div');
      this.readoutEl.className = 'fps-readout';

      this.labelEl = document.createElement('div');
      this.labelEl.className = 'fps-label';
      this.labelEl.textContent = 'fps';

      this.valueEl = document.createElement('div');
      this.valueEl.className = 'fps-value';
      this.valueEl.textContent = '000';

      this.readoutEl.appendChild(this.labelEl);
      this.readoutEl.appendChild(this.valueEl);

      this.graphCanvas = document.createElement('canvas');
      this.graphCanvas.width = 160;
      this.graphCanvas.height = 60;
      this.graphCanvas.className = 'fps-graph';
      this.graphCanvas.setAttribute('aria-hidden', 'true');
      this.graphCtx = this.graphCanvas.getContext('2d');

      this.maxSamples = this.graphCanvas.width;
      this.samples = new Array(this.maxSamples).fill(0);
      this.referenceFps = 120;

      this.sampleWindow = 250;
      this.frameCount = 0;
      this.lastSample = performance.now();
      this.smoothed = 0;

      this.dom.appendChild(this.readoutEl);
      this.dom.appendChild(this.graphCanvas);
      this.drawGraph();
      container.appendChild(this.dom);
    }

    begin() {}

    end() {
      const now = performance.now();
      this.frameCount += 1;
      if (now - this.lastSample >= this.sampleWindow) {
        const elapsed = now - this.lastSample;
        const fps = (this.frameCount * 1000) / elapsed;
        this.frameCount = 0;
        this.lastSample = now;
        this.update(fps);
      }
    }

    update(rawFps) {
      const fps = Math.max(0, rawFps);
      this.smoothed = this.smoothed === 0 ? fps : (this.smoothed * 0.7 + fps * 0.3);
      const rounded = Math.max(0, Math.round(this.smoothed));
      this.valueEl.textContent = `${rounded.toString().padStart(3, '0')}`;
      this.samples.push(fps);
      if (this.samples.length > this.maxSamples) {
        this.samples.shift();
      }
      this.drawGraph();
    }

    drawGraph() {
      const ctx = this.graphCtx;
      const width = this.graphCanvas.width;
      const height = this.graphCanvas.height;
      ctx.clearRect(0, 0, width, height);

      const background = this.styles.getPropertyValue('--navy-900').trim() || '#020817';
      const gridColor = this.styles.getPropertyValue('--graph-grid').trim() || 'rgba(255, 255, 255, 0.18)';
      const fillColor = this.styles.getPropertyValue('--graph-fill').trim() || 'rgba(255, 139, 47, 0.18)';
      const lineColor = this.styles.getPropertyValue('--graph-line').trim() || '#ff8b2f';

      ctx.fillStyle = background;
      ctx.fillRect(0, 0, width, height);

      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      const gridLines = 4;
      for (let i = 1; i < gridLines; i++) {
        const y = Math.round((height / gridLines) * i) + 0.5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      const highestSample = this.samples.reduce((max, value) => Math.max(max, value), 0);
      const scaleMax = Math.max(this.referenceFps, highestSample, 30);
      const verticalPadding = 2;
      const usableHeight = height - verticalPadding * 2;

      ctx.beginPath();
      ctx.moveTo(0, height - verticalPadding);
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(width, height - verticalPadding);
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();

      ctx.beginPath();
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  const fpsMonitor = new FpsMonitor(fpsHolder);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setPixelRatio(1);
  const canvasWrap = document.getElementById('canvas-wrap');
  canvasWrap.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.add(new THREE.AmbientLight(0x666666));
  const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
  sunLight.position.set(260, 220, -500);
  scene.add(sunLight);

  const camera = new THREE.PerspectiveCamera(50, 16 / 9, 0.1, 3000);
  const controls = {
    yaw: 0,
    yawVelocity: 0,
    speed: 60,
    turnSpeed: Math.PI * 0.45,
    turnSmooth: 3,
    height: 60
  };
  camera.position.set(0, controls.height, 160);
  camera.lookAt(0, 0, 0);

  const keyState = {};
  window.addEventListener('keydown', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) { keyState[e.key] = true; e.preventDefault(); }
  });
  window.addEventListener('keyup', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) { keyState[e.key] = false; e.preventDefault(); }
  });

  const onscreenButtons = document.querySelectorAll('#control-pad button[data-key]');
  onscreenButtons.forEach(btn => {
    const key = btn.dataset.key;
    const activate = ev => { keyState[key] = true; ev.preventDefault(); };
    const deactivate = ev => { keyState[key] = false; ev.preventDefault(); };
    btn.addEventListener('mousedown', activate);
    btn.addEventListener('touchstart', activate, { passive: false });
    const endEvents = ['mouseleave','mouseup','touchend','touchcancel'];
    endEvents.forEach(evt => btn.addEventListener(evt, deactivate));
    window.addEventListener('mouseup', () => { keyState[key] = false; });
    window.addEventListener('touchend', () => { keyState[key] = false; });
    window.addEventListener('touchcancel', () => { keyState[key] = false; });
  });

  let touchStart = null;
  window.addEventListener('touchstart', e => {
    if (e.target.closest('#control-pad')) return;
    touchStart = e.touches[0];
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchmove', e => {
    if (!touchStart || e.target.closest('#control-pad')) return;
    const touch = e.touches[0];
    const dx = touch.clientX - touchStart.clientX;
    const dy = touch.clientY - touchStart.clientY;
    const threshold = 10;
    keyState['ArrowLeft'] = dx < -threshold;
    keyState['ArrowRight'] = dx > threshold;
    keyState['ArrowUp'] = dy < -threshold;
    keyState['ArrowDown'] = dy > threshold;
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchend', e => {
    if (e.target.closest('#control-pad')) return;
    touchStart = null;
    keyState['ArrowLeft'] = keyState['ArrowRight'] = keyState['ArrowUp'] = keyState['ArrowDown'] = false;
    e.preventDefault();
  });

  function hash(ix, iz){ const s = Math.sin(ix*127.1 + iz*311.7) * 43758.5453123; return s - Math.floor(s); }
  const lerp = (a,b,t)=> a + (b-a)*t; const smooth = t => t*t*(3-2*t);
  function noise2(x,z){ const ix=Math.floor(x), iz=Math.floor(z), fx=x-ix, fz=z-iz;
    const a=hash(ix,iz), b=hash(ix+1,iz), c=hash(ix,iz+1), d=hash(ix+1,iz+1);
    const ux=smooth(fx), uz=smooth(fz); return lerp( lerp(a,b,ux), lerp(c,d,ux), uz ); }
  function fbm(x,z,oct=5){ let amp=1,freq=0.02,sum=0,norm=0; for(let i=0;i<oct;i++){ sum+=amp*noise2(x*freq,z*freq); norm+=amp; amp*=0.5; freq*=2; } return sum/norm; }

  const terrainSize = 600;
  const terrainSegments = 120;
  const terrain = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
  terrain.rotateX(-Math.PI/2);
  const pos = terrain.attributes.position;
  const basePositions = Float32Array.from(pos.array);
  const cellSize = terrainSize / terrainSegments;
  const chunkSize = cellSize * 10;
  const terrainState = { offsetX: 0, offsetZ: 0 };

  function refreshTerrain(offsetX, offsetZ) {
    for (let i = 0; i < pos.count; i++) {
      const ix = i * 3;
      const x = basePositions[ix];
      const z = basePositions[ix + 2];
      const worldX = x + offsetX;
      const worldZ = z + offsetZ;
      const y = fbm(worldX, worldZ) * 60 - 18;
      pos.setY(i, y);
    }
    pos.needsUpdate = true;
    terrain.computeVertexNormals();
  }
  refreshTerrain(terrainState.offsetX, terrainState.offsetZ);
  const terrainMesh = new THREE.Mesh(terrain, new THREE.MeshStandardMaterial({ color:0x2a8a4b, flatShading:true, metalness:0, roughness:1 }));
  terrainMesh.position.set(terrainState.offsetX, 0, terrainState.offsetZ);
  scene.add(terrainMesh);
  function snapToChunk(value) { return Math.round(value / chunkSize) * chunkSize; }

  const groundRay = new THREE.Raycaster();
  const floatingBlocks = [];

  function createBlock(x, z) {
    const size = 2;
    const color = new THREE.Color().setHSL(Math.random() * 0.15, 0.9, 0.5 + Math.random() * 0.1);
    const block = new THREE.Mesh(
      new THREE.BoxGeometry(size, size, size),
      new THREE.MeshStandardMaterial({ color })
    );
    groundRay.set(new THREE.Vector3(x, 100, z), new THREE.Vector3(0, -1, 0));
    const hit = groundRay.intersectObject(terrainMesh);
    const y = hit.length ? hit[0].point.y : 0;
    block.position.set(x, y + size / 2 + 8 * Math.random(), z);
    block.castShadow = true;
    block.receiveShadow = true;
    block.userData.base = block.position.clone();
    block.userData.bobSpeed = 0.35 + Math.random() * 0.3;
    block.userData.bobAmp = 4 + Math.random() * 6;
    block.userData.phase = Math.random() * Math.PI * 2;
    block.userData.windOffset = new THREE.Vector3();
    block.userData.windVelocity = new THREE.Vector3();
    scene.add(block);
    floatingBlocks.push(block);
  }

  const blockSpread = terrainSize * 0.48;
  async function generateBlocks(count) {
    for (let i = 0; i < count; i++) {
      const x = Math.random() * blockSpread * 2 - blockSpread;
      const z = Math.random() * blockSpread * 2 - blockSpread;
      createBlock(x, z);
      if (i % 50 === 0) {
        setProgress((i / count) * 100);
        await new Promise(requestAnimationFrame);
      }
    }
    setProgress(100);
    loaderEl.remove();
    console.log(`Terrain populated with ${count} blocks.`);
  }

  function updateControls(dt){
    const yawInput = (keyState['ArrowRight'] ? 1 : 0) - (keyState['ArrowLeft'] ? 1 : 0);
    const targetYawVelocity = yawInput * controls.turnSpeed;
    controls.yawVelocity = THREE.MathUtils.damp(controls.yawVelocity, targetYawVelocity, controls.turnSmooth, dt);
    controls.yaw += controls.yawVelocity * dt;
    const forward = new THREE.Vector3(Math.sin(controls.yaw), 0, -Math.cos(controls.yaw));
    let move = new THREE.Vector3();
    if (keyState['ArrowUp']) move.add(forward);
    if (keyState['ArrowDown']) move.add(forward.clone().multiplyScalar(-1));
    if (move.lengthSq() > 0) {
      move.normalize().multiplyScalar(controls.speed * dt);
      const p = camera.position.clone().add(move);
      p.y = controls.height;
      camera.position.copy(p);
    }
    const lookTarget = camera.position.clone().add(forward);
    camera.lookAt(lookTarget);
  }

  function updateTerrainFollow() {
    const snappedX = snapToChunk(camera.position.x);
    const snappedZ = snapToChunk(camera.position.z);
    if (snappedX !== terrainState.offsetX || snappedZ !== terrainState.offsetZ) {
      terrainState.offsetX = snappedX;
      terrainState.offsetZ = snappedZ;
      refreshTerrain(snappedX, snappedZ);
      terrainMesh.position.set(snappedX, 0, snappedZ);
    }
  }

  const tempVec = new THREE.Vector3();
  function updateBlocks(dt, time) {
    const cameraPos = camera.position;
    for (const block of floatingBlocks) {
      const data = block.userData;
      const bob = Math.sin(time * data.bobSpeed + data.phase) * data.bobAmp;
      const desired = data.base.clone();
      desired.y += bob;
      tempVec.copy(cameraPos).sub(block.position);
      const distance = tempVec.length();
      if (distance < 60) {
        const strength = (60 - distance) / 60;
        tempVec.set(Math.random() - 0.5, (Math.random() - 0.5) * 0.3, Math.random() - 0.5).normalize();
        data.windVelocity.addScaledVector(tempVec, strength * 18 * dt);
      }
      data.windVelocity.multiplyScalar(Math.max(0, 1 - dt * 2.4));
      data.windOffset.addScaledVector(data.windVelocity, dt);
      data.windOffset.multiplyScalar(0.94);
      desired.add(data.windOffset);
      block.position.lerp(desired, THREE.MathUtils.clamp(dt * 3, 0, 1));
    }
  }

  let last = performance.now();
  function animate(){
    fpsMonitor.begin();
    const now = performance.now();
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    updateControls(dt);
    updateTerrainFollow();
    updateBlocks(dt, now / 1000);
    renderer.render(scene, camera);
    fpsMonitor.end();
    requestAnimationFrame(animate);
  }

  console.log('Terrain initialising...');
  await generateBlocks(1000);
  console.log('Terrain ready.');
  animate();

  const resolutionSelect = document.getElementById('resolution-select');
  const resolutionDisplay = document.getElementById('resolution-display');
  const fullscreenBtn = document.getElementById('fullscreen-btn');

  const isFullscreenActive = () => Boolean(
    document.fullscreenElement ||
    document.webkitFullscreenElement ||
    document.msFullscreenElement
  );

  let currentResolution = RESOLUTIONS[4];

  function applyResolution(res) {
    currentResolution = res;
    renderer.setSize(res.width, res.height, false);
    renderer.domElement.width = res.width;
    renderer.domElement.height = res.height;
    camera.aspect = res.width / res.height;
    camera.updateProjectionMatrix();
    resolutionDisplay.textContent = `${res.label} — ${res.width} × ${res.height}`;
    updateCanvasLayout();
  }

  function parseResolution(value) {
    const [w, h] = value.split('x').map(Number);
    return RESOLUTIONS.find(r => r.width === w && r.height === h) || RESOLUTIONS[0];
  }

  function updateCanvasLayout() {
    const aspect = currentResolution.width / currentResolution.height;
    const availableWidth = Math.max(100, window.innerWidth);
    const availableHeight = Math.max(100, window.innerHeight);

    let displayWidth = availableWidth;
    let displayHeight = displayWidth / aspect;

    if (displayHeight > availableHeight) {
      const scale = availableHeight / displayHeight;
      displayWidth = Math.floor(displayWidth * scale);
      displayHeight = availableHeight;
    }

    renderer.domElement.style.width = `${displayWidth}px`;
    renderer.domElement.style.height = `${displayHeight}px`;
    canvasWrap.style.width = `${displayWidth}px`;
    canvasWrap.style.height = `${displayHeight}px`;
  }

  resolutionSelect.addEventListener('change', () => {
    applyResolution(parseResolution(resolutionSelect.value));
  });

  function updateFullscreenButton() {
    const isFullscreen = isFullscreenActive();
    fullscreenBtn.textContent = isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen';
    const shouldShow = isFullscreen || window.innerWidth >= 720;
    fullscreenBtn.style.display = shouldShow ? 'inline-flex' : 'none';
    document.body.classList.toggle('is-fullscreen', isFullscreen);
  }

  fullscreenBtn.addEventListener('click', () => {
    if (isFullscreenActive()) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
    } else {
      const target = document.documentElement;
      const request = target.requestFullscreen || target.webkitRequestFullscreen || target.msRequestFullscreen;
      if (request) request.call(target);
    }
  });

  document.addEventListener('fullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });
  document.addEventListener('webkitfullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });
  document.addEventListener('msfullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });

  window.addEventListener('resize', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });

  applyResolution(currentResolution);
  updateFullscreenButton();
  updateCanvasLayout();
  </script>
</body>
</html>
