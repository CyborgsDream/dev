<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Terrain</title>
  <style>
    :root {
      --navy: #000b33;
      --panel-bg: rgba(0, 0, 0, 0.88);
      --panel-border: #ffffff;
      --accent: #00ffd0;
      --accent-2: #ff006c;
      --accent-3: #ffe600;
    }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: var(--navy);
      color: #fff;
      font-family: "Inter", system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    body {
      position: relative;
    }
    #scene-shell {
      position: fixed;
      inset: 0;
      background: var(--navy);
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      pointer-events: none;
      box-sizing: border-box;
    }
    #canvas-wrap {
      position: relative;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
    }
    canvas {
      display: block;
      border-radius: 0;
      background: #000;
      box-shadow: none;
      max-width: 100%;
      max-height: 100%;
      image-rendering: pixelated;
    }
    #loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(0, 0, 0, 0.92);
      color: #fff;
      font-family: sans-serif;
      font-size: 2em;
      z-index: 60;
    }
    #fps {
      position: fixed;
      top: 16px;
      left: 16px;
      z-index: 40;
      pointer-events: none;
    }
    #fps-monitor {
      display: inline-flex;
      align-items: center;
      gap: 12px;
      padding: 10px 14px;
      background: #000;
      border: 2px solid var(--panel-border);
      color: #fff;
      font-family: "Courier New", Courier, monospace;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    #fps-monitor .fps-label {
      font-size: 0.75rem;
      color: var(--accent-3);
    }
    #fps-monitor .fps-value {
      font-size: 1rem;
      font-weight: 700;
      color: var(--accent);
      min-width: 4.5em;
    }
    #control-ui {
      position: fixed;
      top: 16px;
      right: 16px;
      background: #000;
      border: 2px solid var(--panel-border);
      padding: 12px 14px;
      display: grid;
      row-gap: 10px;
      width: min(220px, 78vw);
      z-index: 30;
      font-family: "Courier New", Courier, monospace;
      color: #fff;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      box-shadow: none;
    }
    #control-ui h2 {
      margin: 0;
      font-size: 0.75rem;
      color: var(--accent-2);
    }
    #resolution-display {
      font-size: 0.85rem;
      font-weight: 700;
      color: var(--accent);
    }
    label[for="resolution-select"] {
      font-size: 0.7rem;
      color: var(--accent-3);
    }
    .select-wrap {
      position: relative;
    }
    .select-wrap::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 10px;
      width: 6px;
      height: 6px;
      border-right: 2px solid var(--accent-2);
      border-bottom: 2px solid var(--accent-2);
      transform: translateY(-50%) rotate(45deg);
      pointer-events: none;
    }
    #resolution-select {
      width: 100%;
      padding: 8px 26px 8px 10px;
      border-radius: 0;
      border: 2px solid var(--panel-border);
      background: #001a36;
      color: var(--accent);
      font-size: 0.75rem;
      font-weight: 700;
      letter-spacing: 0.06em;
      appearance: none;
      outline: none;
      box-shadow: none;
    }
    #resolution-select:focus {
      border-color: var(--accent-2);
    }
    #fullscreen-btn {
      position: fixed;
      left: 50%;
      bottom: 28px;
      transform: translateX(-50%);
      padding: 10px 22px;
      background: linear-gradient(120deg, rgba(38, 119, 247, 0.9), rgba(96, 211, 255, 0.85));
      border: none;
      border-radius: 999px;
      color: #fff;
      font-size: 14px;
      font-weight: 600;
      letter-spacing: 0.05em;
      cursor: pointer;
      box-shadow: 0 12px 30px rgba(22, 120, 255, 0.3);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      z-index: 35;
      display: none;
    }
    #fullscreen-btn:hover {
      transform: translateX(-50%) translateY(-1px);
      box-shadow: 0 18px 36px rgba(22, 120, 255, 0.4);
    }
    #control-pad {
      position: fixed;
      bottom: 24px;
      right: 24px;
      display: grid;
      grid-template-columns: repeat(3, 52px);
      grid-template-rows: repeat(3, 52px);
      gap: 8px;
      z-index: 35;
    }
    #control-pad button, #control-pad span {
      width: 52px;
      height: 52px;
      border-radius: 16px;
      border: 1px solid rgba(109, 167, 255, 0.2);
      background: var(--panel-bg);
      backdrop-filter: blur(12px);
      color: rgba(255, 255, 255, 0.92);
      font-size: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08), 0 12px 24px rgba(0, 0, 0, 0.25);
      transition: transform 0.15s ease, background 0.15s ease;
    }
    #control-pad span {
      cursor: default;
      opacity: 0;
      border: none;
      box-shadow: none;
    }
    #control-pad button:active {
      transform: translateY(2px) scale(0.98);
      background: rgba(29, 62, 103, 0.95);
    }
    @media (max-width: 720px) {
      #control-pad {
        right: 14px;
        bottom: 14px;
        grid-template-columns: repeat(3, 46px);
        grid-template-rows: repeat(3, 46px);
        gap: 6px;
      }
      #control-pad button, #control-pad span {
        width: 46px;
        height: 46px;
      }
      #control-ui {
        right: 12px;
        top: 12px;
        padding: 10px 12px;
        width: min(200px, 82vw);
      }
    }
  </style>
</head>
<body>
  <div id="scene-shell">
    <div id="canvas-wrap"></div>
  </div>
  <div id="control-ui">
    <h2>Games Mode</h2>
    <div id="resolution-display">—</div>
    <label for="resolution-select">Resolution</label>
    <div class="select-wrap">
      <select id="resolution-select" aria-label="Resolution selector">
      <option value="256x144">144p — 256 × 144</option>
      <option value="426x240">240p — 426 × 240</option>
      <option value="640x360">360p — 640 × 360</option>
      <option value="854x480">480p — 854 × 480</option>
      <option value="1280x720" selected>720p — 1280 × 720</option>
      <option value="1920x1080">1080p — 1920 × 1080</option>
      <option value="2560x1440">1440p — 2560 × 1440</option>
      <option value="3840x2160">2160p — 3840 × 2160</option>
      </select>
    </div>
  </div>
  <button id="fullscreen-btn" type="button">Enter Fullscreen</button>
  <div id="control-pad">
    <span></span>
    <button data-key="ArrowUp" aria-label="Move forward">▲</button>
    <span></span>
    <button data-key="ArrowLeft" aria-label="Turn left">◀</button>
    <span></span>
    <button data-key="ArrowRight" aria-label="Turn right">▶</button>
    <span></span>
    <button data-key="ArrowDown" aria-label="Move backward">▼</button>
    <span></span>
  </div>
  <div id="fps"></div>
  <div id="loader">Loading <span id="progress">0%</span></div>
  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { initConsoleLogs } from '../../shared/consolelogs.js';

  initConsoleLogs({ removeAfter: null });

  const RESOLUTIONS = [
    { label: '144p', width: 256, height: 144 },
    { label: '240p', width: 426, height: 240 },
    { label: '360p', width: 640, height: 360 },
    { label: '480p', width: 854, height: 480 },
    { label: '720p', width: 1280, height: 720 },
    { label: '1080p', width: 1920, height: 1080 },
    { label: '1440p', width: 2560, height: 1440 },
    { label: '2160p', width: 3840, height: 2160 }
  ];

  const loaderEl = document.getElementById('loader');
  const progressEl = document.getElementById('progress');
  function setProgress(p){ progressEl.textContent = Math.round(p) + '%'; }

  const fpsHolder = document.getElementById('fps');

  class FpsMonitor {
    constructor(container) {
      this.dom = document.createElement('div');
      this.dom.id = 'fps-monitor';

      this.labelEl = document.createElement('div');
      this.labelEl.className = 'fps-label';
      this.labelEl.textContent = 'fps';

      this.valueEl = document.createElement('div');
      this.valueEl.className = 'fps-value';
      this.valueEl.textContent = '000';

      this.sampleWindow = 250;
      this.frameCount = 0;
      this.lastSample = performance.now();
      this.smoothed = 0;

      this.dom.appendChild(this.labelEl);
      this.dom.appendChild(this.valueEl);
      container.appendChild(this.dom);
    }

    begin() {}

    end() {
      const now = performance.now();
      this.frameCount += 1;
      if (now - this.lastSample >= this.sampleWindow) {
        const elapsed = now - this.lastSample;
        const fps = (this.frameCount * 1000) / elapsed;
        this.frameCount = 0;
        this.lastSample = now;
        this.update(fps);
      }
    }

    update(rawFps) {
      const fps = Math.max(0, rawFps);
      this.smoothed = this.smoothed === 0 ? fps : (this.smoothed * 0.7 + fps * 0.3);
      const rounded = Math.max(0, Math.round(this.smoothed));
      this.valueEl.textContent = `${rounded.toString().padStart(3, '0')}`;
    }
  }

  const fpsMonitor = new FpsMonitor(fpsHolder);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setPixelRatio(1);
  const canvasWrap = document.getElementById('canvas-wrap');
  canvasWrap.appendChild(renderer.domElement);

  const scene = new THREE.Scene();
  scene.add(new THREE.AmbientLight(0x666666));
  const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
  sunLight.position.set(260, 220, -500);
  scene.add(sunLight);

  const camera = new THREE.PerspectiveCamera(50, 16 / 9, 0.1, 3000);
  const controls = {
    yaw: 0,
    yawVelocity: 0,
    speed: 60,
    turnSpeed: Math.PI * 0.45,
    turnSmooth: 3,
    height: 60
  };
  camera.position.set(0, controls.height, 160);
  camera.lookAt(0, 0, 0);

  const keyState = {};
  window.addEventListener('keydown', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) { keyState[e.key] = true; e.preventDefault(); }
  });
  window.addEventListener('keyup', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) { keyState[e.key] = false; e.preventDefault(); }
  });

  const onscreenButtons = document.querySelectorAll('#control-pad button[data-key]');
  onscreenButtons.forEach(btn => {
    const key = btn.dataset.key;
    const activate = ev => { keyState[key] = true; ev.preventDefault(); };
    const deactivate = ev => { keyState[key] = false; ev.preventDefault(); };
    btn.addEventListener('mousedown', activate);
    btn.addEventListener('touchstart', activate, { passive: false });
    const endEvents = ['mouseleave','mouseup','touchend','touchcancel'];
    endEvents.forEach(evt => btn.addEventListener(evt, deactivate));
    window.addEventListener('mouseup', () => { keyState[key] = false; });
    window.addEventListener('touchend', () => { keyState[key] = false; });
    window.addEventListener('touchcancel', () => { keyState[key] = false; });
  });

  let touchStart = null;
  window.addEventListener('touchstart', e => {
    if (e.target.closest('#control-pad')) return;
    touchStart = e.touches[0];
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchmove', e => {
    if (!touchStart || e.target.closest('#control-pad')) return;
    const touch = e.touches[0];
    const dx = touch.clientX - touchStart.clientX;
    const dy = touch.clientY - touchStart.clientY;
    const threshold = 10;
    keyState['ArrowLeft'] = dx < -threshold;
    keyState['ArrowRight'] = dx > threshold;
    keyState['ArrowUp'] = dy < -threshold;
    keyState['ArrowDown'] = dy > threshold;
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchend', e => {
    if (e.target.closest('#control-pad')) return;
    touchStart = null;
    keyState['ArrowLeft'] = keyState['ArrowRight'] = keyState['ArrowUp'] = keyState['ArrowDown'] = false;
    e.preventDefault();
  });

  function hash(ix, iz){ const s = Math.sin(ix*127.1 + iz*311.7) * 43758.5453123; return s - Math.floor(s); }
  const lerp = (a,b,t)=> a + (b-a)*t; const smooth = t => t*t*(3-2*t);
  function noise2(x,z){ const ix=Math.floor(x), iz=Math.floor(z), fx=x-ix, fz=z-iz;
    const a=hash(ix,iz), b=hash(ix+1,iz), c=hash(ix,iz+1), d=hash(ix+1,iz+1);
    const ux=smooth(fx), uz=smooth(fz); return lerp( lerp(a,b,ux), lerp(c,d,ux), uz ); }
  function fbm(x,z,oct=5){ let amp=1,freq=0.02,sum=0,norm=0; for(let i=0;i<oct;i++){ sum+=amp*noise2(x*freq,z*freq); norm+=amp; amp*=0.5; freq*=2; } return sum/norm; }

  const terrainSize = 600;
  const terrainSegments = 120;
  const terrain = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
  terrain.rotateX(-Math.PI/2);
  const pos = terrain.attributes.position;
  const basePositions = Float32Array.from(pos.array);
  const cellSize = terrainSize / terrainSegments;
  const chunkSize = cellSize * 10;
  const terrainState = { offsetX: 0, offsetZ: 0 };

  function refreshTerrain(offsetX, offsetZ) {
    for (let i = 0; i < pos.count; i++) {
      const ix = i * 3;
      const x = basePositions[ix];
      const z = basePositions[ix + 2];
      const worldX = x + offsetX;
      const worldZ = z + offsetZ;
      const y = fbm(worldX, worldZ) * 60 - 18;
      pos.setY(i, y);
    }
    pos.needsUpdate = true;
    terrain.computeVertexNormals();
  }
  refreshTerrain(terrainState.offsetX, terrainState.offsetZ);
  const terrainMesh = new THREE.Mesh(terrain, new THREE.MeshStandardMaterial({ color:0x2a8a4b, flatShading:true, metalness:0, roughness:1 }));
  terrainMesh.position.set(terrainState.offsetX, 0, terrainState.offsetZ);
  scene.add(terrainMesh);
  function snapToChunk(value) { return Math.round(value / chunkSize) * chunkSize; }

  const groundRay = new THREE.Raycaster();
  const floatingBlocks = [];

  function createBlock(x, z) {
    const size = 2;
    const color = new THREE.Color().setHSL(Math.random() * 0.15, 0.9, 0.5 + Math.random() * 0.1);
    const block = new THREE.Mesh(
      new THREE.BoxGeometry(size, size, size),
      new THREE.MeshStandardMaterial({ color })
    );
    groundRay.set(new THREE.Vector3(x, 100, z), new THREE.Vector3(0, -1, 0));
    const hit = groundRay.intersectObject(terrainMesh);
    const y = hit.length ? hit[0].point.y : 0;
    block.position.set(x, y + size / 2 + 8 * Math.random(), z);
    block.castShadow = true;
    block.receiveShadow = true;
    block.userData.base = block.position.clone();
    block.userData.bobSpeed = 0.35 + Math.random() * 0.3;
    block.userData.bobAmp = 4 + Math.random() * 6;
    block.userData.phase = Math.random() * Math.PI * 2;
    block.userData.windOffset = new THREE.Vector3();
    block.userData.windVelocity = new THREE.Vector3();
    scene.add(block);
    floatingBlocks.push(block);
  }

  const blockSpread = terrainSize * 0.48;
  async function generateBlocks(count) {
    for (let i = 0; i < count; i++) {
      const x = Math.random() * blockSpread * 2 - blockSpread;
      const z = Math.random() * blockSpread * 2 - blockSpread;
      createBlock(x, z);
      if (i % 50 === 0) {
        setProgress((i / count) * 100);
        await new Promise(requestAnimationFrame);
      }
    }
    setProgress(100);
    loaderEl.remove();
    console.log(`Terrain populated with ${count} blocks.`);
  }

  function updateControls(dt){
    const yawInput = (keyState['ArrowRight'] ? 1 : 0) - (keyState['ArrowLeft'] ? 1 : 0);
    const targetYawVelocity = yawInput * controls.turnSpeed;
    controls.yawVelocity = THREE.MathUtils.damp(controls.yawVelocity, targetYawVelocity, controls.turnSmooth, dt);
    controls.yaw += controls.yawVelocity * dt;
    const forward = new THREE.Vector3(Math.sin(controls.yaw), 0, -Math.cos(controls.yaw));
    let move = new THREE.Vector3();
    if (keyState['ArrowUp']) move.add(forward);
    if (keyState['ArrowDown']) move.add(forward.clone().multiplyScalar(-1));
    if (move.lengthSq() > 0) {
      move.normalize().multiplyScalar(controls.speed * dt);
      const p = camera.position.clone().add(move);
      p.y = controls.height;
      camera.position.copy(p);
    }
    const lookTarget = camera.position.clone().add(forward);
    camera.lookAt(lookTarget);
  }

  function updateTerrainFollow() {
    const snappedX = snapToChunk(camera.position.x);
    const snappedZ = snapToChunk(camera.position.z);
    if (snappedX !== terrainState.offsetX || snappedZ !== terrainState.offsetZ) {
      terrainState.offsetX = snappedX;
      terrainState.offsetZ = snappedZ;
      refreshTerrain(snappedX, snappedZ);
      terrainMesh.position.set(snappedX, 0, snappedZ);
    }
  }

  const tempVec = new THREE.Vector3();
  function updateBlocks(dt, time) {
    const cameraPos = camera.position;
    for (const block of floatingBlocks) {
      const data = block.userData;
      const bob = Math.sin(time * data.bobSpeed + data.phase) * data.bobAmp;
      const desired = data.base.clone();
      desired.y += bob;
      tempVec.copy(cameraPos).sub(block.position);
      const distance = tempVec.length();
      if (distance < 60) {
        const strength = (60 - distance) / 60;
        tempVec.set(Math.random() - 0.5, (Math.random() - 0.5) * 0.3, Math.random() - 0.5).normalize();
        data.windVelocity.addScaledVector(tempVec, strength * 18 * dt);
      }
      data.windVelocity.multiplyScalar(Math.max(0, 1 - dt * 2.4));
      data.windOffset.addScaledVector(data.windVelocity, dt);
      data.windOffset.multiplyScalar(0.94);
      desired.add(data.windOffset);
      block.position.lerp(desired, THREE.MathUtils.clamp(dt * 3, 0, 1));
    }
  }

  let last = performance.now();
  function animate(){
    fpsMonitor.begin();
    const now = performance.now();
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    updateControls(dt);
    updateTerrainFollow();
    updateBlocks(dt, now / 1000);
    renderer.render(scene, camera);
    fpsMonitor.end();
    requestAnimationFrame(animate);
  }

  console.log('Terrain initialising...');
  await generateBlocks(1000);
  console.log('Terrain ready.');
  animate();

  const resolutionSelect = document.getElementById('resolution-select');
  const resolutionDisplay = document.getElementById('resolution-display');
  const fullscreenBtn = document.getElementById('fullscreen-btn');

  const isFullscreenActive = () => Boolean(
    document.fullscreenElement ||
    document.webkitFullscreenElement ||
    document.msFullscreenElement
  );

  let currentResolution = RESOLUTIONS[4];

  function applyResolution(res) {
    currentResolution = res;
    renderer.setSize(res.width, res.height, false);
    renderer.domElement.width = res.width;
    renderer.domElement.height = res.height;
    camera.aspect = res.width / res.height;
    camera.updateProjectionMatrix();
    resolutionDisplay.textContent = `${res.label} — ${res.width} × ${res.height}`;
    updateCanvasLayout();
  }

  function parseResolution(value) {
    const [w, h] = value.split('x').map(Number);
    return RESOLUTIONS.find(r => r.width === w && r.height === h) || RESOLUTIONS[0];
  }

  function updateCanvasLayout() {
    const aspect = currentResolution.width / currentResolution.height;
    const availableWidth = Math.max(100, window.innerWidth);
    const availableHeight = Math.max(100, window.innerHeight);

    let displayWidth = availableWidth;
    let displayHeight = displayWidth / aspect;

    if (displayHeight > availableHeight) {
      const scale = availableHeight / displayHeight;
      displayWidth = Math.floor(displayWidth * scale);
      displayHeight = availableHeight;
    }

    renderer.domElement.style.width = `${displayWidth}px`;
    renderer.domElement.style.height = `${displayHeight}px`;
    canvasWrap.style.width = `${displayWidth}px`;
    canvasWrap.style.height = `${displayHeight}px`;
  }

  resolutionSelect.addEventListener('change', () => {
    applyResolution(parseResolution(resolutionSelect.value));
  });

  function updateFullscreenButton() {
    const isFullscreen = isFullscreenActive();
    fullscreenBtn.textContent = isFullscreen ? 'Exit Fullscreen' : 'Enter Fullscreen';
    const shouldShow = isFullscreen || window.innerWidth >= 720;
    fullscreenBtn.style.display = shouldShow ? 'inline-flex' : 'none';
    document.body.classList.toggle('is-fullscreen', isFullscreen);
  }

  fullscreenBtn.addEventListener('click', () => {
    if (isFullscreenActive()) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
    } else {
      const target = document.documentElement;
      const request = target.requestFullscreen || target.webkitRequestFullscreen || target.msRequestFullscreen;
      if (request) request.call(target);
    }
  });

  document.addEventListener('fullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });
  document.addEventListener('webkitfullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });
  document.addEventListener('msfullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });

  window.addEventListener('resize', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });

  applyResolution(currentResolution);
  updateFullscreenButton();
  updateCanvasLayout();
  </script>
</body>
</html>
