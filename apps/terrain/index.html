<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Terrain</title>
  <style>
    :root {
      --navy-900: #020817;
      --navy-800: #071127;
      --navy-700: #0b1a35;
      --frame-border: rgba(0, 0, 0, 0.45);
      --frame-border-light: rgba(255, 255, 255, 0.08);
      --text-white: #ffffff;
      --text-black: #050505;
      --accent-orange: #ff8b2f;
      --graph-grid: rgba(255, 255, 255, 0.18);
      --graph-fill: rgba(255, 139, 47, 0.18);
      --graph-line: #ff8b2f;
    }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      color: var(--text-white);
      font-family: 'Trebuchet MS', 'Lucida Sans', 'Geneva', sans-serif;
    }
    body {
      position: relative;
      background:
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.06), transparent 45%),
        radial-gradient(circle at 80% 30%, rgba(255, 139, 47, 0.08), transparent 55%),
        var(--navy-900);
      background-size: cover;
    }
    #scene-shell {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      pointer-events: none;
      box-sizing: border-box;
    }
    #canvas-wrap {
      position: relative;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #canvas-wrap::before,
    #canvas-wrap::after {
      content: '';
      position: absolute;
      inset: -4%;
      opacity: 0;
      pointer-events: none;
    }
    #canvas-wrap.vhs-glitch {
      animation: vhs-warp 0.6s ease-out;
      filter: saturate(1.2) contrast(1.1);
    }
    #canvas-wrap.vhs-glitch::before {
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255, 139, 47, 0.2) 0px,
          rgba(255, 139, 47, 0.2) 2px,
          transparent 2px,
          transparent 4px
        ),
        linear-gradient(90deg, rgba(255, 0, 90, 0.18), rgba(0, 240, 255, 0.18));
      mix-blend-mode: screen;
      animation: vhs-noise 0.6s ease-out forwards;
    }
    #canvas-wrap.vhs-glitch::after {
      background: linear-gradient(0deg, rgba(255, 255, 255, 0.06), transparent 60%);
      mix-blend-mode: lighten;
      animation: vhs-color 0.6s ease-out forwards;
    }
    canvas {
      display: block;
      border: 2px solid var(--frame-border);
      background: #000;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.45);
      max-width: 100%;
      max-height: 100%;
      image-rendering: pixelated;
    }
    body.terrain-fallback-mode #control-pad,
    body.terrain-fallback-mode #fullscreen-btn,
    body.terrain-fallback-mode #fps {
      display: none;
    }
    body.terrain-fallback-mode #hud-overlay {
      opacity: 0.78;
    }
    .render-mode-btn.is-disabled {
      opacity: 0.45 !important;
      cursor: not-allowed;
    }
    #loader {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: linear-gradient(180deg, #09132a 0%, #020817 100%);
      color: var(--text-white);
      font-family: 'Lucida Sans', 'Geneva', sans-serif;
      font-size: 2em;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      z-index: 60;
    }
    #loader .loader-content {
      display: grid;
      justify-items: center;
      gap: 20px;
      text-align: center;
      padding: 28px 32px;
      border: none;
      background: none;
      box-shadow: none;
      backdrop-filter: none;
    }
    #loader .loader-icon {
      width: 192px;
      height: 144px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: none;
      border: none;
      box-shadow: none;
      position: relative;
      image-rendering: pixelated;
    }
    #loader .loader-icon::after {
      display: none;
    }
    #loader .loader-icon canvas {
      width: 100%;
      height: 100%;
      display: block;
      image-rendering: pixelated;
      background: transparent;
      border: none !important;
      box-shadow: none !important;
    }
    @media (max-width: 620px) {
      #loader .loader-icon {
        transform: scale(0.82);
      }
    }
    #loader .loader-text {
      font-size: 0.54em;
      letter-spacing: 0.28em;
    }
    #loader.is-error .loader-text {
      color: #ff5b5b;
    }
    #loader .loader-meta {
      font-size: 0.36em;
      letter-spacing: 0.3em;
      color: rgba(255, 255, 255, 0.68);
    }
    @media (prefers-reduced-motion: reduce) {
      #loader .loader-icon {
        transform: none;
      }
    }
    #loader #progress {
      color: var(--accent-orange);
    }
    #fps {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 40;
      pointer-events: none;
    }
    #fps-monitor {
      position: relative;
      display: grid;
      row-gap: 6px;
      padding: 12px;
      background: linear-gradient(160deg, var(--navy-800), var(--navy-700));
      border: 1px solid var(--frame-border);
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
      min-width: 180px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-white);
    }
    #fps-monitor .panel-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.7rem;
      color: var(--accent-orange);
      letter-spacing: 0.18em;
    }
    #fps-monitor .panel-title .label {
      color: var(--text-white);
      letter-spacing: 0.2em;
    }
    #fps-monitor .fps-readout {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-family: 'Lucida Console', 'Courier New', monospace;
      color: var(--text-white);
    }
    #fps-monitor .fps-label {
      font-size: 0.65rem;
      color: var(--accent-orange);
    }
    #fps-monitor .fps-value {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--text-white);
      min-width: 3.6em;
      text-shadow: 0 0 14px rgba(255, 139, 47, 0.3);
    }
    #fps-monitor canvas {
      width: 100%;
      height: 48px;
      border: 1px solid var(--frame-border);
      background: var(--navy-900);
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
    }
    #control-ui {
      position: fixed;
      top: 14px;
      right: 14px;
      background: rgba(7, 17, 39, 0.55);
      border: 1px solid var(--frame-border);
      box-shadow: inset 0 0 0 1px var(--frame-border-light), 0 12px 26px rgba(0, 0, 0, 0.38);
      padding: 14px 16px 18px;
      display: grid;
      row-gap: 12px;
      width: min(220px, 78vw);
      z-index: 34;
      font-family: 'Lucida Sans', 'Geneva', sans-serif;
      color: var(--text-white);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      backdrop-filter: blur(14px);
      transition: background 0.35s ease, border-color 0.35s ease;
    }
    #control-ui.folded {
      background: rgba(7, 17, 39, 0.38);
      border-color: rgba(255, 255, 255, 0.12);
    }
    #control-ui .ui-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    #control-ui h2 {
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.68rem;
      color: var(--accent-orange);
      letter-spacing: 0.2em;
    }
    #control-ui h2 span:last-child {
      color: var(--text-white);
      letter-spacing: 0.24em;
    }
    #ui-fold-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      background: rgba(2, 8, 23, 0.35);
      color: var(--text-white);
      font-size: 0.52rem;
      letter-spacing: 0.16em;
      padding: 5px 10px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    #ui-fold-btn:hover {
      background: rgba(255, 139, 47, 0.25);
      border-color: rgba(255, 139, 47, 0.6);
      transform: translateY(-1px);
    }
    #ui-fold-btn:active {
      transform: translateY(1px);
    }
    #ui-fold-btn .fold-icon {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.35s ease;
    }
    #ui-fold-btn .fold-icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
      transform-origin: center;
      transition: transform 0.35s ease;
      animation: fold-pulse 2.4s ease-in-out infinite;
    }
    #control-ui.folded #ui-fold-btn .fold-icon svg {
      transform: rotate(-90deg);
    }
    .fold-body {
      display: grid;
      row-gap: 10px;
      max-height: 340px;
      overflow: hidden;
      transition: max-height 0.4s ease, opacity 0.3s ease;
    }
    #control-ui.folded .fold-body {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .ui-icon {
      width: 22px;
      height: 22px;
      display: grid;
      place-items: center;
      perspective: 400px;
    }
    .ui-icon svg {
      width: 100%;
      height: 100%;
      fill: var(--text-white);
      transform-origin: center;
      animation: icon-spin 6s linear infinite;
      filter: drop-shadow(0 0 6px rgba(255, 139, 47, 0.35));
    }
    @keyframes icon-spin {
      0% { transform: rotateX(0deg) rotateY(0deg); }
      50% { transform: rotateX(18deg) rotateY(180deg); }
      100% { transform: rotateX(0deg) rotateY(360deg); }
    }
    @keyframes fold-pulse {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.12); }
    }
    @keyframes vhs-warp {
      0% { transform: translate3d(0, 0, 0) skewX(0deg); filter: saturate(1.1) contrast(1.05); }
      20% { transform: translate3d(-4px, 0, 0) skewX(-1.5deg); filter: saturate(1.4) contrast(1.25); }
      45% { transform: translate3d(3px, 0, 0) skewX(1deg); filter: saturate(1.25) contrast(1.18); }
      70% { transform: translate3d(-2px, 0, 0) skewX(-0.6deg); filter: saturate(1.15) contrast(1.12); }
      100% { transform: translate3d(0, 0, 0) skewX(0deg); filter: saturate(1.1) contrast(1.05); }
    }
    @keyframes vhs-noise {
      0% { opacity: 0.55; transform: translate3d(-8px, 0, 0); }
      25% { opacity: 0.7; transform: translate3d(6px, 0, 0); }
      50% { opacity: 0.45; transform: translate3d(-3px, 0, 0); }
      75% { opacity: 0.35; transform: translate3d(2px, 0, 0); }
      100% { opacity: 0; transform: translate3d(0, 0, 0); }
    }
    @keyframes vhs-color {
      0% { opacity: 0.45; transform: translate3d(2px, 0, 0); }
      30% { opacity: 0.35; transform: translate3d(-3px, 0, 0); }
      60% { opacity: 0.2; transform: translate3d(2px, 0, 0); }
      100% { opacity: 0; transform: translate3d(0, 0, 0); }
    }
    #canvas-wrap .vhs-line {
      --shift-start: 0px;
      --shift-mid: 0px;
      --shift-end: 0px;
      --shift-clear: 0px;
      --skew-start: 0deg;
      --skew-mid: 0deg;
      --skew-end: 0deg;
      --line-opacity: 0.6;
      --line-brightness: 1.1;
      --line-hue: 0deg;
      position: absolute;
      left: -8%;
      width: 116%;
      top: 50%;
      height: 8px;
      pointer-events: none;
      background:
        linear-gradient(90deg, rgba(255, 0, 90, 0.25), rgba(0, 240, 255, 0.32)),
        repeating-linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.75) 0px,
          rgba(255, 255, 255, 0.75) 6px,
          rgba(255, 255, 255, 0.05) 6px,
          rgba(255, 255, 255, 0.05) 12px
        );
      background-size: 180px 100%, 20px 100%;
      mix-blend-mode: screen;
      box-shadow: 0 0 24px rgba(255, 139, 47, 0.4);
      opacity: 0;
      transform: translateX(var(--shift-start)) skewX(var(--skew-start));
      animation: vhs-line-burst 0.55s cubic-bezier(0.25, 0.8, 0.45, 1) forwards;
      filter: hue-rotate(var(--line-hue)) saturate(1.6) brightness(var(--line-brightness));
    }
    #canvas-wrap .vhs-line::before,
    #canvas-wrap .vhs-line::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    #canvas-wrap .vhs-line::before {
      background:
        repeating-linear-gradient(
          0deg,
          rgba(255, 139, 47, 0.45) 0px,
          rgba(255, 139, 47, 0.45) 2px,
          rgba(0, 0, 0, 0) 2px,
          rgba(0, 0, 0, 0) 4px
        );
      opacity: 0.8;
    }
    #canvas-wrap .vhs-line::after {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.4), transparent);
      mix-blend-mode: overlay;
      opacity: 0.5;
    }
    #canvas-wrap .vhs-line--cluster {
      box-shadow: 0 0 28px rgba(0, 240, 255, 0.32);
    }
    #canvas-wrap .vhs-line--cluster::before {
      background:
        repeating-linear-gradient(
          0deg,
          rgba(0, 240, 255, 0.35) 0px,
          rgba(0, 240, 255, 0.35) var(--cluster-thickness, 3px),
          rgba(0, 0, 0, 0) var(--cluster-thickness, 3px),
          rgba(0, 0, 0, 0) calc(var(--cluster-thickness, 3px) * 2)
        );
      opacity: 0.9;
    }
    @keyframes vhs-line-burst {
      0% {
        opacity: 0;
        transform: translateX(var(--shift-start)) skewX(var(--skew-start));
      }
      14% {
        opacity: calc(var(--line-opacity) + 0.2);
      }
      38% {
        opacity: var(--line-opacity);
        transform: translateX(var(--shift-mid)) skewX(var(--skew-mid));
      }
      70% {
        opacity: calc(var(--line-opacity) * 0.45);
        transform: translateX(var(--shift-end)) skewX(var(--skew-end));
      }
      100% {
        opacity: 0;
        transform: translateX(var(--shift-clear)) skewX(0deg);
      }
    }
    #resolution-display {
      font-size: 0.74rem;
      font-weight: 700;
      color: var(--text-white);
      text-shadow: 0 0 12px rgba(255, 139, 47, 0.4);
    }
    label[for="resolution-select"] {
      font-size: 0.62rem;
      color: var(--text-white);
    }
    .select-wrap {
      position: relative;
    }
    .select-wrap::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 12px;
      width: 8px;
      height: 8px;
      border-right: 2px solid var(--accent-orange);
      border-bottom: 2px solid var(--accent-orange);
      transform: translateY(-50%) rotate(45deg);
      pointer-events: none;
    }
    #resolution-select {
      width: 100%;
      padding: 6px 28px 6px 10px;
      border-radius: 0;
      border: 1px solid var(--frame-border);
      background: rgba(2, 8, 23, 0.65);
      color: var(--text-white);
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      appearance: none;
      outline: none;
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
    }
    #resolution-select:focus {
      border-color: var(--accent-orange);
      box-shadow: 0 0 0 1px rgba(255, 139, 47, 0.35), 0 0 0 4px rgba(255, 139, 47, 0.15);
    }
    #fullscreen-btn {
      position: fixed;
      left: 50%;
      bottom: 32px;
      transform: translateX(-50%);
      padding: 8px 26px;
      background: linear-gradient(160deg, rgba(2, 8, 23, 0.85), rgba(11, 26, 53, 0.85));
      border: 1px solid var(--frame-border);
      color: var(--text-white);
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      cursor: pointer;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);
      text-transform: uppercase;
      transition: transform 0.15s ease;
      z-index: 48;
      display: none;
      border-radius: 999px;
      align-items: center;
      justify-content: center;
      gap: 10px;
      backdrop-filter: blur(10px);
    }
    #fullscreen-btn:hover {
      transform: translateX(-50%) translateY(-2px);
    }
    #fullscreen-btn:active {
      transform: translateX(-50%) translateY(2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.55);
    }
    #control-pad {
      position: fixed;
      bottom: 22px;
      right: 22px;
      display: grid;
      grid-template-columns: repeat(3, 44px);
      grid-template-rows: repeat(3, 44px);
      gap: 8px;
      z-index: 35;
    }
    #control-pad button,
    #control-pad span {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      border: 1px solid var(--frame-border);
      background: rgba(2, 8, 23, 0.72);
      color: var(--text-white);
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 10px 16px rgba(0, 0, 0, 0.42);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      text-shadow: 0 0 10px rgba(255, 139, 47, 0.35);
    }
    #control-pad span {
      cursor: default;
      opacity: 0;
      box-shadow: none;
      border: none;
      pointer-events: none;
    }
    #control-pad button:active {
      transform: translateY(2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
    }
    @media (max-width: 720px) {
      #control-pad {
        right: 14px;
        bottom: 14px;
        grid-template-columns: repeat(3, 40px);
        grid-template-rows: repeat(3, 40px);
        gap: 6px;
      }
      #control-pad button,
      #control-pad span {
        width: 40px;
        height: 40px;
      }
      #control-ui {
        right: 10px;
        top: 10px;
        padding: 12px 12px 14px;
        width: min(200px, 82vw);
      }
      #ui-fold-btn {
        padding: 4px 8px;
        letter-spacing: 0.12em;
      }
    }
    #hud-overlay {
      position: fixed;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      display: grid;
      gap: 6px;
      padding: 14px 20px;
      background: rgba(2, 8, 23, 0.42);
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08), 0 12px 24px rgba(0, 0, 0, 0.35);
      font-family: 'Lucida Console', 'Courier New', monospace;
      font-size: 0.64rem;
      color: var(--text-white);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      min-width: min(420px, 94vw);
      max-width: min(560px, 94vw);
      z-index: 42;
      backdrop-filter: blur(12px);
      pointer-events: auto;
    }
    #hud-overlay .hud-title {
      display: grid;
      gap: 2px;
      color: var(--accent-orange);
      letter-spacing: 0.18em;
      font-size: 0.6rem;
      text-align: center;
      pointer-events: none;
    }
    #hud-overlay .hud-title span:last-child {
      color: rgba(255, 255, 255, 0.78);
      letter-spacing: 0.16em;
    }
    #hud-overlay .hud-line {
      pointer-events: none;
    }
    .hud-render-modes {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(118px, 1fr));
      gap: 8px;
      justify-content: center;
      pointer-events: auto;
    }
    .hud-render-modes button {
      padding: 6px 10px;
      background: rgba(2, 8, 23, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.24);
      color: rgba(255, 255, 255, 0.82);
      font-family: 'Lucida Console', 'Courier New', monospace;
      font-size: 0.56rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
    }
    .hud-render-modes button:hover {
      border-color: var(--accent-orange);
    }
    .hud-render-modes button:focus-visible {
      outline: 2px solid var(--accent-orange);
      outline-offset: 2px;
    }
    .hud-render-modes button.is-active {
      border-color: var(--accent-orange);
      background: rgba(255, 139, 47, 0.25);
      color: var(--text-white);
      text-shadow: 0 0 8px rgba(255, 139, 47, 0.35);
    }
    #hud-overlay .hud-line {
      display: flex;
      justify-content: space-between;
      gap: 18px;
    }
    #hud-overlay .hud-value {
      color: rgba(255, 255, 255, 0.86);
    }
    #console-dock {
      position: fixed;
      bottom: 0;
      left: 0;
      width: min(520px, 92vw);
      max-height: 220px;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 8px;
      background: rgba(2, 8, 23, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.55);
      font-family: 'Lucida Console', 'Courier New', monospace;
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      overflow: hidden;
      backdrop-filter: blur(10px);
      z-index: 36;
    }
    #console-dock .console-headline {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 0.62rem;
      color: var(--accent-orange);
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }
    #console-dock .console-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #console-dock .console-status {
      color: rgba(255, 255, 255, 0.72);
      letter-spacing: 0.12em;
    }
    #console-fold-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: rgba(2, 8, 23, 0.45);
      color: var(--text-white);
      font-family: inherit;
      font-size: 0.52rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    #console-fold-btn:hover {
      background: rgba(255, 139, 47, 0.2);
      border-color: rgba(255, 139, 47, 0.55);
      transform: translateY(-1px);
    }
    #console-fold-btn:active {
      transform: translateY(1px);
    }
    #console-fold-btn .fold-icon {
      width: 14px;
      height: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.35s ease;
    }
    #console-fold-btn .fold-icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
      transform-origin: center;
      transition: transform 0.35s ease;
    }
    #console-dock.folded #console-fold-btn .fold-icon svg {
      transform: rotate(-90deg);
    }
    #console-dock #console-log {
      position: relative;
      inset: auto;
      width: 100%;
      max-height: 160px;
      padding: 8px 12px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      pointer-events: auto;
      transition: max-height 0.35s ease, opacity 0.3s ease;
    }
    #console-dock #console-log .console-line {
      margin-bottom: 4px;
      white-space: pre-wrap;
    }
    #console-dock.folded #console-log {
      max-height: 0;
      opacity: 0;
      padding-top: 0;
      padding-bottom: 0;
      border-color: rgba(255, 255, 255, 0.06);
      pointer-events: none;
      overflow: hidden;
    }
    body.is-mobile {
      --hud-offset: 56px;
    }
    body.is-mobile #fullscreen-btn {
      top: 14px;
      right: 14px;
      bottom: auto;
      left: auto;
      transform: none;
      padding: 8px 18px;
      gap: 8px;
      font-size: 0.58rem;
      letter-spacing: 0.14em;
      box-shadow: 0 12px 22px rgba(0, 0, 0, 0.45);
    }
    body.is-mobile #fullscreen-btn::before {
      content: '';
      width: 12px;
      height: 12px;
      border: 2px solid currentColor;
      border-radius: 3px;
      transform: translateZ(0);
    }
    body.is-mobile #control-ui {
      top: 110px;
      right: 14px;
      left: 14px;
      width: auto;
      padding: 12px 14px 16px;
      border-radius: 14px;
      background: rgba(7, 17, 39, 0.55);
      row-gap: 10px;
    }
    body.is-mobile #control-ui.folded {
      background: rgba(7, 17, 39, 0.45);
    }
    body.is-mobile #control-ui h2 {
      font-size: 0.62rem;
    }
    body.is-mobile #hud-overlay {
      top: calc(14px + var(--hud-offset));
      width: calc(100% - 28px);
      min-width: 0;
      font-size: 0.56rem;
      gap: 4px;
      padding: 10px 14px;
    }
    body.is-mobile #hud-overlay .hud-title {
      font-size: 0.52rem;
    }
    body.is-mobile #hud-overlay .hud-title span:last-child {
      display: none;
    }
    body.is-mobile .hud-render-modes {
      grid-template-columns: 1fr;
      gap: 6px;
    }
    body.is-mobile .hud-render-modes button {
      padding: 5px 8px;
      font-size: 0.52rem;
    }
    body.is-mobile #control-pad {
      right: 14px;
      bottom: 108px;
      grid-template-columns: repeat(3, 36px);
      grid-template-rows: repeat(3, 36px);
      gap: 6px;
    }
    body.is-mobile #control-pad button,
    body.is-mobile #control-pad span {
      width: 36px;
      height: 36px;
      font-size: 1.1rem;
    }
    body.is-mobile #fps {
      top: 14px;
      left: 14px;
      right: auto;
      bottom: auto;
    }
    body.is-mobile #console-dock {
      bottom: 14px;
      left: 14px;
      right: auto;
      width: min(320px, 74vw);
      max-height: 42vh;
      padding: 10px 12px;
      border-radius: 16px;
      gap: 6px;
      font-size: 0.6rem;
    }
    body.is-mobile #console-dock .console-headline {
      font-size: 0.54rem;
    }
    body.is-mobile #console-dock #console-log {
      max-height: 28vh;
    }
    body.is-mobile #console-dock.folded {
      width: auto;
      padding: 8px 12px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.5);
    }
    body.is-mobile #console-dock.folded #console-status,
    body.is-mobile #console-dock.folded #console-log {
      display: none;
    }
  </style>
</head>
<body>
  <div id="scene-shell">
    <div id="canvas-wrap"></div>
  </div>
  <div id="control-ui">
    <div class="ui-header">
      <h2>
        <span class="ui-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="presentation">
            <polygon points="12,2 22,7 22,17 12,22 2,17 2,7" opacity="0.4"></polygon>
            <polygon points="12,4.5 19.5,8.2 19.5,15.8 12,19.5 4.5,15.8 4.5,8.2" fill="currentColor"></polygon>
            <path d="M9 10h2v2H9zm4 0h2v2h-2zm-2 3h2v2h-2z" fill="var(--accent-orange)"></path>
          </svg>
        </span>
        <span>Games Mode</span>
      </h2>
        <button id="ui-fold-btn" type="button" aria-label="Collapse control panel" aria-expanded="true" aria-controls="ui-foldable">
          <span class="fold-icon" aria-hidden="true">
            <svg viewBox="0 0 16 16" role="presentation" focusable="false">
              <path d="M4.2 2.8a1 1 0 0 1 1.6 0l4 5a1 1 0 0 1 0 1.2l-4 5a1 1 0 0 1-1.6-1.2L7.7 8 4.2 4a1 1 0 0 1 0-1.2z"></path>
            </svg>
          </span>
        </button>
    </div>
    <div id="ui-foldable" class="fold-body">
      <div id="resolution-display">—</div>
      <label for="resolution-select">Resolution</label>
      <div class="select-wrap">
        <select id="resolution-select" aria-label="Resolution selector">
        <option value="256x192">ZX Spectrum — 256 × 192</option>
        <option value="320x200">Commodore 64 — 320 × 200</option>
        <option value="320x256">Amiga 500 (PAL Lowres) — 320 × 256</option>
        <option value="640x512">Amiga 500 (PAL HiRes) — 640 × 512</option>
        <option value="640x480">VGA Era — 640 × 480</option>
        <option value="800x600">SVGA Era — 800 × 600</option>
        <option value="640x360">EDTV 360p — 640 × 360</option>
        <option value="854x480">Wide 480p — 854 × 480</option>
        <option value="960x540">qHD 540p — 960 × 540</option>
        <option value="1024x576">WSVGA — 1024 × 576</option>
        <option value="1280x720" selected>HD 720p — 1280 × 720</option>
        <option value="1366x768">HD 768p — 1366 × 768</option>
        <option value="1600x900">HD+ — 1600 × 900</option>
        <option value="1920x1080">Full HD — 1920 × 1080</option>
        <option value="2560x1440">Quad HD — 2560 × 1440</option>
        <option value="3200x1800">QHD+ — 3200 × 1800</option>
        <option value="3840x2160">4K Ultra HD — 3840 × 2160</option>
        </select>
      </div>
    </div>
  </div>
  <button id="fullscreen-btn" type="button">Enter Fullscreen</button>
  <div id="control-pad">
    <span></span>
    <button data-key="ArrowUp" aria-label="Move forward">▲</button>
    <span></span>
    <button data-key="ArrowLeft" aria-label="Turn left">◀</button>
    <span></span>
    <button data-key="ArrowRight" aria-label="Turn right">▶</button>
    <span></span>
    <button data-key="ArrowDown" aria-label="Move backward">▼</button>
    <span></span>
  </div>
  <div id="hud-overlay" aria-live="polite">
    <div class="hud-title">
      <span>Terrain Telemetry Uplink // Horizon Sweep</span>
      <span>Orbital Metrics Stream — Vectors Locked</span>
    </div>
    <div class="hud-render-modes" role="group" aria-label="Rendering mode">
      <button type="button" class="render-mode-btn is-active" data-render-mode="default" aria-pressed="true">Default</button>
      <button type="button" class="render-mode-btn" data-render-mode="wire" aria-pressed="false">Wired Vectors</button>
      <button type="button" class="render-mode-btn" data-render-mode="zx" aria-pressed="false">ZX Spectrum</button>
      <button type="button" class="render-mode-btn" data-render-mode="petscii" aria-pressed="false">Commodore PETSCII</button>
    </div>
    <div class="hud-line"><span>Position</span><span class="hud-value" data-hud="position">0, 0, 0</span></div>
    <div class="hud-line"><span>Heading</span><span class="hud-value" data-hud="heading">0° / 0°</span></div>
    <div class="hud-line"><span>Chunk</span><span class="hud-value" data-hud="chunk">0, 0</span></div>
    <div class="hud-line"><span>Speed</span><span class="hud-value" data-hud="speed">0 m/s</span></div>
  </div>
  <div id="fps"></div>
  <div id="console-dock" class="folded">
    <div class="console-headline">
      <span class="console-title">Console Log</span>
      <div class="console-actions">
        <span id="console-status" class="console-status">Folded</span>
        <button id="console-fold-btn" type="button" aria-label="Expand console log" aria-expanded="false" aria-controls="console-log">
          <span class="fold-icon" aria-hidden="true">
            <svg viewBox="0 0 16 16" role="presentation" focusable="false">
              <path d="M4.2 2.8a1 1 0 0 1 1.6 0l4 5a1 1 0 0 1 0 1.2l-4 5a1 1 0 0 1-1.6-1.2L7.7 8 4.2 4a1 1 0 0 1 0-1.2z"></path>
            </svg>
          </span>
        </button>
      </div>
    </div>
    <div id="console-log" role="log" aria-live="polite"></div>
  </div>
  <div id="loader">
    <div class="loader-content">
      <div class="loader-icon" aria-hidden="true">
        <canvas id="loader-canvas" width="192" height="144" role="presentation"></canvas>
      </div>
      <div class="loader-text">Loading <span id="progress">0%</span></div>
      <div class="loader-meta">© 2025 Cyborgs Dream</div>
    </div>
  </div>
  <script type="module">
  import { initConsoleLogs } from '../../shared/consolelogs.js';

  async function loadThreeModule() {
    const sources = [
      '../../shared/vendor/three/three.module.js',
      'https://unpkg.com/three@0.160.0/build/three.module.js',
      'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js',
      'https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.module.js'
    ];

    const errors = [];
    for (const source of sources) {
      try {
        if (!source.startsWith('http')) {
          const response = await fetch(source, { method: 'HEAD' });
          if (!response.ok) {
            throw new Error(`HTTP ${response.status} ${response.statusText}`);
          }
        }
        const mod = await import(source);
        const namespace = mod && mod.default ? mod.default : mod;
        if (namespace && typeof namespace.Scene === 'function' && typeof namespace.WebGLRenderer === 'function') {
          return { module: namespace, source };
        }
        errors.push({ source, error: new Error('Loaded module missing THREE exports.') });
        console.warn(`Loaded module from ${source} but it is missing expected THREE.js exports.`);
      } catch (err) {
        errors.push({ source, error: err });
        console.warn(`Failed to load THREE.js from ${source}`, err);
      }
    }

    const aggregate = new Error('Unable to load THREE.js module from any configured source.');
    aggregate.details = errors;
    throw aggregate;
  }

  function activateTerrainFallback(error, { setConsoleFolded } = {}) {
    console.warn('Switching to 2D fallback terrain visualiser.', error);

    if (typeof setConsoleFolded === 'function') {
      setConsoleFolded(false);
    }

    const loader = document.getElementById('loader');
    const progress = document.getElementById('progress');
    if (loader) {
      loader.classList.add('is-error');
      const loaderText = loader.querySelector('.loader-text');
      if (loaderText) {
        loaderText.textContent = 'Terrain offline mode';
      }
      if (progress) {
        progress.textContent = 'Offline';
      }
      const meta = loader.querySelector('.loader-meta');
      if (meta) {
        meta.textContent = 'Fallback renderer active';
      }
      loader.style.transition = 'opacity 0.8s ease';
      loader.style.pointerEvents = 'none';
      setTimeout(() => {
        loader.style.opacity = '0';
      }, 600);
      setTimeout(() => {
        loader.remove();
      }, 1600);
    }

    const canvasWrap = document.getElementById('canvas-wrap');
    if (!canvasWrap) {
      return;
    }

    canvasWrap.innerHTML = '';
    const canvas = document.createElement('canvas');
    const aspectRatio = 16 / 9;
    let logicalWidth = 960;
    let logicalHeight = 540;
    canvas.width = logicalWidth;
    canvas.height = logicalHeight;
    canvas.setAttribute('role', 'img');
    canvas.setAttribute('aria-label', 'Fallback terrain visualisation');
    canvas.classList.add('terrain-fallback-canvas');
    canvasWrap.appendChild(canvas);

    const ctx = canvas.getContext('2d');
    if (!ctx) {
      return;
    }

    document.body.classList.add('terrain-fallback-mode');

    document.querySelectorAll('[data-render-mode]').forEach(btn => {
      btn.setAttribute('disabled', 'true');
      btn.classList.add('is-disabled');
      btn.setAttribute('aria-pressed', 'false');
    });

    const hudPosition = document.querySelector('[data-hud="position"]');
    const hudHeading = document.querySelector('[data-hud="heading"]');
    const hudChunk = document.querySelector('[data-hud="chunk"]');
    const hudSpeed = document.querySelector('[data-hud="speed"]');
    if (hudPosition) hudPosition.textContent = 'Offline';
    if (hudHeading) hudHeading.textContent = '—';
    if (hudChunk) hudChunk.textContent = '—';
    if (hudSpeed) hudSpeed.textContent = '0 m/s';

    const ridges = new Array(6).fill(null).map((_, idx) => ({
      offset: idx * 60,
      amplitude: 26 + idx * 9,
      wavelength: 120 - idx * 6,
      speed: 0.0009 + idx * 0.00035,
      hue: 200 + idx * 12
    }));

    const canvasCtx = ctx;

    function resizeCanvas() {
      const wrapRect = canvasWrap.getBoundingClientRect();
      const availableWidth = Math.max(320, Math.floor(wrapRect.width || window.innerWidth));
      const availableHeight = Math.max(240, Math.floor(wrapRect.height || window.innerHeight));
      let width = availableWidth;
      let height = Math.floor(width / aspectRatio);
      if (height > availableHeight) {
        height = availableHeight;
        width = Math.floor(height * aspectRatio);
      }
      logicalWidth = Math.max(320, width);
      logicalHeight = Math.max(200, height);
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      canvas.width = Math.floor(logicalWidth * dpr);
      canvas.height = Math.floor(logicalHeight * dpr);
      canvas.style.width = `${logicalWidth}px`;
      canvas.style.height = `${logicalHeight}px`;
      canvasCtx.setTransform(dpr, 0, 0, dpr, 0, 0);
    }

    function draw(time = 0) {
      const t = time;
      canvasCtx.clearRect(0, 0, logicalWidth, logicalHeight);

      const gradient = canvasCtx.createLinearGradient(0, 0, 0, logicalHeight);
      gradient.addColorStop(0, '#040b1a');
      gradient.addColorStop(0.45, '#071a2f');
      gradient.addColorStop(1, '#0b1124');
      canvasCtx.fillStyle = gradient;
      canvasCtx.fillRect(0, 0, logicalWidth, logicalHeight);

      canvasCtx.save();
      canvasCtx.translate(0, logicalHeight * 0.55);
      canvasCtx.globalCompositeOperation = 'lighter';

      for (const ridge of ridges) {
        canvasCtx.beginPath();
        const amplitude = ridge.amplitude;
        const wavelength = ridge.wavelength;
        for (let x = 0; x <= logicalWidth; x += 6) {
          const y = Math.sin((x + ridge.offset) / wavelength + t * ridge.speed) * amplitude;
          const perspective = 1 + x / 900;
          const px = x;
          const py = y / perspective - ridge.offset * 0.12;
          if (x === 0) {
            canvasCtx.moveTo(px, py);
          } else {
            canvasCtx.lineTo(px, py);
          }
        }
        canvasCtx.lineTo(logicalWidth, logicalHeight);
        canvasCtx.lineTo(0, logicalHeight);
        canvasCtx.closePath();
        canvasCtx.fillStyle = `hsla(${ridge.hue}, 75%, 55%, 0.08)`;
        canvasCtx.fill();
        canvasCtx.lineWidth = 1.2;
        canvasCtx.strokeStyle = `hsla(${ridge.hue}, 90%, 62%, 0.22)`;
        canvasCtx.stroke();
        ridge.offset += 0.12;
      }

      canvasCtx.restore();

      canvasCtx.fillStyle = 'rgba(255, 255, 255, 0.04)';
      for (let y = 0; y < logicalHeight; y += 4) {
        canvasCtx.fillRect(0, y, logicalWidth, 1);
      }

      canvasCtx.fillStyle = 'rgba(255, 139, 47, 0.4)';
      const markerY = (Math.sin(t * 0.0018) * 0.5 + 0.5) * logicalHeight * 0.9 + logicalHeight * 0.05;
      canvasCtx.fillRect(0, markerY, logicalWidth, 2);

      requestAnimationFrame(draw);
    }

    resizeCanvas();
    window.addEventListener('resize', resizeCanvas);
    requestAnimationFrame(draw);
  }

  (async () => {

  const consoleLogEl = document.getElementById('console-log');
  const consoleDock = document.getElementById('console-dock');
  const consoleFoldBtn = document.getElementById('console-fold-btn');
  const consoleStatus = document.getElementById('console-status');
  let setConsoleFolded = null;

  initConsoleLogs({ container: consoleLogEl, removeAfter: null });
  console.log('Console dock folded for minimal footprint.');

  if (consoleFoldBtn && consoleDock) {
    const syncConsoleFold = (folded) => {
      consoleDock.classList.toggle('folded', folded);
      consoleFoldBtn.setAttribute('aria-expanded', String(!folded));
      if (consoleStatus) {
        consoleStatus.textContent = folded ? 'Folded' : 'Expanded';
      }
      const label = folded ? 'Expand console log' : 'Collapse console log';
      consoleFoldBtn.setAttribute('aria-label', label);
    };
    setConsoleFolded = syncConsoleFold;
    consoleFoldBtn.addEventListener('click', () => {
      const next = !consoleDock.classList.contains('folded');
      syncConsoleFold(next);
      console.log(`Console log ${next ? 'folded' : 'expanded'}.`);
    });
    syncConsoleFold(consoleDock.classList.contains('folded'));
  }

  const hudElements = {
    position: document.querySelector('[data-hud="position"]'),
    heading: document.querySelector('[data-hud="heading"]'),
    chunk: document.querySelector('[data-hud="chunk"]'),
    speed: document.querySelector('[data-hud="speed"]')
  };
  console.log('HUD telemetry overlay online.');
  console.log('Compact terrain interface scaling engaged.');

  let THREE_NS = null;
  let threeSource = null;
  try {
    const { module, source } = await loadThreeModule();
    THREE_NS = module;
    threeSource = source;
  } catch (error) {
    console.error('Unable to initialise THREE.js for the terrain demo.', error);
    activateTerrainFallback(error, { setConsoleFolded });
    return;
  }

  if (threeSource) {
    console.log(`THREE.js loaded from ${threeSource}.`);
  }

  const THREE = THREE_NS;

  const renderModeButtons = document.querySelectorAll('[data-render-mode]');
  const renderModeDescriptions = {
    default: 'default shading',
    wire: 'wired vectors',
    zx: 'ZX Spectrum wireframe',
    petscii: 'Commodore PETSCII mosaic'
  };
  const retroPalettes = {
    zx: [
      0x000000, 0x0000d7, 0xd70000, 0xd700d7,
      0x00d700, 0x00d7d7, 0xd7d700, 0xd7d7d7,
      0x000000, 0x0000ff, 0xff0000, 0xff00ff,
      0x00ff00, 0x00ffff, 0xffff00, 0xffffff
    ],
    petscii: [
      0x000000, 0x00ff6a
    ]
  };
  const retroModeConfigs = {
    default: { blockSize: 1, attributeMode: 'quantize' },
    zx: { blockSize: 8, attributeMode: 'attribute' },
    petscii: { blockSize: 8, attributeMode: 'petscii' }
  };
  const zxGroundPalette = retroPalettes.zx.map(hex => new THREE.Color(hex));
  let currentRenderMode = 'default';
  const wireModePalette = {
    wire: {
      terrain: new THREE.Color(0x8fd6ff),
      block: new THREE.Color(0xffb86b)
    },
    zx: {
      terrain: new THREE.Color(0x00ffff),
      block: new THREE.Color(0xff2aff)
    }
  };
  const getWireColorsForMode = (mode) => wireModePalette[mode] || wireModePalette.wire;
  let defaultTerrainColor = null;

  const paletteScratchColor = new THREE.Color();
  function findNearestPaletteColor(color, palette) {
    let closest = palette[0];
    let smallestDistance = Infinity;
    for (const swatch of palette) {
      const dr = color.r - swatch.r;
      const dg = color.g - swatch.g;
      const db = color.b - swatch.b;
      const distance = dr * dr + dg * dg + db * db;
      if (distance < smallestDistance) {
        smallestDistance = distance;
        closest = swatch;
      }
    }
    return closest;
  }

  const renderModeFogColors = {
    default: 0x020817,
    wire: 0x020817,
    zx: 0x0000d7,
    petscii: 0x00140a
  };

  const renderModeCanvasBackgrounds = {
    default: '#020817',
    wire: '#020817',
    zx: '#0000d7',
    petscii: '#00140a'
  };

  const RESOLUTIONS = [
    { label: 'ZX Spectrum', width: 256, height: 192 },
    { label: 'Commodore 64', width: 320, height: 200 },
    { label: 'Amiga 500 PAL Lowres', width: 320, height: 256 },
    { label: 'Amiga 500 PAL HiRes', width: 640, height: 512 },
    { label: 'VGA Era', width: 640, height: 480 },
    { label: 'SVGA Era', width: 800, height: 600 },
    { label: 'EDTV 360p', width: 640, height: 360 },
    { label: 'Wide 480p', width: 854, height: 480 },
    { label: 'qHD 540p', width: 960, height: 540 },
    { label: 'WSVGA', width: 1024, height: 576 },
    { label: 'HD 720p', width: 1280, height: 720 },
    { label: 'HD 768p', width: 1366, height: 768 },
    { label: 'HD+', width: 1600, height: 900 },
    { label: 'Full HD', width: 1920, height: 1080 },
    { label: 'Quad HD', width: 2560, height: 1440 },
    { label: 'QHD+', width: 3200, height: 1800 },
    { label: '4K Ultra HD', width: 3840, height: 2160 }
  ];
  const defaultResolution = RESOLUTIONS.find(r => r.width === 1280 && r.height === 720) || RESOLUTIONS[0];

  const loaderEl = document.getElementById('loader');
  const progressEl = document.getElementById('progress');
  function setProgress(p){
    if (!progressEl) return;
    progressEl.textContent = Math.round(p) + '%';
  }

  const GOURAUD_LEVELS = 6;

  function applyGouraudQuantization(material, levels = GOURAUD_LEVELS) {
    const cacheKey = `gouraud_${levels}`;
    material.onBeforeCompile = (shader) => {
      shader.fragmentShader = shader.fragmentShader.replace(
        'gl_FragColor = vec4( outgoingLight, diffuseColor.a );',
        `
        vec3 gouraudColor = floor(outgoingLight * ${levels}.0 + 0.5) / ${levels}.0;
        gl_FragColor = vec4( gouraudColor, diffuseColor.a );
      `
      );
    };
    material.customProgramCacheKey = () => cacheKey;
    material.needsUpdate = true;
  }

  function createGouraudMaterial({ color = new THREE.Color(0xffffff), emissive = new THREE.Color(0x000000), emissiveIntensity = 1, vertexColors = false } = {}) {
    const material = new THREE.MeshLambertMaterial({
      color,
      emissive,
      emissiveIntensity,
      vertexColors,
      fog: true
    });
    applyGouraudQuantization(material);
    return material;
  }

  let stopLoaderAnimation = () => {};
  {
    const loaderCanvas = document.getElementById('loader-canvas');
    if (loaderCanvas) {
      const ctx = loaderCanvas.getContext('2d', { alpha: true });
      const width = loaderCanvas.width;
      const height = loaderCanvas.height;
      ctx.imageSmoothingEnabled = false;
      ctx.lineJoin = 'round';
      ctx.lineCap = 'round';

      const halfWidth = width * 0.5;
      const halfHeight = height * 0.5;

      const zxFacePairs = [
        ['#0000d7', '#0000ff'],
        ['#00d7d7', '#00ffff'],
        ['#d7d700', '#ffff00'],
        ['#d700d7', '#ff00ff'],
        ['#00d700', '#00ff00'],
        ['#d70000', '#ff0000'],
        ['#d7d7d7', '#ffffff'],
        ['#0000d7', '#0000ff'],
        ['#00d7d7', '#00ffff'],
        ['#d7d700', '#ffff00']
      ];

      const tau = Math.PI * 2;
      const radius = 1;
      const midHeight = 0.5;
      const sinHalfStep = Math.sin(Math.PI / 10);
      const edgeSquared = 4 * radius * radius * sinHalfStep * sinHalfStep + 4 * midHeight * midHeight;
      const apexOffset = Math.sqrt(Math.max(1e-6, edgeSquared - radius * radius));
      const apexHeight = midHeight + apexOffset;

      const vertexCount = 12;
      const vertices = new Float32Array(vertexCount * 3);
      vertices[0] = 0;
      vertices[1] = apexHeight;
      vertices[2] = 0;
      for (let i = 0; i < 5; i++) {
        const angle = (i * tau) / 5;
        const offset = (1 + i) * 3;
        vertices[offset] = radius * Math.cos(angle);
        vertices[offset + 1] = midHeight;
        vertices[offset + 2] = radius * Math.sin(angle);
      }
      for (let i = 0; i < 5; i++) {
        const angle = (i * tau) / 5 + Math.PI / 5;
        const offset = (6 + i) * 3;
        vertices[offset] = radius * Math.cos(angle);
        vertices[offset + 1] = -midHeight;
        vertices[offset + 2] = radius * Math.sin(angle);
      }
      const bottomIndex = vertexCount - 1;
      vertices[bottomIndex * 3] = 0;
      vertices[bottomIndex * 3 + 1] = -apexHeight;
      vertices[bottomIndex * 3 + 2] = 0;

      const transformed = new Float32Array(vertices.length);
      const projected = new Float32Array(vertexCount * 2);
      const faceIndices = new Uint8Array([
        0, 1, 6, 2,
        0, 2, 7, 3,
        0, 3, 8, 4,
        0, 4, 9, 5,
        0, 5, 10, 1,
        11, 6, 2, 7,
        11, 7, 3, 8,
        11, 8, 4, 9,
        11, 9, 5, 10,
        11, 10, 1, 6
      ]);
      const faceCount = faceIndices.length / 4;
      const facePalettes = new Array(faceCount);
      for (let i = 0; i < faceCount; i++) {
        facePalettes[i] = zxFacePairs[i % zxFacePairs.length];
      }

      const depths = new Float32Array(faceCount);
      const faceBrightness = new Float32Array(faceCount);
      const faceOrder = new Uint8Array(faceCount);
      for (let i = 0; i < faceCount; i++) {
        faceOrder[i] = i;
      }

      const hexToRgb = (hex) => {
        const value = parseInt(hex.replace('#', ''), 16);
        return [
          (value >> 16) & 0xff,
          (value >> 8) & 0xff,
          value & 0xff
        ];
      };

      const rgbToHex = (r, g, b) => {
        const toComponent = (c) => Math.max(0, Math.min(255, Math.round(c))).toString(16).padStart(2, '0');
        return `#${toComponent(r)}${toComponent(g)}${toComponent(b)}`;
      };

      const adjustColor = (hex, amount) => {
        const [r, g, b] = hexToRgb(hex);
        const adjust = (channel) => amount >= 0
          ? channel + (255 - channel) * amount
          : channel * (1 + amount);
        return rgbToHex(adjust(r), adjust(g), adjust(b));
      };

      const lightVector = (() => {
        const x = 0.62;
        const y = 0.9;
        const z = 0.38;
        const invLen = 1 / Math.sqrt(x * x + y * y + z * z);
        return new Float32Array([x * invLen, y * invLen, z * invLen]);
      })();

      const reduceMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      const spinSpeed = reduceMotion ? 0.38 : 0.85;
      const tiltFrequency = reduceMotion ? 0.4 : 0.78;
      const tiltAmplitude = reduceMotion ? 0.22 : 0.36;
      const baseTilt = 0.55;
      const cameraDistance = 7.2;
      const scale = Math.min(width, height) * 0.354;
      let rafId = null;

      function sortFaces() {
        for (let i = 1; i < faceCount; i++) {
          const current = faceOrder[i];
          const depth = depths[current];
          let j = i - 1;
          while (j >= 0 && depths[faceOrder[j]] < depth) {
            faceOrder[j + 1] = faceOrder[j];
            j--;
          }
          faceOrder[j + 1] = current;
        }
      }

      function render(timeMs) {
        rafId = requestAnimationFrame(render);
        const t = timeMs * 0.001;
        const rotY = t * spinSpeed;
        const rotX = baseTilt + Math.sin(t * tiltFrequency) * tiltAmplitude;

        const sinY = Math.sin(rotY);
        const cosY = Math.cos(rotY);
        const sinX = Math.sin(rotX);
        const cosX = Math.cos(rotX);

        for (let i = 0; i < vertexCount; i++) {
          const vi = i * 3;
          const x = vertices[vi];
          const y = vertices[vi + 1];
          const z = vertices[vi + 2];

          const x1 = x * cosY - z * sinY;
          const z1 = x * sinY + z * cosY;
          const y1 = y * cosX - z1 * sinX;
          const z2 = y * sinX + z1 * cosX;

          transformed[vi] = x1;
          transformed[vi + 1] = y1;
          transformed[vi + 2] = z2;

          const depth = cameraDistance - z2;
          const perspective = cameraDistance / (depth > 1e-3 ? depth : 1e-3);
          const pi = i * 2;
          projected[pi] = halfWidth + x1 * perspective * scale;
          projected[pi + 1] = halfHeight - y1 * perspective * scale;
        }

        for (let face = 0; face < faceCount; face++) {
          const offset = face * 4;
          const i0 = faceIndices[offset];
          const i1 = faceIndices[offset + 1];
          const i2 = faceIndices[offset + 2];
          const i3 = faceIndices[offset + 3];

          const ax = transformed[i0 * 3];
          const ay = transformed[i0 * 3 + 1];
          const az = transformed[i0 * 3 + 2];
          const bx = transformed[i1 * 3];
          const by = transformed[i1 * 3 + 1];
          const bz = transformed[i1 * 3 + 2];
          const cx = transformed[i2 * 3];
          const cy = transformed[i2 * 3 + 1];
          const cz = transformed[i2 * 3 + 2];
          const dx = transformed[i3 * 3];
          const dy = transformed[i3 * 3 + 1];
          const dz = transformed[i3 * 3 + 2];

          const ux = bx - ax;
          const uy = by - ay;
          const uz = bz - az;
          const vx = cx - ax;
          const vy = cy - ay;
          const vz = cz - az;

          let nx = uy * vz - uz * vy;
          let ny = uz * vx - ux * vz;
          let nz = ux * vy - uy * vx;
          const normalLengthSq = nx * nx + ny * ny + nz * nz;
          const invLen = normalLengthSq > 1e-12 ? 1 / Math.sqrt(normalLengthSq) : 1;
          nx *= invLen;
          ny *= invLen;
          nz *= invLen;

          const brightness = Math.max(0, nx * lightVector[0] + ny * lightVector[1] + nz * lightVector[2]);

          depths[face] = (az + bz + cz + dz) * 0.25;
          faceBrightness[face] = brightness;
        }

        sortFaces();

        ctx.clearRect(0, 0, width, height);

        for (let orderIndex = 0; orderIndex < faceCount; orderIndex++) {
          const face = faceOrder[orderIndex];
          const offset = face * 4;
          const i0 = faceIndices[offset];
          const i1 = faceIndices[offset + 1];
          const i2 = faceIndices[offset + 2];
          const i3 = faceIndices[offset + 3];

          const p0x = projected[i0 * 2];
          const p0y = projected[i0 * 2 + 1];
          const p1x = projected[i1 * 2];
          const p1y = projected[i1 * 2 + 1];
          const p2x = projected[i2 * 2];
          const p2y = projected[i2 * 2 + 1];
          const p3x = projected[i3 * 2];
          const p3y = projected[i3 * 2 + 1];

          const centerX = (p0x + p1x + p2x + p3x) * 0.25;
          const centerY = (p0y + p1y + p2y + p3y) * 0.25;
          const radius = Math.max(
            Math.hypot(p0x - centerX, p0y - centerY),
            Math.hypot(p1x - centerX, p1y - centerY),
            Math.hypot(p2x - centerX, p2y - centerY),
            Math.hypot(p3x - centerX, p3y - centerY)
          );

          const palette = facePalettes[face];
          const brightness = faceBrightness[face];
          const highlightBoost = Math.min(1, 0.2 + brightness * 0.6);
          const shadowDip = Math.max(-1, -(0.5 + (1 - brightness) * 0.4));
          const highlight = adjustColor(palette[1], highlightBoost);
          const shadow = adjustColor(palette[0], shadowDip);

          const gradient = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, Math.max(radius, 1));
          gradient.addColorStop(0, highlight);
          gradient.addColorStop(1, shadow);

          ctx.beginPath();
          ctx.moveTo(p0x, p0y);
          ctx.lineTo(p1x, p1y);
          ctx.lineTo(p2x, p2y);
          ctx.lineTo(p3x, p3y);
          ctx.closePath();
          ctx.fillStyle = gradient;
          ctx.fill();

          const edgeColor = brightness > 0.55 ? adjustColor(palette[1], 0.25) : adjustColor(palette[0], -0.45);
          ctx.strokeStyle = edgeColor;
          ctx.stroke();
        }
      }

      rafId = requestAnimationFrame(render);
      stopLoaderAnimation = () => {
        if (rafId !== null) {
          cancelAnimationFrame(rafId);
          rafId = null;
        }
      };
    }
  }

  const fpsHolder = document.getElementById('fps');

  class FpsMonitor {
    constructor(container) {
      this.dom = document.createElement('div');
      this.dom.id = 'fps-monitor';

      const iconMarkup = `
        <span class="ui-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="presentation">
            <polygon points="12,2 22,7 22,17 12,22 2,17 2,7" opacity="0.35"></polygon>
            <polygon points="12,4.5 19.5,8.2 19.5,15.8 12,19.5 4.5,15.8 4.5,8.2" fill="currentColor"></polygon>
            <path d="M8 15h2.5V9H8zm5-6v8h-2.5V9zm2.5 0H18v10h-2.5z" fill="var(--accent-orange)"></path>
          </svg>
        </span>`;

      this.titleEl = document.createElement('div');
      this.titleEl.className = 'panel-title';
      this.titleEl.innerHTML = `${iconMarkup}<span class="label">Performance</span>`;
      this.dom.appendChild(this.titleEl);

      this.styles = getComputedStyle(document.documentElement);

      this.readoutEl = document.createElement('div');
      this.readoutEl.className = 'fps-readout';

      this.labelEl = document.createElement('div');
      this.labelEl.className = 'fps-label';
      this.labelEl.textContent = 'fps';

      this.valueEl = document.createElement('div');
      this.valueEl.className = 'fps-value';
      this.valueEl.textContent = '000';

      this.readoutEl.appendChild(this.labelEl);
      this.readoutEl.appendChild(this.valueEl);

      this.graphCanvas = document.createElement('canvas');
      this.graphCanvas.width = 160;
      this.graphCanvas.height = 60;
      this.graphCanvas.className = 'fps-graph';
      this.graphCanvas.setAttribute('aria-hidden', 'true');
      this.graphCtx = this.graphCanvas.getContext('2d');

      this.maxSamples = this.graphCanvas.width;
      this.samples = new Array(this.maxSamples).fill(0);
      this.referenceFps = 120;

      this.sampleWindow = 250;
      this.frameCount = 0;
      this.lastSample = performance.now();
      this.smoothed = 0;

      this.dom.appendChild(this.readoutEl);
      this.dom.appendChild(this.graphCanvas);
      this.drawGraph();
      container.appendChild(this.dom);
    }

    begin() {}

    end() {
      const now = performance.now();
      this.frameCount += 1;
      if (now - this.lastSample >= this.sampleWindow) {
        const elapsed = now - this.lastSample;
        const fps = (this.frameCount * 1000) / elapsed;
        this.frameCount = 0;
        this.lastSample = now;
        this.update(fps);
      }
    }

    update(rawFps) {
      const fps = Math.max(0, rawFps);
      this.smoothed = this.smoothed === 0 ? fps : (this.smoothed * 0.7 + fps * 0.3);
      const rounded = Math.max(0, Math.round(this.smoothed));
      this.valueEl.textContent = `${rounded.toString().padStart(3, '0')}`;
      this.samples.push(fps);
      if (this.samples.length > this.maxSamples) {
        this.samples.shift();
      }
      this.drawGraph();
    }

    drawGraph() {
      const ctx = this.graphCtx;
      const width = this.graphCanvas.width;
      const height = this.graphCanvas.height;
      ctx.clearRect(0, 0, width, height);

      const background = this.styles.getPropertyValue('--navy-900').trim() || '#020817';
      const gridColor = this.styles.getPropertyValue('--graph-grid').trim() || 'rgba(255, 255, 255, 0.18)';
      const fillColor = this.styles.getPropertyValue('--graph-fill').trim() || 'rgba(255, 139, 47, 0.18)';
      const lineColor = this.styles.getPropertyValue('--graph-line').trim() || '#ff8b2f';

      ctx.fillStyle = background;
      ctx.fillRect(0, 0, width, height);

      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      const gridLines = 4;
      for (let i = 1; i < gridLines; i++) {
        const y = Math.round((height / gridLines) * i) + 0.5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      const highestSample = this.samples.reduce((max, value) => Math.max(max, value), 0);
      const scaleMax = Math.max(this.referenceFps, highestSample, 30);
      const verticalPadding = 2;
      const usableHeight = height - verticalPadding * 2;

      ctx.beginPath();
      ctx.moveTo(0, height - verticalPadding);
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(width, height - verticalPadding);
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();

      ctx.beginPath();
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  const fpsMonitor = new FpsMonitor(fpsHolder);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setPixelRatio(1);
  const canvasWrap = document.getElementById('canvas-wrap');
  canvasWrap.appendChild(renderer.domElement);
  renderer.domElement.style.cursor = 'grab';
  renderer.domElement.style.touchAction = 'none';
  renderer.domElement.tabIndex = 0;
  renderer.domElement.setAttribute('aria-label', 'Interactive terrain viewport');
  renderer.domElement.style.background = renderModeCanvasBackgrounds.default;

  const retroEffect = createRetroEffect(renderer, retroPalettes.zx, retroModeConfigs.zx);

  const scene = new THREE.Scene();
  scene.fog = new THREE.Fog(renderModeFogColors.default, 380, 760);
  renderer.setClearColor(renderModeFogColors.default);
  scene.add(new THREE.AmbientLight(0x666666));
  const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
  sunLight.position.set(260, 220, -500);
  scene.add(sunLight);
  scene.add(sunLight.target);
  const sunLightOffset = new THREE.Vector3(260, 220, -500);
  const sunLightDesired = new THREE.Vector3();
  const sunLightTargetDesired = new THREE.Vector3();

  function createSkyDomeMaterial() {
    const uniforms = {
      horizonColor: { value: new THREE.Color('#0f1d30') },
      midColor: { value: new THREE.Color('#2e4f7d') },
      zenithColor: { value: new THREE.Color('#79b5ff') },
      glowColor: { value: new THREE.Color('#ffe6c2') },
      glowStrength: { value: 0.12 },
      time: { value: 0 }
    };

    const material = new THREE.ShaderMaterial({
      uniforms,
      vertexShader: `
        varying vec3 vWorldPosition;
        void main() {
          vec4 worldPosition = modelMatrix * vec4(position, 1.0);
          vWorldPosition = worldPosition.xyz;
          gl_Position = projectionMatrix * viewMatrix * worldPosition;
        }
      `,
      fragmentShader: `
        varying vec3 vWorldPosition;
        uniform vec3 horizonColor;
        uniform vec3 midColor;
        uniform vec3 zenithColor;
        uniform vec3 glowColor;
        uniform float glowStrength;
        uniform float time;

        void main() {
          vec3 worldDir = normalize(vWorldPosition);
          float vertical = clamp(worldDir.y * 0.5 + 0.5, 0.0, 1.0);
          float midBlend = smoothstep(0.15, 0.65, vertical);
          vec3 base = mix(horizonColor, midColor, midBlend);
          base = mix(base, zenithColor, smoothstep(0.45, 1.0, vertical));

          float glow = pow(1.0 - vertical, 1.8);
          float pulse = 0.65 + 0.35 * sin(time * 0.12);
          vec3 color = base + glow * glowStrength * pulse * glowColor;
          gl_FragColor = vec4(clamp(color, 0.0, 1.0), 1.0);
        }
      `,
      side: THREE.BackSide,
      depthWrite: false,
      fog: false
    });

    return { material, uniforms };
  }

  function createCloudTexture() {
    const pixelSize = 4;
    const pixelWidth = 64;
    const pixelHeight = 32;
    const canvas = document.createElement('canvas');
    canvas.width = pixelWidth * pixelSize;
    canvas.height = pixelHeight * pixelSize;
    const ctx = canvas.getContext('2d');

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.imageSmoothingEnabled = false;

    const centerX = pixelWidth / 2;
    const centerY = pixelHeight * 0.55;

    const random = (x, y) => {
      const s = Math.sin(x * 127.1 + y * 311.7) * 43758.5453;
      return s - Math.floor(s);
    };

    for (let py = 0; py < pixelHeight; py++) {
      for (let px = 0; px < pixelWidth; px++) {
        const nx = (px - centerX) / (pixelWidth * 0.5);
        const ny = (py - centerY) / (pixelHeight * 0.45);
        const distance = Math.sqrt(nx * nx * 0.75 + ny * ny);
        const falloff = Math.max(0, 1 - distance);
        if (falloff <= 0.05) continue;

        const noise =
          Math.sin(px * 0.45) * 0.05 +
          Math.cos(py * 0.55) * 0.04 +
          Math.sin((px + py) * 0.12) * 0.03 +
          random(px, py) * 0.08;

        const value = falloff + noise - 0.08;
        if (value <= 0) continue;

        const highlight = Math.max(0, 1 - py / pixelHeight);
        const shade = 0.78 + falloff * 0.22 + highlight * 0.18;
        const blueTint = 0.88 + highlight * 0.08;
        const alpha = Math.min(0.95, 0.32 + falloff * 0.6 + highlight * 0.18);

        ctx.fillStyle = `rgba(${Math.floor(shade * 255)}, ${Math.floor(shade * 255)}, ${Math.floor(blueTint * 255)}, ${alpha})`;
        ctx.fillRect(px * pixelSize, py * pixelSize, pixelSize, pixelSize);
      }
    }

    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = 'rgba(255, 255, 255, 0.08)';
    for (let i = 0; i < 14; i++) {
      const px = Math.floor(random(i, i * 1.7) * pixelWidth);
      const py = Math.floor(random(i * 2.1, i * 3.1) * pixelHeight * 0.6);
      ctx.fillRect(px * pixelSize, py * pixelSize, pixelSize * 2, pixelSize);
    }
    ctx.globalCompositeOperation = 'source-over';

    const undersideGradient = ctx.createLinearGradient(0, canvas.height * 0.55, 0, canvas.height);
    undersideGradient.addColorStop(0, 'rgba(170, 200, 255, 0.12)');
    undersideGradient.addColorStop(1, 'rgba(110, 140, 200, 0.35)');
    ctx.fillStyle = undersideGradient;
    ctx.fillRect(0, canvas.height * 0.55, canvas.width, canvas.height * 0.45);

    const texture = new THREE.CanvasTexture(canvas);
    texture.center.set(0.5, 0.5);
    texture.generateMipmaps = false;
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.needsUpdate = true;
    return texture;
  }

  function createBlackHoleCoreTexture() {
    const size = 512;
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d');

    const gradient = ctx.createRadialGradient(size / 2, size / 2, size * 0.12, size / 2, size / 2, size * 0.5);
    gradient.addColorStop(0, 'rgba(0, 0, 0, 1)');
    gradient.addColorStop(0.32, 'rgba(2, 4, 10, 1)');
    gradient.addColorStop(0.5, 'rgba(18, 12, 28, 0.95)');
    gradient.addColorStop(0.7, 'rgba(22, 14, 40, 0.8)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    for (let i = 0; i < 28; i++) {
      const radius = size * (0.2 + i * 0.01 + Math.random() * 0.015);
      ctx.beginPath();
      ctx.arc(size / 2, size / 2, radius, 0, Math.PI * 2);
      const opacity = 0.32 - i * 0.008;
      ctx.strokeStyle = `rgba(122, 72, 160, ${Math.max(0, opacity)})`;
      ctx.lineWidth = 2 + i * 0.5;
      ctx.stroke();
    }

    const texture = new THREE.CanvasTexture(canvas);
    texture.center.set(0.5, 0.5);
    texture.generateMipmaps = false;
    texture.magFilter = THREE.LinearFilter;
    texture.minFilter = THREE.LinearFilter;
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.needsUpdate = true;
    return texture;
  }

  function createBlackHoleHaloTexture() {
    const size = 512;
    const canvas = document.createElement('canvas');
    canvas.width = canvas.height = size;
    const ctx = canvas.getContext('2d');

    const gradient = ctx.createRadialGradient(size / 2, size / 2, size * 0.18, size / 2, size / 2, size * 0.5);
    gradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
    gradient.addColorStop(0.35, 'rgba(120, 90, 255, 0.08)');
    gradient.addColorStop(0.55, 'rgba(180, 120, 255, 0.35)');
    gradient.addColorStop(0.78, 'rgba(255, 170, 120, 0.28)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, size, size);

    const texture = new THREE.CanvasTexture(canvas);
    texture.center.set(0.5, 0.5);
    texture.generateMipmaps = false;
    texture.magFilter = THREE.LinearFilter;
    texture.minFilter = THREE.LinearFilter;
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.needsUpdate = true;
    return texture;
  }

  function createAccretionDiskTexture() {
    const size = 1024;
    const canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext('2d');

    ctx.translate(size / 2, size / 2);
    ctx.rotate(-Math.PI / 8);

    const radialGradient = ctx.createRadialGradient(0, 0, size * 0.12, 0, 0, size * 0.48);
    radialGradient.addColorStop(0, 'rgba(0, 0, 0, 0)');
    radialGradient.addColorStop(0.35, 'rgba(80, 30, 120, 0.6)');
    radialGradient.addColorStop(0.55, 'rgba(190, 90, 255, 0.55)');
    radialGradient.addColorStop(0.75, 'rgba(255, 180, 120, 0.4)');
    radialGradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.fillStyle = radialGradient;
    ctx.fillRect(-size / 2, -size / 2, size, size);

    const arcCount = 26;
    ctx.lineWidth = 8;
    ctx.strokeStyle = 'rgba(255, 220, 180, 0.28)';
    for (let i = 0; i < arcCount; i++) {
      const radius = size * (0.18 + i * 0.009 + Math.random() * 0.004);
      const start = Math.random() * Math.PI * 2;
      const length = Math.PI * (0.45 + Math.random() * 0.25);
      ctx.globalAlpha = 0.3 + Math.random() * 0.4;
      ctx.beginPath();
      ctx.arc(0, 0, radius, start, start + length);
      ctx.stroke();
    }

    const innerGlow = ctx.createRadialGradient(0, 0, size * 0.08, 0, 0, size * 0.28);
    innerGlow.addColorStop(0, 'rgba(255, 255, 255, 0.45)');
    innerGlow.addColorStop(0.6, 'rgba(255, 150, 120, 0.08)');
    innerGlow.addColorStop(1, 'rgba(0, 0, 0, 0)');
    ctx.globalAlpha = 1;
    ctx.fillStyle = innerGlow;
    ctx.beginPath();
    ctx.arc(0, 0, size * 0.35, 0, Math.PI * 2);
    ctx.fill();

    const texture = new THREE.CanvasTexture(canvas);
    texture.center.set(0.5, 0.5);
    texture.generateMipmaps = false;
    texture.magFilter = THREE.LinearFilter;
    texture.minFilter = THREE.LinearFilter;
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.needsUpdate = true;
    return texture;
  }

  const PETSCII_CHAR_ROM_BASE64 = `
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAQAAAAAAK8PCgAAAAAAwiRqAAAAAGBmUHAAAAAAJEJCJAAAAAAAZGYAAAAAAAAA
AEAAAAAAAAECTAAAAABgpORuAAAAAGYiQuYAAAAABm7yJgAAAABmguRkAAAAAGaqYmYAAAAAAEQABAAAAAAgTk4gAAAAAMYiJsQAAAAAYKaGZgAAAAAAhujm
AAAAAAAmbmYAAAAAACZqQgAAAAAAgOSmAAAAAAAILioAAAAAAEBPaQAAAAAAZqqmAAAAAABmqsIAAAAAAGaGjgAAAAAA4EomAAAAAAABr2YAAAAAAIBq4gAA
AAAG5CTmAAAAACZCQuYAAAAAAGRvRAAAAAAABv4KAAAAAGao6OYAAAAARqis7gAAAABmiMqGAAAAAAak5KYAAAAAYC4sagAAAAABj4npAAAAAAbq6qYAAAAA
ZqrKggAAAABmqOKmAAAAAOBKSkYAAAAAAamvbQAAAAAAamakAAAAAOQkT+QAAAAAhESERAAAAABVqlWqAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAADAwMDAAAAAAPAPDwAAAAAAgICAgAAAAAoVGhUQAAAAAKBapVAAAAABQUFxQAAAAABAQ3MAAAAAAAAMBPAAAAAAQEf0AAAAAABAT8RAAA
AACIiIiIAAAAAD8wMDAAAAAA8PAADwAAAAAQIMyMAAAAADQ0DAAAAAAAzMwDAwAAAAAABv4KAAAAAGao6OYAAAAARqis7gAAAABmiMqGAAAAAAak5KYAAAAA
YC4sagAAAAABj4npAAAAAAbq6qYAAAAAZqrKggAAAABmqOKmAAAAAOBKSkYAAAAAAamvbQAAAAAAamakAAAAAOQkT+QAAAAAhESERAAAAABVqlWqAAAAAAwM
DAwAAAAADwDw8AAAAAAICAgIAAAAAKFRoVEAAAAACgWqVQAAAAAUFBcUAAAAAAQENzAAAAAAAADATwAAAAAEBH9AAAAAAAQE/EQAAAAAiIiIiAAAAAA/MDAw
AAAAAPDwAA8AAAAAECDMjAAAAAA0NAwAAAAAAMXKBQoAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAEAAAAAACvDwoAAAAA
AMIkagAAAABgZlBwAAAAACRCQiQAAAAAAGRmAAAAAAAAAABAAAAAAAABAkwAAAAAYKTkbgAAAABmIkLmAAAAAAZu8iYAAAAAZoLkZAAAAABmqmJmAAAAAABE
AAQAAAAAIE5OIAAAAADGIibEAAAAAGCmjmoAAAAAZqjo5gAAAABGqKzuAAAAAGaIyoYAAAAABqTkpgAAAABgLixqAAAAAAGPiekAAAAABurqpgAAAABmqsqC
AAAAAGao4qYAAAAA4EpKRgAAAAABqa9tAAAAAABqZqQAAAAA5iRE5gAAAAAmQkLmAAAAAABkb0QAAAAAAAb/BgAAAABAQE9AAAAAAAD/AAAAAAAABAT0BAAA
AAAgICwkAAAAAERkOAAAAAAAiIyG8wAAAAAfKEiIAAAAAPAeHhYAAAAABg8G8AAAAACAgIOEAAAAAJDuarYAAAAAQqJCYgAAAAAEZG8EAAAAAIREhEQAAAAA
DxfjYQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAwMDAwAAAAADwDw8AAAAAAICAgIAAAAAKFRoVEAAAAADw6sWAAAAAAUFBcU
AAAAAAQENzAAAAAAAADATwAAAAAEBH9AAAAAAAQE/EQAAAAAiIiIiAAAAAA/MDAwAAAAAPDwAA8AAAAAEBAc/AAAAAA0NAwAAAAAAMzMAwMAAAAAAAb/BgAA
AABAQE9AAAAAAAD/AAAAAAAABAT0BAAAAAAgICwkAAAAAERkOAAAAAAAiIyG8wAAAAAfKEiIAAAAAPAeHhYAAAAABg8G8AAAAACAgIOEAAAAAJDuarYAAAAA
QqJCYgAAAAAEZG8EAAAAAIREhEQAAAAADxfjYQAAAAAMDAwMAAAAAA8A8PAAAAAACAgICAAAAAChUaFRAAAAAA8OrFgAAAAAFBQXFAAAAAAEBDcwAAAAAAAA
wE8AAAAABAR/QAAAAAAEBPxEAAAAAIiIiIgAAAAAPzAwMAAAAADw8AAPAAAAABAQHPwAAAAANDQMAAAAAADAwQ4GAAA=`;

  function decodeBase64ToUint8Array(base64) {
    if (typeof atob === 'function') {
      const binary = atob(base64.replace(/\s+/g, ''));
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    }
    if (typeof Buffer !== 'undefined') {
      const buf = Buffer.from(base64, 'base64');
      return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
    }
    throw new Error('Base64 decoding not supported in this environment.');
  }

  function createPetsciiAtlas() {
    const rom = decodeBase64ToUint8Array(PETSCII_CHAR_ROM_BASE64);
    const charSize = 8;
    const charStride = charSize;
    const levels = Math.floor(rom.length / charStride);
    const textureHeight = charSize * levels;
    const textureData = new Uint8Array(charSize * textureHeight);
    let offset = 0;
    for (let charIndex = 0; charIndex < levels; charIndex++) {
      const charOffset = charIndex * charStride;
      for (let row = 0; row < charSize; row++) {
        const rowByte = rom[charOffset + row];
        for (let col = 0; col < charSize; col++) {
          const bit = (rowByte >> (7 - col)) & 1;
          textureData[offset++] = bit ? 255 : 0;
        }
      }
    }
    const texture = new THREE.DataTexture(textureData, charSize, textureHeight, THREE.LuminanceFormat);
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    texture.generateMipmaps = false;
    texture.needsUpdate = true;
    if ('colorSpace' in texture && 'NoColorSpace' in THREE) {
      texture.colorSpace = THREE.NoColorSpace;
    }
    return { texture, charSize, levels, rom };
  }

  function createRetroEffect(renderer, initialPalette = [], initialSettings = {}) {
    const paletteVectors = new Array(16).fill(null).map(() => new THREE.Vector3());
    const paletteColor = new THREE.Color();

    function applyPalette(palette) {
      const source = Array.isArray(palette) && palette.length ? palette : [0x000000];
      for (let i = 0; i < paletteVectors.length; i++) {
        const hex = source[i % source.length];
        paletteColor.set(hex);
        paletteVectors[i].set(paletteColor.r, paletteColor.g, paletteColor.b);
      }
    }

    applyPalette(initialPalette);

    const petsciiAtlas = createPetsciiAtlas();
    const petsciiCharRom = petsciiAtlas.rom;
    const petsciiCharStride = 8;
    const petsciiCharCount = Math.floor(petsciiCharRom.length / petsciiCharStride);
    const bitCountLut = new Uint8Array(256);
    for (let i = 0; i < bitCountLut.length; i++) {
      let count = 0;
      let value = i;
      while (value) {
        value &= value - 1;
        count++;
      }
      bitCountLut[i] = count;
    }

    const petsciiState = {
      pixelBuffer: null,
      luminances: null,
      rowBits: null,
      charBuffer: null,
      charTexture: null,
      blockWidth: 0,
      blockHeight: 0
    };

    function ensurePixelBuffer(width, height) {
      const required = Math.max(1, Math.floor(width) * Math.floor(height) * 4);
      if (!petsciiState.pixelBuffer || petsciiState.pixelBuffer.length !== required) {
        petsciiState.pixelBuffer = new Uint8Array(required);
      }
    }

    function ensurePetsciiResources(blockWidth, blockHeight, blockSize) {
      const safeBlockWidth = Math.max(1, Math.floor(blockWidth));
      const safeBlockHeight = Math.max(1, Math.floor(blockHeight));
      const blockCount = safeBlockWidth * safeBlockHeight;
      const requiredDataLength = blockCount * 2;
      let replacedData = false;
      if (!petsciiState.charBuffer || petsciiState.charBuffer.length !== requiredDataLength) {
        petsciiState.charBuffer = new Uint8Array(requiredDataLength);
        replacedData = true;
      }
      const needsTextureResize = !petsciiState.charTexture ||
        petsciiState.charTexture.image.width !== safeBlockWidth ||
        petsciiState.charTexture.image.height !== safeBlockHeight;
      if (needsTextureResize) {
        petsciiState.charTexture = new THREE.DataTexture(
          petsciiState.charBuffer,
          safeBlockWidth,
          safeBlockHeight,
          THREE.LuminanceAlphaFormat
        );
        petsciiState.charTexture.magFilter = THREE.NearestFilter;
        petsciiState.charTexture.minFilter = THREE.NearestFilter;
        petsciiState.charTexture.wrapS = THREE.ClampToEdgeWrapping;
        petsciiState.charTexture.wrapT = THREE.ClampToEdgeWrapping;
        petsciiState.charTexture.generateMipmaps = false;
        petsciiState.charTexture.needsUpdate = true;
        if ('colorSpace' in petsciiState.charTexture && 'NoColorSpace' in THREE) {
          petsciiState.charTexture.colorSpace = THREE.NoColorSpace;
        }
      } else if (replacedData && petsciiState.charTexture) {
        petsciiState.charTexture.image.data = petsciiState.charBuffer;
        petsciiState.charTexture.needsUpdate = true;
      }
      petsciiState.blockWidth = safeBlockWidth;
      petsciiState.blockHeight = safeBlockHeight;
      const luminanceSize = Math.max(1, blockSize * blockSize);
      if (!petsciiState.luminances || petsciiState.luminances.length !== luminanceSize) {
        petsciiState.luminances = new Float32Array(luminanceSize);
      }
      if (!petsciiState.rowBits || petsciiState.rowBits.length !== blockSize) {
        petsciiState.rowBits = new Uint8Array(blockSize);
      }
    }

    function updatePetsciiAttributes(blockWidth, blockHeight, blockSize) {
      if (!blockWidth || !blockHeight) {
        return;
      }
      ensurePixelBuffer(targetWidth, targetHeight);
      ensurePetsciiResources(blockWidth, blockHeight, blockSize);

      renderer.readRenderTargetPixels(
        sceneTarget,
        0,
        0,
        Math.floor(targetWidth),
        Math.floor(targetHeight),
        petsciiState.pixelBuffer
      );

      const pixelData = petsciiState.pixelBuffer;
      const luminances = petsciiState.luminances;
      const rowBits = petsciiState.rowBits;
      const charBuffer = petsciiState.charBuffer;
      const width = Math.floor(targetWidth);
      const height = Math.floor(targetHeight);
      const maxIndex = blockSize * blockSize;

      for (let by = 0; by < blockHeight; by++) {
        const baseY = by * blockSize;
        for (let bx = 0; bx < blockWidth; bx++) {
          const baseX = bx * blockSize;
          let lumIndex = 0;
          let lumSum = 0;
          let minLum = Infinity;
          let maxLum = -Infinity;

          for (let py = 0; py < blockSize; py++) {
            const pixelY = baseY + py;
            const clampedY = Math.min(pixelY, height - 1);
            const rowOffset = clampedY * width;
            for (let px = 0; px < blockSize; px++) {
              const pixelX = baseX + px;
              const clampedX = Math.min(pixelX, width - 1);
              const idx = (rowOffset + clampedX) * 4;
              const r = pixelData[idx];
              const g = pixelData[idx + 1];
              const b = pixelData[idx + 2];
              const lum = 0.299 * r + 0.587 * g + 0.114 * b;
              luminances[lumIndex++] = lum;
              lumSum += lum;
              if (lum < minLum) minLum = lum;
              if (lum > maxLum) maxLum = lum;
            }
          }

          const pixelTotal = Math.max(1, Math.min(maxIndex, lumIndex));
          let threshold = lumSum / pixelTotal;
          if (maxLum - minLum < 1e-3) {
            threshold = minLum;
          }

          lumIndex = 0;
          for (let py = 0; py < blockSize; py++) {
            let rowByte = 0;
            for (let px = 0; px < blockSize; px++) {
              const lum = luminances[lumIndex++];
              if (lum >= threshold) {
                rowByte |= 1 << (7 - px);
              }
            }
            rowBits[py] = rowByte & 0xff;
          }

          let bestChar = 0;
          let bestScore = Infinity;
          let bestInvert = 0;

          for (let charIndex = 0; charIndex < petsciiCharCount; charIndex++) {
            const charOffset = charIndex * petsciiCharStride;
            let diff = 0;
            let diffInverted = 0;
            for (let row = 0; row < blockSize; row++) {
              const blockRow = rowBits[row];
              const charRow = petsciiCharRom[charOffset + row];
              diff += bitCountLut[blockRow ^ charRow];
              diffInverted += bitCountLut[((~blockRow) & 0xff) ^ charRow];
              if (diff >= bestScore && diffInverted >= bestScore) {
                break;
              }
            }
            if (diff < bestScore) {
              bestScore = diff;
              bestChar = charIndex;
              bestInvert = 0;
            }
            if (diffInverted < bestScore) {
              bestScore = diffInverted;
              bestChar = charIndex;
              bestInvert = 1;
            }
          }

          const dataIndex = (by * blockWidth + bx) * 2;
          charBuffer[dataIndex] = bestChar & 0xff;
          charBuffer[dataIndex + 1] = bestInvert ? 255 : 0;
        }
      }

      if (petsciiState.charTexture) {
        petsciiState.charTexture.needsUpdate = true;
      }
    }

    function updateAttributeTextureBinding(attributeValue) {
      if (attributeValue > 1.5 && petsciiState.charTexture) {
        finalUniforms.attributeTexture.value = petsciiState.charTexture;
      } else {
        finalUniforms.attributeTexture.value = attributeTarget.texture;
      }
    }

    const resolution = new THREE.Vector2(1, 1);
    const blockCount = new THREE.Vector2(1, 1);
    let targetWidth = 16;
    let targetHeight = 16;
    let currentBlockSize = Math.max(1, initialSettings.blockSize || 8);
    const blockPixelSizeUniform = { value: currentBlockSize };
    const attributeModeUniform = {
      value: initialSettings.attributeMode === 'attribute'
        ? 1
        : initialSettings.attributeMode === 'petscii'
          ? 2
          : 0
    };

    const sceneTarget = new THREE.WebGLRenderTarget(16, 16, {
      minFilter: THREE.LinearFilter,
      magFilter: THREE.LinearFilter,
      depthBuffer: true,
      stencilBuffer: false
    });
    sceneTarget.texture.generateMipmaps = false;
    if ('colorSpace' in sceneTarget.texture && renderer.outputColorSpace) {
      sceneTarget.texture.colorSpace = renderer.outputColorSpace;
    } else if ('encoding' in sceneTarget.texture && renderer.outputEncoding !== undefined) {
      sceneTarget.texture.encoding = renderer.outputEncoding;
    }

    const attributeTarget = new THREE.WebGLRenderTarget(2, 2, {
      minFilter: THREE.NearestFilter,
      magFilter: THREE.NearestFilter,
      depthBuffer: false,
      stencilBuffer: false,
      type: THREE.UnsignedByteType
    });
    attributeTarget.texture.generateMipmaps = false;

    const quadGeometry = new THREE.PlaneGeometry(2, 2);
    const orthoCamera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    const fullscreenVertexShader = `
      varying vec2 vUv;
      void main() {
        vUv = uv;
        gl_Position = vec4(position.xy, 0.0, 1.0);
      }
    `;

    const attributeUniforms = {
      sceneTexture: { value: null },
      resolution: { value: resolution },
      blockCount: { value: blockCount },
      palette: { value: paletteVectors },
      blockPixelSize: blockPixelSizeUniform
    };

    const attributeMaterial = new THREE.ShaderMaterial({
      uniforms: attributeUniforms,
      vertexShader: fullscreenVertexShader,
      fragmentShader: `
        precision highp float;
        uniform sampler2D sceneTexture;
        uniform vec2 resolution;
        uniform vec2 blockCount;
        uniform vec3 palette[16];
        uniform float blockPixelSize;
        varying vec2 vUv;

        const float SAMPLE_GRID = 4.0;

        float colorDistance(vec3 a, vec3 b) {
          vec3 d = a - b;
          return dot(d, d);
        }

        int nearestPaletteIndex(vec3 color) {
          float bestDistance = 1e9;
          int bestIndex = 0;
          for (int i = 0; i < 16; i++) {
            vec3 paletteColor = palette[i];
            float dist = colorDistance(color, paletteColor);
            if (dist < bestDistance) {
              bestDistance = dist;
              bestIndex = i;
            }
          }
          return bestIndex;
        }

        vec2 clampUv(vec2 pixel) {
          vec2 clamped = clamp(pixel, vec2(0.0), resolution - vec2(1.0));
          return (clamped + 0.5) / resolution;
        }

        void main() {
          vec2 blockIndex = floor(vUv * blockCount);
          vec2 blockBase = blockIndex * blockPixelSize;
          float sampleStep = blockPixelSize / SAMPLE_GRID;
          vec3 averageColor = vec3(0.0);
          float totalSamples = SAMPLE_GRID * SAMPLE_GRID;

          for (int y = 0; y < 4; y++) {
            for (int x = 0; x < 4; x++) {
              vec2 offset = (vec2(float(x), float(y)) + 0.5) * sampleStep;
              vec2 samplePixel = blockBase + offset;
              vec2 sampleUv = clampUv(samplePixel);
              averageColor += texture2D(sceneTexture, sampleUv).rgb;
            }
          }
          averageColor /= totalSamples;

          int paperIndex = nearestPaletteIndex(averageColor);
          vec3 paperColor = palette[paperIndex];

          float maxDistance = -1.0;
          vec3 furthestColor = paperColor;

          for (int y = 0; y < 4; y++) {
            for (int x = 0; x < 4; x++) {
              vec2 offset = (vec2(float(x), float(y)) + 0.5) * sampleStep;
              vec2 samplePixel = blockBase + offset;
              vec2 sampleUv = clampUv(samplePixel);
              vec3 sampleColor = texture2D(sceneTexture, sampleUv).rgb;
              float dist = colorDistance(sampleColor, paperColor);
              if (dist > maxDistance) {
                maxDistance = dist;
                furthestColor = sampleColor;
              }
            }
          }

          int inkIndex = nearestPaletteIndex(furthestColor);
          if (maxDistance < 0.003) {
            inkIndex = paperIndex;
          }

          gl_FragColor = vec4(float(paperIndex) / 255.0, float(inkIndex) / 255.0, 0.0, 1.0);
        }
      `,
      depthTest: false,
      depthWrite: false,
      transparent: false,
      blending: THREE.NoBlending
    });

    const attributeScene = new THREE.Scene();
    attributeScene.add(new THREE.Mesh(quadGeometry, attributeMaterial));

    const finalUniforms = {
      sceneTexture: { value: null },
      attributeTexture: { value: null },
      resolution: { value: resolution },
      blockCount: { value: blockCount },
      palette: { value: paletteVectors },
      blockPixelSize: blockPixelSizeUniform,
      attributeMode: attributeModeUniform,
      patternTexture: { value: petsciiAtlas.texture },
      patternCharSize: { value: petsciiAtlas.charSize },
      patternCount: { value: petsciiAtlas.levels }
    };

    const finalMaterial = new THREE.ShaderMaterial({
      uniforms: finalUniforms,
      vertexShader: fullscreenVertexShader,
      fragmentShader: `
        precision highp float;
        uniform sampler2D sceneTexture;
        uniform sampler2D attributeTexture;
        uniform sampler2D patternTexture;
        uniform vec2 resolution;
        uniform vec2 blockCount;
        uniform vec3 palette[16];
        uniform float blockPixelSize;
        uniform float attributeMode;
        uniform float patternCharSize;
        uniform float patternCount;
        varying vec2 vUv;

        float colorDistance(vec3 a, vec3 b) {
          vec3 d = a - b;
          return dot(d, d);
        }

        int decodeIndex(float value) {
          return clamp(int(floor(value * 255.0 + 0.5)), 0, 15);
        }

        vec3 paletteColor(int index) {
          return palette[index];
        }

        int nearestPaletteIndex(vec3 color) {
          float bestDistance = 1e9;
          int bestIndex = 0;
          for (int i = 0; i < 16; i++) {
            vec3 paletteColor = palette[i];
            float dist = colorDistance(color, paletteColor);
            if (dist < bestDistance) {
              bestDistance = dist;
              bestIndex = i;
            }
          }
          return bestIndex;
        }

        float bayerDither(vec2 coord) {
          vec2 pos = mod(coord, 4.0);
          int x = int(pos.x);
          int y = int(pos.y);
          int index = x + y * 4;
          const float bayer[16] = float[16](
            0.0, 8.0, 2.0, 10.0,
            12.0, 4.0, 14.0, 6.0,
            3.0, 11.0, 1.0, 9.0,
            15.0, 7.0, 13.0, 5.0
          );
          return (bayer[index] + 0.5) / 16.0;
        }

        float samplePetsciiPattern(float patternIndex, vec2 pixelCoord) {
          float charSize = max(patternCharSize, 1.0);
          vec2 local = mod(pixelCoord, charSize);
          float u = (local.x + 0.5) / charSize;
          float v = (local.y + 0.5 + patternIndex * charSize) / (charSize * max(patternCount, 1.0));
          return texture2D(patternTexture, vec2(u, v)).r;
        }

        void main() {
          vec3 sceneColor = texture2D(sceneTexture, vUv).rgb;

          if (attributeMode < 0.5) {
            int paletteIndex = nearestPaletteIndex(sceneColor);
            vec3 quantizedColor = paletteColor(paletteIndex);
            gl_FragColor = vec4(quantizedColor, 1.0);
            return;
          }

          vec2 pixelCoord = vUv * resolution;
          vec2 blockCoord = floor(pixelCoord / max(blockPixelSize, 1.0));
          vec2 maxBlock = max(blockCount - vec2(1.0), vec2(0.0));
          blockCoord = clamp(blockCoord, vec2(0.0), maxBlock);
          vec2 attributeUv = (blockCoord + 0.5) / blockCount;

          vec4 attributeData = texture2D(attributeTexture, attributeUv);

          if (attributeMode > 1.5) {
            float charIndex = floor(attributeData.r * 255.0 + 0.5);
            float invertFlag = step(0.5, attributeData.a);
            vec3 paperColor = paletteColor(0);
            vec3 inkColor = paletteColor(1);
            float glyph = samplePetsciiPattern(charIndex, pixelCoord);
            if (invertFlag > 0.5) {
              glyph = 1.0 - glyph;
            }
            vec3 finalColor = mix(paperColor, inkColor, step(0.5, glyph));
            gl_FragColor = vec4(finalColor, 1.0);
            return;
          }
          int paperIndex = decodeIndex(attributeData.r);
          int inkIndex = decodeIndex(attributeData.g);
          vec3 paperColor = paletteColor(paperIndex);
          vec3 inkColor = paletteColor(inkIndex);

          float paperDist = colorDistance(sceneColor, paperColor);
          float inkDist = colorDistance(sceneColor, inkColor);
          vec3 finalColor = paperColor;

          if (inkIndex != paperIndex) {
            float totalDist = max(paperDist + inkDist, 1e-5);
            float paperWeight = clamp(inkDist / totalDist, 0.0, 1.0);
            float inkWeight = 1.0 - paperWeight;
            vec3 luminanceWeights = vec3(0.299, 0.587, 0.114);
            float luminancePaper = dot(paperColor, luminanceWeights);
            float luminanceInk = dot(inkColor, luminanceWeights);
            float luminanceScene = dot(sceneColor, luminanceWeights);
            float luminanceDiff = luminanceInk - luminancePaper;
            float gradientWeight = inkWeight;
            if (abs(luminanceDiff) > 1e-5) {
              float grad = clamp((luminanceScene - luminancePaper) / luminanceDiff, 0.0, 1.0);
              if (luminanceDiff < 0.0) {
                grad = 1.0 - grad;
              }
              gradientWeight = mix(inkWeight, grad, 0.5);
            }
            gradientWeight = clamp(gradientWeight, 0.0, 1.0);
            float pattern = bayerDither(pixelCoord);
            if (gradientWeight > pattern) {
              finalColor = inkColor;
            }
          }

          gl_FragColor = vec4(finalColor, 1.0);
        }
      `,
      depthTest: false,
      depthWrite: false,
      transparent: false,
      blending: THREE.NoBlending
    });

    const finalScene = new THREE.Scene();
    finalScene.add(new THREE.Mesh(quadGeometry.clone(), finalMaterial));

    return {
      enabled: false,
      setEnabled(value) {
        this.enabled = Boolean(value);
      },
      setConfig(config = {}) {
        if (typeof config.blockSize === 'number' && config.blockSize > 0) {
          currentBlockSize = config.blockSize;
        }
        if (typeof config.attributeMode === 'string') {
          if (config.attributeMode === 'attribute') {
            attributeModeUniform.value = 1;
          } else if (config.attributeMode === 'petscii') {
            attributeModeUniform.value = 2;
          } else {
            attributeModeUniform.value = 0;
          }
        } else if (typeof config.attributeMode === 'number') {
          attributeModeUniform.value = config.attributeMode;
        }
        updateAttributeTextureBinding(attributeModeUniform.value);
        this.setSize(targetWidth, targetHeight);
      },
      setPalette(palette) {
        applyPalette(palette);
        attributeMaterial.needsUpdate = true;
        finalMaterial.needsUpdate = true;
      },
      setSize(width, height) {
        const safeWidth = Math.max(1, Math.floor(width));
        const safeHeight = Math.max(1, Math.floor(height));
        targetWidth = safeWidth;
        targetHeight = safeHeight;
        sceneTarget.setSize(safeWidth, safeHeight);
        const blockSize = Math.max(1, currentBlockSize);
        blockPixelSizeUniform.value = blockSize;
        const attributeValue = attributeModeUniform.value;
        const blockWidth = Math.max(1, Math.floor(safeWidth / blockSize));
        const blockHeight = Math.max(1, Math.floor(safeHeight / blockSize));
        const useAttribute = attributeValue > 0.5 && attributeValue < 1.5;
        const usePetscii = attributeValue > 1.5;
        attributeTarget.setSize(useAttribute ? blockWidth : 1, useAttribute ? blockHeight : 1);
        if (usePetscii) {
          ensurePetsciiResources(blockWidth, blockHeight, blockSize);
        }
        updateAttributeTextureBinding(attributeValue);
        resolution.set(safeWidth, safeHeight);
        blockCount.set(blockWidth, blockHeight);
      },
      render(scene, camera) {
        renderer.setRenderTarget(sceneTarget);
        renderer.render(scene, camera);

        const attributeValue = attributeModeUniform.value;
        const blockSize = Math.max(1, Math.floor(blockPixelSizeUniform.value));
        const blockWidth = Math.max(1, Math.floor(targetWidth / blockSize));
        const blockHeight = Math.max(1, Math.floor(targetHeight / blockSize));

        if (attributeValue > 0.5 && attributeValue < 1.5) {
          attributeUniforms.sceneTexture.value = sceneTarget.texture;
          renderer.setRenderTarget(attributeTarget);
          renderer.render(attributeScene, orthoCamera);
          finalUniforms.attributeTexture.value = attributeTarget.texture;
        } else if (attributeValue > 1.5) {
          updatePetsciiAttributes(blockWidth, blockHeight, blockSize);
          if (petsciiState.charTexture) {
            finalUniforms.attributeTexture.value = petsciiState.charTexture;
          }
        } else {
          finalUniforms.attributeTexture.value = attributeTarget.texture;
        }

        finalUniforms.sceneTexture.value = sceneTarget.texture;

        renderer.setRenderTarget(null);
        renderer.render(finalScene, orthoCamera);
      }
    };
  }

  const { material: skyMaterial, uniforms: skyUniforms } = createSkyDomeMaterial();
  const skyModeSettings = {
    default: {
      horizon: skyUniforms.horizonColor.value.clone(),
      mid: skyUniforms.midColor.value.clone(),
      zenith: skyUniforms.zenithColor.value.clone(),
      glow: skyUniforms.glowColor.value.clone()
    },
    zx: {
      horizon: new THREE.Color('#1f1fd7'),
      mid: new THREE.Color('#2affff'),
      zenith: new THREE.Color('#ffffff'),
      glow: new THREE.Color('#ff2aff')
    },
    petscii: {
      horizon: new THREE.Color('#001708'),
      mid: new THREE.Color('#015f2a'),
      zenith: new THREE.Color('#0bff6a'),
      glow: new THREE.Color('#6aff9f')
    }
  };
  const skyGeometry = new THREE.SphereGeometry(4200, 48, 24);
  const skyDome = new THREE.Mesh(skyGeometry, skyMaterial);
  skyDome.renderOrder = -6;
  scene.add(skyDome);

  const cloudTexture = createCloudTexture();
  const cloudSprites = [];
  const cloudModeColors = {
    default: new THREE.Color(0xffffff),
    zx: new THREE.Color('#ffd71f'),
    petscii: new THREE.Color('#00ff6a')
  };
  const cloudGroup = new THREE.Group();
  cloudGroup.renderOrder = -4;
  const cloudMaterial = new THREE.SpriteMaterial({
    map: cloudTexture,
    transparent: true,
    opacity: 0.68,
    depthWrite: false,
    depthTest: false
  });
  const cloudCount = 12;
  for (let i = 0; i < cloudCount; i++) {
    const sprite = new THREE.Sprite(cloudMaterial.clone());
    const scale = 420 + Math.random() * 260;
    const aspect = 0.58 + Math.random() * 0.12;
    sprite.scale.set(scale, scale * aspect, 1);
    sprite.renderOrder = -4;
    sprite.material.opacity = 0.45 + Math.random() * 0.22;
    sprite.userData = {
      radius: 520 + Math.random() * 240,
      heightOffset: 160 + Math.random() * 140,
      driftSpeed: 0.06 + Math.random() * 0.06,
      bobSpeed: 0.4 + Math.random() * 0.3,
      baseOpacity: sprite.material.opacity,
      phase: Math.random() * Math.PI * 2,
      windAmplitude: 24 + Math.random() * 18,
      windFrequencyX: 0.08 + Math.random() * 0.06,
      windFrequencyZ: 0.1 + Math.random() * 0.05
    };
    cloudGroup.add(sprite);
    cloudSprites.push(sprite);
  }
  scene.add(cloudGroup);

  function applySkyAndAtmosphereMode(mode) {
    const skySettings = skyModeSettings[mode] || skyModeSettings.default;
    skyUniforms.horizonColor.value.copy(skySettings.horizon);
    skyUniforms.midColor.value.copy(skySettings.mid);
    skyUniforms.zenithColor.value.copy(skySettings.zenith);
    skyUniforms.glowColor.value.copy(skySettings.glow);

    const cloudColor = cloudModeColors[mode] || cloudModeColors.default;
    cloudSprites.forEach(sprite => {
      sprite.material.color.copy(cloudColor);
      sprite.material.needsUpdate = true;
    });
  }

  const blackHoleTextures = {
    core: createBlackHoleCoreTexture(),
    halo: createBlackHoleHaloTexture(),
    disk: createAccretionDiskTexture()
  };

  const blackHoleGroup = new THREE.Group();
  blackHoleGroup.renderOrder = -5;
  scene.add(blackHoleGroup);

  const blackHoleCore = new THREE.Sprite(new THREE.SpriteMaterial({
    map: blackHoleTextures.core,
    transparent: true,
    depthWrite: false,
    depthTest: false
  }));
  blackHoleCore.scale.set(640, 640, 1);
  blackHoleGroup.add(blackHoleCore);

  const blackHoleHalo = new THREE.Sprite(new THREE.SpriteMaterial({
    map: blackHoleTextures.halo,
    transparent: true,
    depthWrite: false,
    depthTest: false,
    blending: THREE.AdditiveBlending,
    opacity: 0.68
  }));
  blackHoleHalo.scale.set(980, 980, 1);
  blackHoleGroup.add(blackHoleHalo);

  const blackHoleDisk = new THREE.Sprite(new THREE.SpriteMaterial({
    map: blackHoleTextures.disk,
    transparent: true,
    depthWrite: false,
    depthTest: true,
    blending: THREE.AdditiveBlending,
    opacity: 0.82
  }));
  blackHoleDisk.scale.set(1380, 820, 1);
  blackHoleDisk.material.rotation = Math.PI / 10;
  blackHoleGroup.add(blackHoleDisk);

  const blackHoleState = {
    group: blackHoleGroup,
    core: blackHoleCore,
    halo: blackHoleHalo,
    disk: blackHoleDisk,
    offset: new THREE.Vector3(-420, 110, -980),
    target: new THREE.Vector3()
  };
  blackHoleGroup.position.copy(blackHoleState.offset);

  const camera = new THREE.PerspectiveCamera(50, 16 / 9, 0.1, 3000);
  const controls = {
    yaw: 0,
    pitch: -0.22,
    yawVelocity: 0,
    speed: 60,
    turnSpeed: Math.PI * 0.45,
    turnSmooth: 3,
    height: 60,
    minPitch: -Math.PI / 3,
    maxPitch: Math.PI / 4,
    dragSensitivity: 0.0024,
    touchDragSensitivity: 0.0042
  };
  let currentSpeed = 0;
  camera.position.set(0, controls.height, 160);
  camera.lookAt(0, 0, 0);

  const keyState = {};
  const horizontalForward = new THREE.Vector3();
  const moveVector = new THREE.Vector3();
  const lookVector = new THREE.Vector3();
  window.addEventListener('keydown', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) { keyState[e.key] = true; e.preventDefault(); }
  });
  window.addEventListener('keyup', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) { keyState[e.key] = false; e.preventDefault(); }
  });

  const onscreenButtons = document.querySelectorAll('#control-pad button[data-key]');
  onscreenButtons.forEach(btn => {
    const key = btn.dataset.key;
    const activate = ev => { keyState[key] = true; ev.preventDefault(); };
    const deactivate = ev => { keyState[key] = false; ev.preventDefault(); };
    btn.addEventListener('mousedown', activate);
    btn.addEventListener('touchstart', activate, { passive: false });
    const endEvents = ['mouseleave','mouseup','touchend','touchcancel'];
    endEvents.forEach(evt => btn.addEventListener(evt, deactivate));
    window.addEventListener('mouseup', () => { keyState[key] = false; });
    window.addEventListener('touchend', () => { keyState[key] = false; });
    window.addEventListener('touchcancel', () => { keyState[key] = false; });
  });

  const pointerState = {
    active: false,
    pointerId: null,
    lastX: 0,
    lastY: 0,
    pointerType: null,
    hasLogged: false
  };

  function beginPointerDrag(event) {
    if (pointerState.active) return;
    if (event.button !== undefined && event.button !== 0) return;
    if (event.target.closest('#control-ui, #console-dock')) return;
    pointerState.active = true;
    pointerState.pointerId = event.pointerId;
    pointerState.lastX = event.clientX;
    pointerState.lastY = event.clientY;
    pointerState.pointerType = event.pointerType || 'mouse';
    renderer.domElement.setPointerCapture(event.pointerId);
    renderer.domElement.style.cursor = 'grabbing';
    if (!pointerState.hasLogged) {
      console.log(`Pointer look engaged (${pointerState.pointerType}).`);
      pointerState.hasLogged = true;
    }
    event.preventDefault();
  }

  function handlePointerMove(event) {
    if (!pointerState.active || event.pointerId !== pointerState.pointerId) return;
    const dx = event.clientX - pointerState.lastX;
    const dy = event.clientY - pointerState.lastY;
    pointerState.lastX = event.clientX;
    pointerState.lastY = event.clientY;
    const sensitivity = event.pointerType === 'touch' ? controls.touchDragSensitivity : controls.dragSensitivity;
    controls.yaw -= dx * sensitivity;
    controls.pitch = THREE.MathUtils.clamp(controls.pitch - dy * sensitivity, controls.minPitch, controls.maxPitch);
    event.preventDefault();
  }

  function endPointerDrag(event) {
    if (pointerState.active && (event.pointerId === pointerState.pointerId || event.type === 'pointerleave')) {
      if (event.pointerId != null && renderer.domElement.hasPointerCapture?.(event.pointerId)) {
        renderer.domElement.releasePointerCapture(event.pointerId);
      }
      pointerState.active = false;
      pointerState.pointerId = null;
      renderer.domElement.style.cursor = 'grab';
    }
  }

  renderer.domElement.addEventListener('pointerdown', beginPointerDrag);
  renderer.domElement.addEventListener('pointermove', handlePointerMove);
  renderer.domElement.addEventListener('pointerup', endPointerDrag);
  renderer.domElement.addEventListener('pointercancel', endPointerDrag);
  renderer.domElement.addEventListener('lostpointercapture', endPointerDrag);
  renderer.domElement.addEventListener('pointerleave', endPointerDrag);
  window.addEventListener('blur', () => { pointerState.active = false; renderer.domElement.style.cursor = 'grab'; });

  let touchStart = null;
  const swipeTouchIgnoreSelector = [
    '#control-pad',
    '#canvas-wrap',
    '#control-ui',
    '#hud-overlay',
    '#console-dock',
    '#fullscreen-btn',
    'button',
    'select',
    'input',
    'label',
    'a',
    '[role="button"]'
  ].join(', ');
  const shouldIgnoreGlobalSwipe = (target) => Boolean(target?.closest(swipeTouchIgnoreSelector));

  window.addEventListener('touchstart', e => {
    if (shouldIgnoreGlobalSwipe(e.target)) return;
    touchStart = e.touches[0];
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchmove', e => {
    if (!touchStart || shouldIgnoreGlobalSwipe(e.target)) return;
    const touch = e.touches[0];
    const dx = touch.clientX - touchStart.clientX;
    const dy = touch.clientY - touchStart.clientY;
    const threshold = 10;
    keyState['ArrowLeft'] = dx < -threshold;
    keyState['ArrowRight'] = dx > threshold;
    keyState['ArrowUp'] = dy < -threshold;
    keyState['ArrowDown'] = dy > threshold;
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchend', e => {
    if (shouldIgnoreGlobalSwipe(e.target)) return;
    touchStart = null;
    keyState['ArrowLeft'] = keyState['ArrowRight'] = keyState['ArrowUp'] = keyState['ArrowDown'] = false;
    e.preventDefault();
  });

  function hash(ix, iz){ const s = Math.sin(ix*127.1 + iz*311.7) * 43758.5453123; return s - Math.floor(s); }
  const lerp = (a,b,t)=> a + (b-a)*t; const smooth = t => t*t*(3-2*t);
  function noise2(x,z){ const ix=Math.floor(x), iz=Math.floor(z), fx=x-ix, fz=z-iz;
    const a=hash(ix,iz), b=hash(ix+1,iz), c=hash(ix,iz+1), d=hash(ix+1,iz+1);
    const ux=smooth(fx), uz=smooth(fz); return lerp( lerp(a,b,ux), lerp(c,d,ux), uz ); }
  function fbm(x,z,oct=5){ let amp=1,freq=0.02,sum=0,norm=0; for(let i=0;i<oct;i++){ sum+=amp*noise2(x*freq,z*freq); norm+=amp; amp*=0.5; freq*=2; } return sum/norm; }

  const terrainSize = 600;
  const terrainSegments = 120;
  const terrain = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
  terrain.rotateX(-Math.PI/2);
  const pos = terrain.attributes.position;
  const basePositions = Float32Array.from(pos.array);
  const fadeAttribute = new Float32Array(pos.count);
  const halfSize = terrainSize / 2;
  const fadeWidth = terrainSize * 0.22;
  const colorAttribute = new THREE.BufferAttribute(new Float32Array(pos.count * 3), 3);
  const zxColorAttribute = new THREE.BufferAttribute(new Float32Array(pos.count * 3), 3);
  for (let i = 0; i < pos.count; i++) {
    const ix = i * 3;
    const x = basePositions[ix];
    const z = basePositions[ix + 2];
    const distX = halfSize - Math.abs(x);
    const distZ = halfSize - Math.abs(z);
    const edgeDistance = Math.max(0, Math.min(distX, distZ));
    const fadeStrength = THREE.MathUtils.clamp(edgeDistance / fadeWidth, 0, 1);
    fadeAttribute[i] = fadeStrength * fadeStrength;
  }
  terrain.setAttribute('edgeFade', new THREE.BufferAttribute(fadeAttribute, 1));
  terrain.setAttribute('color', colorAttribute);
  terrain.setAttribute('zxColor', zxColorAttribute);
  const cellSize = terrainSize / terrainSegments;
  const chunkSize = cellSize * 10;
  const terrainState = { offsetX: 0, offsetZ: 0 };
  const plateauHalfSize = chunkSize * 1.5;
  const plateauBlend = chunkSize * 0.8;
  const plateauLevel = 0;
  const plateauColor = new THREE.Color(0xdde3f5);
  const tileBorderWidth = chunkSize * 0.12;

  const chunkColorCache = new Map();
  function chunkRandom(ix, iz, salt = 0) {
    return hash(ix + salt * 19.19, iz + salt * 7.7);
  }
  function getChunkColor(cx, cz) {
    const key = `${cx},${cz}`;
    let color = chunkColorCache.get(key);
    if (!color) {
      const hue = chunkRandom(cx * 0.61, cz * 0.47, 1);
      const saturation = 0.35 + chunkRandom(cx * 0.93, cz * 0.78, 2) * 0.3;
      const lightness = 0.3 + chunkRandom(cx * 1.21, cz * 1.09, 3) * 0.28;
      color = new THREE.Color().setHSL(hue, saturation, lightness);
      chunkColorCache.set(key, color);
    }
    return color;
  }

  function refreshTerrain(offsetX, offsetZ) {
    const colors = colorAttribute.array;
    const zxColors = zxColorAttribute.array;
    for (let i = 0; i < pos.count; i++) {
      const ix = i * 3;
      const x = basePositions[ix];
      const z = basePositions[ix + 2];
      const worldX = x + offsetX;
      const worldZ = z + offsetZ;
      const y = fbm(worldX, worldZ) * 60 - 18;
      const distanceFromPlateau = Math.max(Math.abs(worldX) - plateauHalfSize, Math.abs(worldZ) - plateauHalfSize);
      let finalY = y;
      if (distanceFromPlateau <= plateauBlend) {
        const t = THREE.MathUtils.clamp(1 - distanceFromPlateau / plateauBlend, 0, 1);
        const eased = smooth(t);
        finalY = THREE.MathUtils.lerp(y, plateauLevel, eased);
      }
      pos.setY(i, finalY);
      const chunkX = Math.round(worldX / chunkSize);
      const chunkZ = Math.round(worldZ / chunkSize);
      const isPlateau = Math.abs(worldX) <= plateauHalfSize && Math.abs(worldZ) <= plateauHalfSize;
      const baseColor = isPlateau ? plateauColor : getChunkColor(chunkX, chunkZ);

      let r = baseColor.r;
      let g = baseColor.g;
      let b = baseColor.b;

      const localX = THREE.MathUtils.euclideanModulo(worldX, chunkSize);
      const localZ = THREE.MathUtils.euclideanModulo(worldZ, chunkSize);
      const edgeDistX = Math.min(localX, chunkSize - localX);
      const edgeDistZ = Math.min(localZ, chunkSize - localZ);
      const edgeFactorX = 1 - THREE.MathUtils.clamp(edgeDistX / tileBorderWidth, 0, 1);
      const edgeFactorZ = 1 - THREE.MathUtils.clamp(edgeDistZ / tileBorderWidth, 0, 1);
      const edgeMix = Math.max(edgeFactorX, edgeFactorZ);
      if (edgeMix > 0) {
        const mixAmount = edgeMix * 0.85;
        r = THREE.MathUtils.lerp(r, 1, mixAmount);
        g = THREE.MathUtils.lerp(g, 1, mixAmount);
        b = THREE.MathUtils.lerp(b, 1, mixAmount);
      }

      colors[ix] = r;
      colors[ix + 1] = g;
      colors[ix + 2] = b;

      paletteScratchColor.setRGB(r, g, b);
      const zxMatch = findNearestPaletteColor(paletteScratchColor, zxGroundPalette);
      zxColors[ix] = zxMatch.r;
      zxColors[ix + 1] = zxMatch.g;
      zxColors[ix + 2] = zxMatch.b;
    }
    pos.needsUpdate = true;
    colorAttribute.needsUpdate = true;
    zxColorAttribute.needsUpdate = true;
    terrain.computeVertexNormals();
    if (terrain.attributes.normal) {
      terrain.attributes.normal.needsUpdate = true;
    }
    terrain.computeBoundingSphere();
    terrain.computeBoundingBox();
  }
  refreshTerrain(terrainState.offsetX, terrainState.offsetZ);
  const terrainMaterial = new THREE.MeshLambertMaterial({
    color: 0xffffff,
    vertexColors: true,
    fog: true
  });
  const edgeFadeUniform = {
    value: scene.fog ? scene.fog.color.clone() : new THREE.Color(renderModeFogColors.default)
  };
  terrainMaterial.onBeforeCompile = shader => {
    shader.uniforms.edgeFadeColor = edgeFadeUniform;
    shader.vertexShader = shader.vertexShader
      .replace('#include <common>', `#include <common>\nattribute float edgeFade;\nvarying float vEdgeFade;`)
      .replace('#include <begin_vertex>', `#include <begin_vertex>\nvEdgeFade = edgeFade;`);
    shader.fragmentShader = shader.fragmentShader
      .replace('#include <common>', `#include <common>\nvarying float vEdgeFade;\nuniform vec3 edgeFadeColor;`)
      .replace('gl_FragColor = vec4( outgoingLight, diffuseColor.a );', `
      vec3 gouraudColor = floor(outgoingLight * ${GOURAUD_LEVELS}.0 + 0.5) / ${GOURAUD_LEVELS}.0;
      gl_FragColor = vec4( gouraudColor, diffuseColor.a );
      gl_FragColor.rgb = mix(edgeFadeColor, gl_FragColor.rgb, vEdgeFade);
    `);
  };
  terrainMaterial.customProgramCacheKey = () => `terrain_gouraud_${GOURAUD_LEVELS}`;
  terrainMaterial.needsUpdate = true;
  const terrainMesh = new THREE.Mesh(terrain, terrainMaterial);
  terrainMesh.position.set(terrainState.offsetX, 0, terrainState.offsetZ);
  scene.add(terrainMesh);
  defaultTerrainColor = terrainMesh.material.color.clone();
  const terrainZXMaterial = new THREE.MeshBasicMaterial({
    color: 0xffffff,
    fog: true,
    depthTest: true,
    depthWrite: true,
    polygonOffset: true,
    polygonOffsetFactor: -1,
    polygonOffsetUnits: -1
  });
  terrainZXMaterial.onBeforeCompile = shader => {
    shader.vertexShader = shader.vertexShader
      .replace('#include <common>', `#include <common>\nattribute vec3 zxColor;\nvarying vec3 vZXColor;`)
      .replace('#include <begin_vertex>', `#include <begin_vertex>\nvZXColor = zxColor;`);
    shader.fragmentShader = shader.fragmentShader
      .replace('#include <common>', `#include <common>\nvarying vec3 vZXColor;`)
      .replace('vec4 diffuseColor = vec4( diffuse, opacity );', 'vec4 diffuseColor = vec4( vZXColor, opacity );');
  };
  const terrainZXMesh = new THREE.Mesh(terrain, terrainZXMaterial);
  terrainZXMesh.visible = false;
  terrainZXMesh.renderOrder = -1;
  terrainZXMesh.position.copy(terrainMesh.position);
  scene.add(terrainZXMesh);
  function snapToChunk(value) { return Math.round(value / chunkSize) * chunkSize; }

  const cityGroup = new THREE.Group();
  cityGroup.name = 'PlateauCity';
  terrainMesh.add(cityGroup);
  const cityMeshes = [];

  function registerCityMesh(mesh) {
    if (!mesh) return;
    cityMeshes.push(mesh);
    if (mesh.material && mesh.material.color) {
      mesh.userData.baseColor = mesh.material.color.clone();
    }
  }

  function updateCityAnchor() {
    cityGroup.position.set(-terrainState.offsetX, 0, -terrainState.offsetZ);
  }

  function buildCityOnPlateau() {
    cityGroup.clear();
    cityMeshes.length = 0;

    const plazaSize = plateauHalfSize * 1.25;
    const plazaHeight = 0.7;
    const plaza = new THREE.Mesh(
      new THREE.BoxGeometry(plazaSize, plazaHeight, plazaSize),
      createGouraudMaterial({ color: new THREE.Color(0x1d2432) })
    );
    plaza.position.y = plateauLevel - plazaHeight / 2;
    plaza.receiveShadow = true;
    cityGroup.add(plaza);
    registerCityMesh(plaza);

    const pathway = new THREE.Mesh(
      new THREE.BoxGeometry(plazaSize * 0.6, 0.3, chunkSize * 0.2),
      createGouraudMaterial({ color: new THREE.Color(0x2c384a) })
    );
    pathway.position.y = plateauLevel + 0.01;
    cityGroup.add(pathway);
    registerCityMesh(pathway);

    const crossPath = pathway.clone();
    crossPath.rotation.y = Math.PI / 2;
    cityGroup.add(crossPath);
    registerCityMesh(crossPath);

    const buildingGeometry = new THREE.BoxGeometry(1, 1, 1);
    const towerMaterial = createGouraudMaterial({ color: new THREE.Color(0x8fb4ff), emissive: new THREE.Color(0x0b1b3c), emissiveIntensity: 0.12 });
    const buildingMaterials = [
      createGouraudMaterial({ color: new THREE.Color(0x3f5c7a) }),
      createGouraudMaterial({ color: new THREE.Color(0x516b8c) }),
      createGouraudMaterial({ color: new THREE.Color(0x6884a8) })
    ];

    const gridCount = 3;
    const spacing = chunkSize * 0.55;
    const startOffset = -spacing * (gridCount - 1) / 2;
    for (let gx = 0; gx < gridCount; gx++) {
      for (let gz = 0; gz < gridCount; gz++) {
        const x = startOffset + gx * spacing;
        const z = startOffset + gz * spacing;
        const isCenter = Math.abs(x) < chunkSize * 0.2 && Math.abs(z) < chunkSize * 0.2;
        const baseScale = isCenter ? 0.16 : 0.08;
        const variation = isCenter ? 0.08 : 0.07;
        const width = chunkSize * (baseScale + Math.random() * variation);
        const depth = chunkSize * (baseScale + Math.random() * variation);
        const height = isCenter ? chunkSize * 0.9 : chunkSize * (0.35 + Math.random() * 0.55);
        const material = isCenter ? towerMaterial : buildingMaterials[(gx + gz) % buildingMaterials.length];
        const building = new THREE.Mesh(buildingGeometry.clone(), material);
        building.scale.set(width, height, depth);
        building.position.set(x, plateauLevel + height / 2, z);
        building.castShadow = true;
        building.receiveShadow = true;
        cityGroup.add(building);
        registerCityMesh(building);

        if (!isCenter && Math.random() > 0.5) {
          const roofHeight = height * (0.45 + Math.random() * 0.15);
          const roof = new THREE.Mesh(
            new THREE.ConeGeometry(width * 0.35, height * 0.16, 4),
            createGouraudMaterial({ color: new THREE.Color(0xffb347) })
          );
          roof.position.set(x, plateauLevel + roofHeight, z);
          roof.rotation.y = Math.PI / 4;
          roof.castShadow = true;
          cityGroup.add(roof);
          registerCityMesh(roof);
        }
      }
    }

    const borderHeight = 1.6;
    const borderThickness = chunkSize * 0.16;
    const borderLength = plazaSize * 0.95;
    const borderMaterial = createGouraudMaterial({ color: new THREE.Color(0x2a3646) });
    for (let i = 0; i < 4; i++) {
      const wall = new THREE.Mesh(
        new THREE.BoxGeometry(borderLength, borderHeight, borderThickness),
        borderMaterial
      );
      wall.position.y = plateauLevel + borderHeight / 2;
      if (i < 2) {
        wall.position.z = (i === 0 ? -1 : 1) * (plazaSize / 2 - borderThickness / 2);
      } else {
        wall.rotation.y = Math.PI / 2;
        wall.position.x = (i === 2 ? -1 : 1) * (plazaSize / 2 - borderThickness / 2);
      }
      wall.castShadow = true;
      wall.receiveShadow = true;
      cityGroup.add(wall);
      registerCityMesh(wall);
    }

    updateCityAnchor();
  }

  buildCityOnPlateau();

  function updateCityRenderMode(isWire, wireColor) {
    cityMeshes.forEach(mesh => {
      if (!mesh.material) return;
      mesh.material.wireframe = isWire;
      mesh.material.side = THREE.FrontSide;
      if (mesh.userData.baseColor && mesh.material.color) {
        if (isWire) {
          mesh.material.color.copy(wireColor);
        } else {
          mesh.material.color.copy(mesh.userData.baseColor);
        }
      }
      mesh.material.needsUpdate = true;
    });
  }

  const groundRay = new THREE.Raycaster();
  const floatingBlocks = [];

  function updateRenderButtons(activeMode) {
    renderModeButtons.forEach(button => {
      const isActive = button.dataset.renderMode === activeMode;
      button.classList.toggle('is-active', isActive);
      button.setAttribute('aria-pressed', String(isActive));
    });
  }

  function applyRenderMode(mode, { announce = true } = {}) {
    const previousMode = currentRenderMode;
    currentRenderMode = mode;
    const isWireMode = mode === 'wire' || mode === 'zx';
    const wireColors = getWireColorsForMode(mode);
    const retroPalette = retroPalettes[mode];
    const useRetro = Boolean(retroPalette);
    if (defaultTerrainColor) {
      terrainMesh.material.wireframe = isWireMode;
      terrainMesh.material.side = THREE.FrontSide;
      terrainMesh.material.color.copy(isWireMode ? wireColors.terrain : defaultTerrainColor);
      terrainMesh.material.needsUpdate = true;
    }
    if (terrainZXMesh) {
      terrainZXMesh.visible = mode === 'zx';
    }
    floatingBlocks.forEach(block => {
      block.material.wireframe = isWireMode;
      block.material.side = THREE.FrontSide;
      if (isWireMode) {
        block.material.color.copy(wireColors.block);
      } else if (block.userData.baseColor) {
        block.material.color.copy(block.userData.baseColor);
      }
      block.material.needsUpdate = true;
    });
    updateCityRenderMode(isWireMode, wireColors.block);
    retroEffect.setEnabled(useRetro);
    if (useRetro) {
      retroEffect.setConfig(retroModeConfigs[mode] || retroModeConfigs.default);
      retroEffect.setPalette(retroPalette);
    } else {
      retroEffect.setConfig(retroModeConfigs.default);
    }
    applySkyAndAtmosphereMode(mode);
    const fogHex = renderModeFogColors[mode] ?? renderModeFogColors.default;
    scene.fog.color.set(fogHex);
    edgeFadeUniform.value.set(fogHex);
    renderer.setClearColor(fogHex);
    renderer.domElement.style.background = renderModeCanvasBackgrounds[mode] ?? renderModeCanvasBackgrounds.default;
    updateRenderButtons(mode);
    if (announce && previousMode !== mode) {
      const description = renderModeDescriptions[mode] || mode;
      console.log(`Render mode switched to ${description}.`);
    }
  }

  renderModeButtons.forEach(button => {
    button.addEventListener('click', () => {
      const mode = button.dataset.renderMode;
      if (!mode || mode === currentRenderMode) return;
      applyRenderMode(mode);
    });
  });

  applyRenderMode(currentRenderMode, { announce: false });

  function createBlock(x, z) {
    const size = 2;
    const color = new THREE.Color().setHSL(Math.random() * 0.15, 0.9, 0.5 + Math.random() * 0.1);
    const block = new THREE.Mesh(
      new THREE.BoxGeometry(size, size, size),
      createGouraudMaterial({ color })
    );
    groundRay.set(new THREE.Vector3(x, 100, z), new THREE.Vector3(0, -1, 0));
    const hit = groundRay.intersectObject(terrainMesh);
    const y = hit.length ? hit[0].point.y : 0;
    block.position.set(x, y + size / 2 + 8 * Math.random(), z);
    block.castShadow = true;
    block.receiveShadow = true;
    block.userData.baseColor = block.material.color.clone();
    if (currentRenderMode === 'wire' || currentRenderMode === 'zx') {
      const activeWireColors = getWireColorsForMode(currentRenderMode);
      block.material.wireframe = true;
      block.material.side = THREE.FrontSide;
      block.material.color.copy(activeWireColors.block);
      block.material.needsUpdate = true;
    }
    block.userData.base = block.position.clone();
    block.userData.bobSpeed = 0.35 + Math.random() * 0.3;
    block.userData.bobAmp = 4 + Math.random() * 6;
    block.userData.phase = Math.random() * Math.PI * 2;
    block.userData.windSeed = Math.random() * Math.PI * 2;
    block.userData.windSpeed = 0.6 + Math.random() * 0.5;
    block.userData.windStrength = 10 + Math.random() * 6;
    block.userData.windOffset = new THREE.Vector3();
    block.userData.windVelocity = new THREE.Vector3();
    scene.add(block);
    floatingBlocks.push(block);
  }

  const blockSpread = terrainSize * 0.48;
  const cityExclusion = plateauHalfSize + chunkSize * 0.4;
  async function generateBlocks(count) {
    let created = 0;
    let lastYield = performance.now();
    while (created < count) {
      const x = Math.random() * blockSpread * 2 - blockSpread;
      const z = Math.random() * blockSpread * 2 - blockSpread;
      if (Math.abs(x) < cityExclusion && Math.abs(z) < cityExclusion) {
        continue;
      }
      createBlock(x, z);
      created++;
      const now = performance.now();
      if (now - lastYield >= 16 || created === count) {
        setProgress((created / count) * 100);
        await new Promise(resolve => requestAnimationFrame(resolve));
        lastYield = now;
      }
    }
    setProgress(100);
    await new Promise(resolve => requestAnimationFrame(resolve));
    if (loaderEl) {
      stopLoaderAnimation();
      loaderEl.remove();
    }
    console.log(`Terrain populated with ${count} blocks.`);
  }

  function updateControls(dt){
    const yawInput = (keyState['ArrowRight'] ? 1 : 0) - (keyState['ArrowLeft'] ? 1 : 0);
    const targetYawVelocity = yawInput * controls.turnSpeed;
    controls.yawVelocity = THREE.MathUtils.damp(controls.yawVelocity, targetYawVelocity, controls.turnSmooth, dt);
    controls.yaw += controls.yawVelocity * dt;
    controls.yaw = THREE.MathUtils.euclideanModulo(controls.yaw, Math.PI * 2);

    horizontalForward.set(Math.sin(controls.yaw), 0, -Math.cos(controls.yaw));
    moveVector.set(0, 0, 0);
    if (keyState['ArrowUp']) moveVector.add(horizontalForward);
    if (keyState['ArrowDown']) moveVector.addScaledVector(horizontalForward, -1);

    let speedTarget = 0;
    if (moveVector.lengthSq() > 0) {
      moveVector.normalize().multiplyScalar(controls.speed * dt);
      speedTarget = controls.speed;
      camera.position.add(moveVector);
    }
    currentSpeed = THREE.MathUtils.damp(currentSpeed, speedTarget, 6, dt);

    const cosPitch = Math.cos(controls.pitch);
    lookVector.set(
      Math.sin(controls.yaw) * cosPitch,
      Math.sin(controls.pitch),
      -Math.cos(controls.yaw) * cosPitch
    );
    camera.position.y = controls.height;
    lookTargetScratch.copy(camera.position).add(lookVector);
    camera.lookAt(lookTargetScratch);
  }

  function updateSky(time, dt){
    skyDome.position.copy(camera.position);
    const glowTarget = 0.12 + (Math.sin(time * 0.22) + 1) * 0.04;
    skyUniforms.glowStrength.value = THREE.MathUtils.damp(skyUniforms.glowStrength.value, glowTarget, 2.4, dt);
    skyUniforms.time.value = time;

    if (blackHoleState) {
      blackHoleState.target.copy(camera.position).add(blackHoleState.offset);
      blackHoleState.target.y = camera.position.y * 0.42 + 48;
      blackHoleState.group.position.lerp(blackHoleState.target, THREE.MathUtils.clamp(dt * 1.4, 0, 1));

      const haloTarget = 0.6 + Math.sin(time * 0.52) * 0.18;
      const dampedHalo = THREE.MathUtils.damp(blackHoleState.halo.material.opacity, haloTarget, 2.2, dt);
      blackHoleState.halo.material.opacity = THREE.MathUtils.clamp(dampedHalo, 0.32, 0.9);

      blackHoleState.disk.material.rotation += dt * 0.22;
      blackHoleState.halo.material.rotation -= dt * 0.08;

      const corePulse = 620 + Math.sin(time * 0.9) * 28;
      blackHoleState.core.scale.set(corePulse, corePulse, 1);
      const diskWidth = 1380 + Math.sin(time * 0.4) * 64;
      const diskHeight = 820 + Math.cos(time * 0.55) * 44;
      blackHoleState.disk.scale.set(diskWidth, diskHeight, 1);
    }

    for (const sprite of cloudSprites) {
      const data = sprite.userData;
      const angle = time * data.driftSpeed + data.phase;
      const windOffsetX = Math.sin(time * data.windFrequencyX + data.phase) * data.windAmplitude;
      const windOffsetZ = Math.cos(time * data.windFrequencyZ + data.phase * 0.6) * data.windAmplitude;
      const targetX = camera.position.x + Math.cos(angle) * data.radius + windOffsetX;
      const targetZ = camera.position.z + Math.sin(angle) * data.radius + windOffsetZ;
      sprite.position.x = THREE.MathUtils.damp(sprite.position.x, targetX, 3.2, dt);
      sprite.position.z = THREE.MathUtils.damp(sprite.position.z, targetZ, 3.2, dt);
      const bob = Math.sin(time * data.bobSpeed + data.phase) * 14;
      const targetY = camera.position.y + data.heightOffset + bob;
      sprite.position.y = THREE.MathUtils.damp(sprite.position.y, targetY, 2.4, dt);
      const targetOpacity = data.baseOpacity + Math.sin(time * 0.32 + data.phase) * 0.1;
      const dampedOpacity = THREE.MathUtils.damp(sprite.material.opacity, targetOpacity, 2.8, dt);
      sprite.material.opacity = THREE.MathUtils.clamp(dampedOpacity, 0.28, 0.92);
      sprite.material.rotation = Math.sin(time * 0.12 + data.phase) * 0.18 + Math.sin(time * data.windFrequencyX) * 0.05;
    }
  }

  function updateLighting(dt, time, isMoving) {
    sunLightDesired.copy(camera.position).add(sunLightOffset);
    sunLightDesired.x += Math.sin(time * 0.18) * 90;
    sunLightDesired.z += Math.cos(time * 0.16) * 110;
    const lerpFactor = THREE.MathUtils.clamp(dt * 3.6, 0, 1);
    sunLight.position.lerp(sunLightDesired, lerpFactor);

    sunLightTargetDesired.copy(camera.position).addScaledVector(lookVector, 60);
    sunLight.target.position.lerp(sunLightTargetDesired, lerpFactor);
    sunLight.target.updateMatrixWorld();

    const baseIntensity = 1.05 + Math.sin(time * 0.24) * 0.08;
    const targetIntensity = baseIntensity + (isMoving ? 0.18 : 0);
    sunLight.intensity = THREE.MathUtils.damp(sunLight.intensity, targetIntensity, 3.2, dt);
  }

  function updateTerrainFollow() {
    const snappedX = snapToChunk(camera.position.x);
    const snappedZ = snapToChunk(camera.position.z);
    if (snappedX !== terrainState.offsetX || snappedZ !== terrainState.offsetZ) {
      terrainState.offsetX = snappedX;
      terrainState.offsetZ = snappedZ;
      refreshTerrain(snappedX, snappedZ);
      terrainMesh.position.set(snappedX, 0, snappedZ);
      if (terrainZXMesh) {
        terrainZXMesh.position.copy(terrainMesh.position);
      }
      updateCityAnchor();
      console.log(`Terrain recentered to chunk (${Math.round(snappedX / chunkSize)}, ${Math.round(snappedZ / chunkSize)}).`);
    }
  }

  const tempVec = new THREE.Vector3();
  const lookTargetScratch = new THREE.Vector3();
  const desiredBlock = new THREE.Vector3();
  const windScratch = new THREE.Vector3();
  function updateHud() {
    if (!hudElements.position) return;
    const pos = camera.position;
    hudElements.position.textContent = `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
    const yawDeg = THREE.MathUtils.euclideanModulo(THREE.MathUtils.radToDeg(controls.yaw), 360);
    const pitchDeg = THREE.MathUtils.radToDeg(controls.pitch);
    hudElements.heading.textContent = `${yawDeg.toFixed(1)}° / ${pitchDeg.toFixed(1)}°`;
    hudElements.chunk.textContent = `${Math.round(terrainState.offsetX / chunkSize)}, ${Math.round(terrainState.offsetZ / chunkSize)}`;
    hudElements.speed.textContent = `${currentSpeed.toFixed(1)} m/s`;
  }
  function updateBlocks(dt, time) {
    const cameraPos = camera.position;
    const influenceRadius = 60;
    const influenceRadiusSq = influenceRadius * influenceRadius;
    for (const block of floatingBlocks) {
      const data = block.userData;
      const bob = Math.sin(time * data.bobSpeed + data.phase) * data.bobAmp;
      desiredBlock.copy(data.base);
      desiredBlock.y += bob;
      tempVec.copy(cameraPos).sub(block.position);
      const distanceSq = tempVec.lengthSq();
      if (distanceSq < influenceRadiusSq) {
        const distance = Math.sqrt(distanceSq);
        const strength = (influenceRadius - distance) / influenceRadius;
        const windPhase = time * data.windSpeed + data.windSeed;
        windScratch.set(
          Math.sin(windPhase),
          Math.cos(windPhase * 0.8) * 0.3,
          Math.cos(windPhase * 1.1)
        );
        data.windVelocity.addScaledVector(windScratch, strength * data.windStrength * dt);
      }
      data.windVelocity.multiplyScalar(Math.max(0, 1 - dt * 2.2));
      data.windOffset.addScaledVector(data.windVelocity, dt);
      data.windOffset.multiplyScalar(0.92);
      desiredBlock.add(data.windOffset);
      block.position.lerp(desiredBlock, THREE.MathUtils.clamp(dt * 4, 0, 1));
    }
  }

  let last = performance.now();
  function animate(){
    fpsMonitor.begin();
    const now = performance.now();
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    updateControls(dt);
    const isCameraMoving = moveVector.lengthSq() > 1e-6 || currentSpeed > 0.5;
    updateTerrainFollow();
    updateHud();
    updateBlocks(dt, now / 1000);
    updateSky(now / 1000, dt);
    updateLighting(dt, now / 1000, isCameraMoving);
    if (retroEffect.enabled) {
      retroEffect.render(scene, camera);
    } else {
      renderer.render(scene, camera);
    }
    fpsMonitor.end();
    requestAnimationFrame(animate);
  }

  async function bootTerrain() {
    console.log('Terrain initialising...');
    setProgress(0);
    await generateBlocks(1000);
    applyRenderMode(currentRenderMode, { announce: false });
    console.log('Terrain ready.');
    animate();
  }

  bootTerrain().catch(err => {
    console.error('Terrain failed to initialise.', err);
    if (progressEl) {
      progressEl.textContent = 'ERR';
    }
    if (loaderEl) {
      stopLoaderAnimation();
      loaderEl.classList.add('is-error');
    }
  });

  const resolutionSelect = document.getElementById('resolution-select');
  const resolutionDisplay = document.getElementById('resolution-display');
  const fullscreenBtn = document.getElementById('fullscreen-btn');
  const controlUi = document.getElementById('control-ui');
  const foldBtn = document.getElementById('ui-fold-btn');
  let setControlFolded = null;

  if (foldBtn && controlUi) {
    const syncControlFold = (folded) => {
      controlUi.classList.toggle('folded', folded);
      foldBtn.setAttribute('aria-expanded', String(!folded));
      const label = folded ? 'Expand control panel' : 'Collapse control panel';
      foldBtn.setAttribute('aria-label', label);
    };
    setControlFolded = syncControlFold;
    foldBtn.addEventListener('click', () => {
      const next = !controlUi.classList.contains('folded');
      syncControlFold(next);
      console.log(`Control interface ${next ? 'folded' : 'expanded'}.`);
    });
    syncControlFold(controlUi.classList.contains('folded'));
    console.log('Control interface initialised with animated fold icon.');
  }

  const isFullscreenActive = () => Boolean(
    document.fullscreenElement ||
    document.webkitFullscreenElement ||
    document.msFullscreenElement
  );

  let currentResolution = defaultResolution;
  let vhsTimeoutId = null;
  const MOBILE_BREAKPOINT = 720;
  let isMobileLayout = null;

  function updateResponsiveState() {
    const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
    document.body.classList.toggle('is-mobile', isMobile);
    if (isMobile !== isMobileLayout) {
      if (isMobile) {
        setControlFolded?.(true);
        setConsoleFolded?.(true);
      }
      isMobileLayout = isMobile;
    }
  }

  const spawnVhsLines = () => {
    if (!canvasWrap) return;
    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
    const createLine = (topPercent) => {
      const line = document.createElement('div');
      line.classList.add('vhs-line');

      const isCluster = Math.random() < 0.45;
      if (isCluster) {
        line.classList.add('vhs-line--cluster');
        const clusterThickness = 2 + Math.random() * 3;
        line.style.setProperty('--cluster-thickness', `${clusterThickness}px`);
        const clusterHeight = 14 + Math.random() * 26;
        line.style.height = `${clusterHeight}px`;
      } else {
        const baseHeight = 4 + Math.random() * 10;
        line.style.height = `${baseHeight}px`;
      }

      const top = clamp(topPercent, 0, 100);
      line.style.top = `${top}%`;

      const shiftStart = (Math.random() - 0.5) * 140;
      const shiftMid = shiftStart + (Math.random() - 0.5) * 180;
      const shiftEnd = (Math.random() - 0.5) * 120;
      const shiftClear = (Math.random() - 0.5) * 20;
      line.style.setProperty('--shift-start', `${shiftStart}px`);
      line.style.setProperty('--shift-mid', `${shiftMid}px`);
      line.style.setProperty('--shift-end', `${shiftEnd}px`);
      line.style.setProperty('--shift-clear', `${shiftClear}px`);

      const skewStart = (Math.random() - 0.5) * 4;
      const skewMid = (Math.random() - 0.5) * 12;
      const skewEnd = (Math.random() - 0.5) * 4;
      line.style.setProperty('--skew-start', `${skewStart}deg`);
      line.style.setProperty('--skew-mid', `${skewMid}deg`);
      line.style.setProperty('--skew-end', `${skewEnd}deg`);

      line.style.setProperty('--line-opacity', `${0.5 + Math.random() * 0.4}`);
      line.style.setProperty('--line-brightness', `${0.85 + Math.random() * 0.6}`);
      line.style.setProperty('--line-hue', `${(Math.random() - 0.5) * 100}deg`);

      canvasWrap.appendChild(line);
      line.addEventListener('animationend', () => {
        line.remove();
      }, { once: true });
    };

    const groupCount = 3 + Math.floor(Math.random() * 4);
    for (let group = 0; group < groupCount; group++) {
      const baseTop = Math.random() * 100;
      const linesInGroup = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < linesInGroup; i++) {
        createLine(baseTop + (Math.random() - 0.5) * 10);
      }
    }
  };

  const triggerVhsEffect = () => {
    if (!canvasWrap) return;
    canvasWrap.classList.remove('vhs-glitch');
    void canvasWrap.offsetWidth;
    canvasWrap.classList.add('vhs-glitch');
    spawnVhsLines();
    if (vhsTimeoutId) {
      clearTimeout(vhsTimeoutId);
    }
    vhsTimeoutId = setTimeout(() => {
      canvasWrap.classList.remove('vhs-glitch');
    }, 650);
  };

  function applyResolution(res) {
    currentResolution = res;
    renderer.setSize(res.width, res.height, false);
    renderer.domElement.width = res.width;
    renderer.domElement.height = res.height;
    retroEffect.setSize(res.width, res.height);
    camera.aspect = res.width / res.height;
    camera.updateProjectionMatrix();
    resolutionDisplay.textContent = `${res.label} — ${res.width} × ${res.height}`;
    updateCanvasLayout();
    console.log(`Resolution set to ${res.width}×${res.height} (${res.label}).`);
  }

  function parseResolution(value) {
    const [w, h] = value.split('x').map(Number);
    return RESOLUTIONS.find(r => r.width === w && r.height === h) || defaultResolution;
  }

  function updateCanvasLayout() {
    const aspect = currentResolution.width / currentResolution.height;
    const availableWidth = Math.max(100, window.innerWidth);
    const availableHeight = Math.max(100, window.innerHeight);

    let displayWidth = availableWidth;
    let displayHeight = displayWidth / aspect;

    if (displayHeight > availableHeight) {
      const scale = availableHeight / displayHeight;
      displayWidth = Math.floor(displayWidth * scale);
      displayHeight = availableHeight;
    }

    renderer.domElement.style.width = `${displayWidth}px`;
    renderer.domElement.style.height = `${displayHeight}px`;
    canvasWrap.style.width = `${displayWidth}px`;
    canvasWrap.style.height = `${displayHeight}px`;
  }

  resolutionSelect.addEventListener('change', () => {
    applyResolution(parseResolution(resolutionSelect.value));
    triggerVhsEffect();
  });

  function updateFullscreenButton() {
    const isFullscreen = isFullscreenActive();
    const isMobile = document.body.classList.contains('is-mobile');
    const label = isFullscreen ? 'Exit Fullscreen' : (isMobile ? 'Fullscreen' : 'Enter Fullscreen');
    fullscreenBtn.textContent = label;
    const shouldShow = isFullscreen || window.innerWidth >= MOBILE_BREAKPOINT || isMobile;
    fullscreenBtn.style.display = shouldShow ? 'inline-flex' : 'none';
    document.body.classList.toggle('is-fullscreen', isFullscreen);
  }

  fullscreenBtn.addEventListener('click', () => {
    if (isFullscreenActive()) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
    } else {
      const target = document.documentElement;
      const request = target.requestFullscreen || target.webkitRequestFullscreen || target.msRequestFullscreen;
      if (request) request.call(target);
    }
  });

  document.addEventListener('fullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });
  document.addEventListener('webkitfullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });
  document.addEventListener('msfullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });

  window.addEventListener('resize', () => {
    updateResponsiveState();
    updateCanvasLayout();
    updateFullscreenButton();
  });

  window.addEventListener('orientationchange', () => {
    updateResponsiveState();
    updateCanvasLayout();
    updateFullscreenButton();
  });

  updateResponsiveState();
  applyResolution(currentResolution);
  updateFullscreenButton();
  updateCanvasLayout();
  })();
  </script>
</body>
</html>
