<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Terrain</title>
  <style>
    :root {
      --navy-900: #020817;
      --navy-800: #071127;
      --navy-700: #0b1a35;
      --frame-border: rgba(0, 0, 0, 0.45);
      --frame-border-light: rgba(255, 255, 255, 0.08);
      --text-white: #ffffff;
      --text-black: #050505;
      --accent-orange: #ff8b2f;
      --graph-grid: rgba(255, 255, 255, 0.18);
      --graph-fill: rgba(255, 139, 47, 0.18);
      --graph-line: #ff8b2f;
    }
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      color: var(--text-white);
      font-family: 'Trebuchet MS', 'Lucida Sans', 'Geneva', sans-serif;
    }
    body {
      position: relative;
      background:
        radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.06), transparent 45%),
        radial-gradient(circle at 80% 30%, rgba(255, 139, 47, 0.08), transparent 55%),
        var(--navy-900);
      background-size: cover;
    }
    #scene-shell {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      pointer-events: none;
      box-sizing: border-box;
    }
    #canvas-wrap {
      position: relative;
      pointer-events: auto;
      display: flex;
      align-items: center;
      justify-content: center;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }
    #canvas-wrap::before,
    #canvas-wrap::after {
      content: '';
      position: absolute;
      inset: -4%;
      opacity: 0;
      pointer-events: none;
    }
    #canvas-wrap.vhs-glitch {
      animation: vhs-warp 0.6s ease-out;
      filter: saturate(1.2) contrast(1.1);
    }
    #canvas-wrap.vhs-glitch::before {
      background:
        repeating-linear-gradient(
          to bottom,
          rgba(255, 139, 47, 0.2) 0px,
          rgba(255, 139, 47, 0.2) 2px,
          transparent 2px,
          transparent 4px
        ),
        linear-gradient(90deg, rgba(255, 0, 90, 0.18), rgba(0, 240, 255, 0.18));
      mix-blend-mode: screen;
      animation: vhs-noise 0.6s ease-out forwards;
    }
    #canvas-wrap.vhs-glitch::after {
      background: linear-gradient(0deg, rgba(255, 255, 255, 0.06), transparent 60%);
      mix-blend-mode: lighten;
      animation: vhs-color 0.6s ease-out forwards;
    }
    canvas {
      display: block;
      border: 2px solid var(--frame-border);
      background: #000;
      box-shadow: 0 18px 32px rgba(0, 0, 0, 0.45);
      max-width: 100%;
      max-height: 100%;
      image-rendering: pixelated;
    }
    #loader {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(2, 8, 23, 0.92);
      color: var(--text-white);
      font-family: 'Lucida Sans', 'Geneva', sans-serif;
      font-size: 2em;
      letter-spacing: 0.08em;
      text-transform: uppercase;
      z-index: 60;
    }
    #loader .loader-content {
      display: grid;
      justify-items: center;
      gap: 26px;
      text-align: center;
    }
    #loader .loader-text {
      font-size: 0.58em;
      letter-spacing: 0.32em;
    }
    #loader .loader-logo {
      position: relative;
      width: min(180px, 38vw);
      aspect-ratio: 1 / 1;
      display: grid;
      place-items: center;
      padding: 22px;
      border-radius: 28px;
      background:
        radial-gradient(circle at 30% 25%, rgba(255, 139, 47, 0.35), transparent 60%),
        radial-gradient(circle at 70% 75%, rgba(111, 208, 255, 0.32), transparent 58%),
        rgba(7, 17, 39, 0.85);
      filter: drop-shadow(0 22px 36px rgba(0, 0, 0, 0.55));
      overflow: hidden;
    }
    #loader .loader-logo::before {
      content: '';
      position: absolute;
      inset: 12px;
      border-radius: 22px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background:
        radial-gradient(circle, rgba(255, 255, 255, 0.05), transparent 65%),
        radial-gradient(circle at 22% 18%, rgba(255, 139, 47, 0.25), transparent 55%),
        radial-gradient(circle at 80% 70%, rgba(111, 208, 255, 0.25), transparent 60%),
        rgba(2, 8, 23, 0.75);
      pointer-events: none;
      mix-blend-mode: screen;
    }
    #loader .loader-logo::after {
      content: '';
      position: absolute;
      inset: 0;
      border-radius: 28px;
      background: radial-gradient(circle, rgba(255, 255, 255, 0.12), transparent 70%);
      opacity: 0.35;
      pointer-events: none;
    }
    #loader-canvas {
      width: 100%;
      height: 100%;
      border-radius: 18px;
      position: relative;
      z-index: 1;
      background:
        radial-gradient(circle at 40% 35%, rgba(255, 255, 255, 0.18), transparent 55%),
        radial-gradient(circle at 70% 70%, rgba(111, 208, 255, 0.28), transparent 60%),
        rgba(2, 8, 23, 0.9);
      box-shadow: inset 0 0 40px rgba(255, 139, 47, 0.18), inset 0 0 70px rgba(111, 208, 255, 0.25);
    }
    #loader .loader-halo {
      position: absolute;
      inset: 10%;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.16);
      box-shadow: 0 0 32px rgba(111, 208, 255, 0.35);
      animation: loader-halo-shift 3.6s ease-in-out infinite;
      pointer-events: none;
      z-index: 0;
    }
    @keyframes loader-halo-shift {
      0%, 100% { transform: scale(0.92) rotate(0deg); opacity: 0.65; }
      40% { transform: scale(1.05) rotate(8deg); opacity: 0.9; }
      70% { transform: scale(1.08) rotate(-6deg); opacity: 0.75; }
    }
    #loader .loader-meta {
      font-size: 0.38em;
      letter-spacing: 0.32em;
      color: rgba(255, 255, 255, 0.72);
    }
    @media (prefers-reduced-motion: reduce) {
      #loader .loader-halo {
        animation-duration: 6s !important;
      }
    }
    #loader #progress {
      color: var(--accent-orange);
    }
    #fps {
      position: fixed;
      top: 20px;
      left: 20px;
      z-index: 40;
      pointer-events: none;
    }
    #fps-monitor {
      position: relative;
      display: grid;
      row-gap: 6px;
      padding: 12px;
      background: linear-gradient(160deg, var(--navy-800), var(--navy-700));
      border: 1px solid var(--frame-border);
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
      min-width: 180px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-white);
    }
    #fps-monitor .panel-title {
      display: flex;
      align-items: center;
      gap: 10px;
      font-size: 0.7rem;
      color: var(--accent-orange);
      letter-spacing: 0.18em;
    }
    #fps-monitor .panel-title .label {
      color: var(--text-white);
      letter-spacing: 0.2em;
    }
    #fps-monitor .fps-readout {
      display: flex;
      align-items: baseline;
      gap: 8px;
      font-family: 'Lucida Console', 'Courier New', monospace;
      color: var(--text-white);
    }
    #fps-monitor .fps-label {
      font-size: 0.65rem;
      color: var(--accent-orange);
    }
    #fps-monitor .fps-value {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--text-white);
      min-width: 3.6em;
      text-shadow: 0 0 14px rgba(255, 139, 47, 0.3);
    }
    #fps-monitor canvas {
      width: 100%;
      height: 48px;
      border: 1px solid var(--frame-border);
      background: var(--navy-900);
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
    }
    #control-ui {
      position: fixed;
      top: 14px;
      right: 14px;
      background: rgba(7, 17, 39, 0.55);
      border: 1px solid var(--frame-border);
      box-shadow: inset 0 0 0 1px var(--frame-border-light), 0 12px 26px rgba(0, 0, 0, 0.38);
      padding: 14px 16px 18px;
      display: grid;
      row-gap: 12px;
      width: min(220px, 78vw);
      z-index: 34;
      font-family: 'Lucida Sans', 'Geneva', sans-serif;
      color: var(--text-white);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      backdrop-filter: blur(14px);
      transition: background 0.35s ease, border-color 0.35s ease;
    }
    #control-ui.folded {
      background: rgba(7, 17, 39, 0.38);
      border-color: rgba(255, 255, 255, 0.12);
    }
    #control-ui .ui-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
    }
    #control-ui h2 {
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.68rem;
      color: var(--accent-orange);
      letter-spacing: 0.2em;
    }
    #control-ui h2 span:last-child {
      color: var(--text-white);
      letter-spacing: 0.24em;
    }
    #ui-fold-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(255, 255, 255, 0.24);
      background: rgba(2, 8, 23, 0.35);
      color: var(--text-white);
      font-size: 0.52rem;
      letter-spacing: 0.16em;
      padding: 5px 10px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    #ui-fold-btn:hover {
      background: rgba(255, 139, 47, 0.25);
      border-color: rgba(255, 139, 47, 0.6);
      transform: translateY(-1px);
    }
    #ui-fold-btn:active {
      transform: translateY(1px);
    }
    #ui-fold-btn .fold-icon {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.35s ease;
    }
    #ui-fold-btn .fold-icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
      transform-origin: center;
      transition: transform 0.35s ease;
      animation: fold-pulse 2.4s ease-in-out infinite;
    }
    #control-ui.folded #ui-fold-btn .fold-icon svg {
      transform: rotate(-90deg);
    }
    .fold-body {
      display: grid;
      row-gap: 10px;
      max-height: 340px;
      overflow: hidden;
      transition: max-height 0.4s ease, opacity 0.3s ease;
    }
    #control-ui.folded .fold-body {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .ui-icon {
      width: 22px;
      height: 22px;
      display: grid;
      place-items: center;
      perspective: 400px;
    }
    .ui-icon svg {
      width: 100%;
      height: 100%;
      fill: var(--text-white);
      transform-origin: center;
      animation: icon-spin 6s linear infinite;
      filter: drop-shadow(0 0 6px rgba(255, 139, 47, 0.35));
    }
    @keyframes icon-spin {
      0% { transform: rotateX(0deg) rotateY(0deg); }
      50% { transform: rotateX(18deg) rotateY(180deg); }
      100% { transform: rotateX(0deg) rotateY(360deg); }
    }
    @keyframes fold-pulse {
      0%, 100% { opacity: 0.8; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.12); }
    }
    @keyframes vhs-warp {
      0% { transform: translate3d(0, 0, 0) skewX(0deg); filter: saturate(1.1) contrast(1.05); }
      20% { transform: translate3d(-4px, 0, 0) skewX(-1.5deg); filter: saturate(1.4) contrast(1.25); }
      45% { transform: translate3d(3px, 0, 0) skewX(1deg); filter: saturate(1.25) contrast(1.18); }
      70% { transform: translate3d(-2px, 0, 0) skewX(-0.6deg); filter: saturate(1.15) contrast(1.12); }
      100% { transform: translate3d(0, 0, 0) skewX(0deg); filter: saturate(1.1) contrast(1.05); }
    }
    @keyframes vhs-noise {
      0% { opacity: 0.55; transform: translate3d(-8px, 0, 0); }
      25% { opacity: 0.7; transform: translate3d(6px, 0, 0); }
      50% { opacity: 0.45; transform: translate3d(-3px, 0, 0); }
      75% { opacity: 0.35; transform: translate3d(2px, 0, 0); }
      100% { opacity: 0; transform: translate3d(0, 0, 0); }
    }
    @keyframes vhs-color {
      0% { opacity: 0.45; transform: translate3d(2px, 0, 0); }
      30% { opacity: 0.35; transform: translate3d(-3px, 0, 0); }
      60% { opacity: 0.2; transform: translate3d(2px, 0, 0); }
      100% { opacity: 0; transform: translate3d(0, 0, 0); }
    }
    #canvas-wrap .vhs-line {
      --shift-start: 0px;
      --shift-mid: 0px;
      --shift-end: 0px;
      --shift-clear: 0px;
      --skew-start: 0deg;
      --skew-mid: 0deg;
      --skew-end: 0deg;
      --line-opacity: 0.6;
      --line-brightness: 1.1;
      --line-hue: 0deg;
      position: absolute;
      left: -8%;
      width: 116%;
      top: 50%;
      height: 8px;
      pointer-events: none;
      background:
        linear-gradient(90deg, rgba(255, 0, 90, 0.25), rgba(0, 240, 255, 0.32)),
        repeating-linear-gradient(
          90deg,
          rgba(255, 255, 255, 0.75) 0px,
          rgba(255, 255, 255, 0.75) 6px,
          rgba(255, 255, 255, 0.05) 6px,
          rgba(255, 255, 255, 0.05) 12px
        );
      background-size: 180px 100%, 20px 100%;
      mix-blend-mode: screen;
      box-shadow: 0 0 24px rgba(255, 139, 47, 0.4);
      opacity: 0;
      transform: translateX(var(--shift-start)) skewX(var(--skew-start));
      animation: vhs-line-burst 0.55s cubic-bezier(0.25, 0.8, 0.45, 1) forwards;
      filter: hue-rotate(var(--line-hue)) saturate(1.6) brightness(var(--line-brightness));
    }
    #canvas-wrap .vhs-line::before,
    #canvas-wrap .vhs-line::after {
      content: '';
      position: absolute;
      inset: 0;
      pointer-events: none;
    }
    #canvas-wrap .vhs-line::before {
      background:
        repeating-linear-gradient(
          0deg,
          rgba(255, 139, 47, 0.45) 0px,
          rgba(255, 139, 47, 0.45) 2px,
          rgba(0, 0, 0, 0) 2px,
          rgba(0, 0, 0, 0) 4px
        );
      opacity: 0.8;
    }
    #canvas-wrap .vhs-line::after {
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.4), transparent);
      mix-blend-mode: overlay;
      opacity: 0.5;
    }
    #canvas-wrap .vhs-line--cluster {
      box-shadow: 0 0 28px rgba(0, 240, 255, 0.32);
    }
    #canvas-wrap .vhs-line--cluster::before {
      background:
        repeating-linear-gradient(
          0deg,
          rgba(0, 240, 255, 0.35) 0px,
          rgba(0, 240, 255, 0.35) var(--cluster-thickness, 3px),
          rgba(0, 0, 0, 0) var(--cluster-thickness, 3px),
          rgba(0, 0, 0, 0) calc(var(--cluster-thickness, 3px) * 2)
        );
      opacity: 0.9;
    }
    @keyframes vhs-line-burst {
      0% {
        opacity: 0;
        transform: translateX(var(--shift-start)) skewX(var(--skew-start));
      }
      14% {
        opacity: calc(var(--line-opacity) + 0.2);
      }
      38% {
        opacity: var(--line-opacity);
        transform: translateX(var(--shift-mid)) skewX(var(--skew-mid));
      }
      70% {
        opacity: calc(var(--line-opacity) * 0.45);
        transform: translateX(var(--shift-end)) skewX(var(--skew-end));
      }
      100% {
        opacity: 0;
        transform: translateX(var(--shift-clear)) skewX(0deg);
      }
    }
    #resolution-display {
      font-size: 0.74rem;
      font-weight: 700;
      color: var(--text-white);
      text-shadow: 0 0 12px rgba(255, 139, 47, 0.4);
    }
    label[for="resolution-select"] {
      font-size: 0.62rem;
      color: var(--text-white);
    }
    .select-wrap {
      position: relative;
    }
    .select-wrap::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 12px;
      width: 8px;
      height: 8px;
      border-right: 2px solid var(--accent-orange);
      border-bottom: 2px solid var(--accent-orange);
      transform: translateY(-50%) rotate(45deg);
      pointer-events: none;
    }
    #resolution-select {
      width: 100%;
      padding: 6px 28px 6px 10px;
      border-radius: 0;
      border: 1px solid var(--frame-border);
      background: rgba(2, 8, 23, 0.65);
      color: var(--text-white);
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      appearance: none;
      outline: none;
      box-shadow: inset 0 0 0 1px var(--frame-border-light);
    }
    #resolution-select:focus {
      border-color: var(--accent-orange);
      box-shadow: 0 0 0 1px rgba(255, 139, 47, 0.35), 0 0 0 4px rgba(255, 139, 47, 0.15);
    }
    #fullscreen-btn {
      position: fixed;
      left: 50%;
      bottom: 32px;
      transform: translateX(-50%);
      padding: 8px 26px;
      background: linear-gradient(160deg, rgba(2, 8, 23, 0.85), rgba(11, 26, 53, 0.85));
      border: 1px solid var(--frame-border);
      color: var(--text-white);
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.12em;
      cursor: pointer;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.45);
      text-transform: uppercase;
      transition: transform 0.15s ease;
      z-index: 48;
      display: none;
      border-radius: 999px;
      align-items: center;
      justify-content: center;
      gap: 10px;
      backdrop-filter: blur(10px);
    }
    #fullscreen-btn:hover {
      transform: translateX(-50%) translateY(-2px);
    }
    #fullscreen-btn:active {
      transform: translateX(-50%) translateY(2px);
      box-shadow: 0 6px 12px rgba(0, 0, 0, 0.55);
    }
    #control-pad {
      position: fixed;
      bottom: 22px;
      right: 22px;
      display: grid;
      grid-template-columns: repeat(3, 44px);
      grid-template-rows: repeat(3, 44px);
      gap: 8px;
      z-index: 35;
    }
    #control-pad button,
    #control-pad span {
      width: 44px;
      height: 44px;
      border-radius: 10px;
      border: 1px solid var(--frame-border);
      background: rgba(2, 8, 23, 0.72);
      color: var(--text-white);
      font-size: 16px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      box-shadow: 0 10px 16px rgba(0, 0, 0, 0.42);
      transition: transform 0.1s ease, box-shadow 0.1s ease;
      text-shadow: 0 0 10px rgba(255, 139, 47, 0.35);
    }
    #control-pad span {
      cursor: default;
      opacity: 0;
      box-shadow: none;
      border: none;
      pointer-events: none;
    }
    #control-pad button:active {
      transform: translateY(2px);
      box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6);
    }
    @media (max-width: 720px) {
      #control-pad {
        right: 14px;
        bottom: 14px;
        grid-template-columns: repeat(3, 40px);
        grid-template-rows: repeat(3, 40px);
        gap: 6px;
      }
      #control-pad button,
      #control-pad span {
        width: 40px;
        height: 40px;
      }
      #control-ui {
        right: 10px;
        top: 10px;
        padding: 12px 12px 14px;
        width: min(200px, 82vw);
      }
      #ui-fold-btn {
        padding: 4px 8px;
        letter-spacing: 0.12em;
      }
    }
    #hud-overlay {
      position: fixed;
      top: 14px;
      left: 50%;
      transform: translateX(-50%);
      display: grid;
      gap: 6px;
      padding: 12px 16px;
      background: rgba(2, 8, 23, 0.42);
      border: 1px solid rgba(255, 255, 255, 0.16);
      box-shadow: inset 0 0 0 1px rgba(255, 255, 255, 0.08), 0 12px 24px rgba(0, 0, 0, 0.35);
      font-family: 'Lucida Console', 'Courier New', monospace;
      font-size: 0.64rem;
      color: var(--text-white);
      letter-spacing: 0.12em;
      text-transform: uppercase;
      min-width: min(320px, 90vw);
      z-index: 42;
      backdrop-filter: blur(12px);
      pointer-events: auto;
    }
    #hud-overlay .hud-title {
      display: grid;
      gap: 2px;
      color: var(--accent-orange);
      letter-spacing: 0.18em;
      font-size: 0.6rem;
      text-align: center;
      pointer-events: none;
    }
    #hud-overlay .hud-title span:last-child {
      color: rgba(255, 255, 255, 0.78);
      letter-spacing: 0.16em;
    }
    #hud-overlay .hud-line {
      pointer-events: none;
    }
    .hud-render-modes {
      display: grid;
      grid-auto-flow: column;
      gap: 8px;
      justify-content: center;
      pointer-events: auto;
    }
    .hud-render-modes button {
      padding: 6px 10px;
      background: rgba(2, 8, 23, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.24);
      color: rgba(255, 255, 255, 0.82);
      font-family: 'Lucida Console', 'Courier New', monospace;
      font-size: 0.56rem;
      letter-spacing: 0.12em;
      text-transform: uppercase;
      cursor: pointer;
      transition: border-color 0.2s ease, background 0.2s ease, color 0.2s ease;
    }
    .hud-render-modes button:hover {
      border-color: var(--accent-orange);
    }
    .hud-render-modes button:focus-visible {
      outline: 2px solid var(--accent-orange);
      outline-offset: 2px;
    }
    .hud-render-modes button.is-active {
      border-color: var(--accent-orange);
      background: rgba(255, 139, 47, 0.25);
      color: var(--text-white);
      text-shadow: 0 0 8px rgba(255, 139, 47, 0.35);
    }
    #hud-overlay .hud-line {
      display: flex;
      justify-content: space-between;
      gap: 18px;
    }
    #hud-overlay .hud-value {
      color: rgba(255, 255, 255, 0.86);
    }
    #console-dock {
      position: fixed;
      bottom: 0;
      left: 0;
      width: min(520px, 92vw);
      max-height: 220px;
      display: flex;
      flex-direction: column;
      padding: 12px;
      gap: 8px;
      background: rgba(2, 8, 23, 0.55);
      border: 1px solid rgba(255, 255, 255, 0.14);
      box-shadow: 0 -8px 32px rgba(0, 0, 0, 0.55);
      font-family: 'Lucida Console', 'Courier New', monospace;
      font-size: 0.7rem;
      letter-spacing: 0.08em;
      overflow: hidden;
      backdrop-filter: blur(10px);
      z-index: 36;
    }
    #console-dock .console-headline {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
      font-size: 0.62rem;
      color: var(--accent-orange);
      text-transform: uppercase;
      letter-spacing: 0.16em;
    }
    #console-dock .console-actions {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    #console-dock .console-status {
      color: rgba(255, 255, 255, 0.72);
      letter-spacing: 0.12em;
    }
    #console-fold-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 9px;
      border: 1px solid rgba(255, 255, 255, 0.22);
      background: rgba(2, 8, 23, 0.45);
      color: var(--text-white);
      font-family: inherit;
      font-size: 0.52rem;
      letter-spacing: 0.14em;
      text-transform: uppercase;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease;
    }
    #console-fold-btn:hover {
      background: rgba(255, 139, 47, 0.2);
      border-color: rgba(255, 139, 47, 0.55);
      transform: translateY(-1px);
    }
    #console-fold-btn:active {
      transform: translateY(1px);
    }
    #console-fold-btn .fold-icon {
      width: 14px;
      height: 14px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.35s ease;
    }
    #console-fold-btn .fold-icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
      transform-origin: center;
      transition: transform 0.35s ease;
    }
    #console-dock.folded #console-fold-btn .fold-icon svg {
      transform: rotate(-90deg);
    }
    #console-dock #console-log {
      position: relative;
      inset: auto;
      width: 100%;
      max-height: 160px;
      padding: 8px 12px;
      overflow-y: auto;
      background: rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      pointer-events: auto;
      transition: max-height 0.35s ease, opacity 0.3s ease;
    }
    #console-dock #console-log .console-line {
      margin-bottom: 4px;
      white-space: pre-wrap;
    }
    #console-dock.folded #console-log {
      max-height: 0;
      opacity: 0;
      padding-top: 0;
      padding-bottom: 0;
      border-color: rgba(255, 255, 255, 0.06);
      pointer-events: none;
      overflow: hidden;
    }
    body.is-mobile {
      --hud-offset: 56px;
    }
    body.is-mobile #fullscreen-btn {
      top: 14px;
      right: 14px;
      bottom: auto;
      left: auto;
      transform: none;
      padding: 8px 18px;
      gap: 8px;
      font-size: 0.58rem;
      letter-spacing: 0.14em;
      box-shadow: 0 12px 22px rgba(0, 0, 0, 0.45);
    }
    body.is-mobile #fullscreen-btn::before {
      content: '';
      width: 12px;
      height: 12px;
      border: 2px solid currentColor;
      border-radius: 3px;
      transform: translateZ(0);
    }
    body.is-mobile #control-ui {
      top: 110px;
      right: 14px;
      left: 14px;
      width: auto;
      padding: 12px 14px 16px;
      border-radius: 14px;
      background: rgba(7, 17, 39, 0.55);
      row-gap: 10px;
    }
    body.is-mobile #control-ui.folded {
      background: rgba(7, 17, 39, 0.45);
    }
    body.is-mobile #control-ui h2 {
      font-size: 0.62rem;
    }
    body.is-mobile #hud-overlay {
      top: calc(14px + var(--hud-offset));
      width: calc(100% - 28px);
      min-width: 0;
      font-size: 0.56rem;
      gap: 4px;
      padding: 10px 14px;
    }
    body.is-mobile #hud-overlay .hud-title {
      font-size: 0.52rem;
    }
    body.is-mobile #hud-overlay .hud-title span:last-child {
      display: none;
    }
    body.is-mobile .hud-render-modes {
      grid-auto-flow: row;
      gap: 6px;
    }
    body.is-mobile .hud-render-modes button {
      padding: 5px 8px;
      font-size: 0.52rem;
    }
    body.is-mobile #control-pad {
      right: 14px;
      bottom: 108px;
      grid-template-columns: repeat(3, 36px);
      grid-template-rows: repeat(3, 36px);
      gap: 6px;
    }
    body.is-mobile #control-pad button,
    body.is-mobile #control-pad span {
      width: 36px;
      height: 36px;
      font-size: 1.1rem;
    }
    body.is-mobile #fps {
      top: 14px;
      left: 14px;
      right: auto;
      bottom: auto;
    }
    body.is-mobile #console-dock {
      bottom: 14px;
      left: 14px;
      right: auto;
      width: min(320px, 74vw);
      max-height: 42vh;
      padding: 10px 12px;
      border-radius: 16px;
      gap: 6px;
      font-size: 0.6rem;
    }
    body.is-mobile #console-dock .console-headline {
      font-size: 0.54rem;
    }
    body.is-mobile #console-dock #console-log {
      max-height: 28vh;
    }
    body.is-mobile #console-dock.folded {
      width: auto;
      padding: 8px 12px;
      border-radius: 999px;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      box-shadow: 0 10px 22px rgba(0, 0, 0, 0.5);
    }
    body.is-mobile #console-dock.folded #console-status,
    body.is-mobile #console-dock.folded #console-log {
      display: none;
    }
  </style>
</head>
<body>
  <div id="scene-shell">
    <div id="canvas-wrap"></div>
  </div>
  <div id="control-ui">
    <div class="ui-header">
      <h2>
        <span class="ui-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="presentation">
            <polygon points="12,2 22,7 22,17 12,22 2,17 2,7" opacity="0.4"></polygon>
            <polygon points="12,4.5 19.5,8.2 19.5,15.8 12,19.5 4.5,15.8 4.5,8.2" fill="currentColor"></polygon>
            <path d="M9 10h2v2H9zm4 0h2v2h-2zm-2 3h2v2h-2z" fill="var(--accent-orange)"></path>
          </svg>
        </span>
        <span>Games Mode</span>
      </h2>
        <button id="ui-fold-btn" type="button" aria-label="Collapse control panel" aria-expanded="true" aria-controls="ui-foldable">
          <span class="fold-icon" aria-hidden="true">
            <svg viewBox="0 0 16 16" role="presentation" focusable="false">
              <path d="M4.2 2.8a1 1 0 0 1 1.6 0l4 5a1 1 0 0 1 0 1.2l-4 5a1 1 0 0 1-1.6-1.2L7.7 8 4.2 4a1 1 0 0 1 0-1.2z"></path>
            </svg>
          </span>
        </button>
    </div>
    <div id="ui-foldable" class="fold-body">
      <div id="resolution-display">—</div>
      <label for="resolution-select">Resolution</label>
      <div class="select-wrap">
        <select id="resolution-select" aria-label="Resolution selector">
        <option value="256x144">144p — 256 × 144</option>
        <option value="426x240">240p — 426 × 240</option>
        <option value="640x360">360p — 640 × 360</option>
        <option value="854x480">480p — 854 × 480</option>
        <option value="1280x720" selected>720p — 1280 × 720</option>
        <option value="1920x1080">1080p — 1920 × 1080</option>
        <option value="2560x1440">1440p — 2560 × 1440</option>
        <option value="3840x2160">2160p — 3840 × 2160</option>
        </select>
      </div>
    </div>
  </div>
  <button id="fullscreen-btn" type="button">Enter Fullscreen</button>
  <div id="control-pad">
    <span></span>
    <button data-key="ArrowUp" aria-label="Move forward">▲</button>
    <span></span>
    <button data-key="ArrowLeft" aria-label="Turn left">◀</button>
    <span></span>
    <button data-key="ArrowRight" aria-label="Turn right">▶</button>
    <span></span>
    <button data-key="ArrowDown" aria-label="Move backward">▼</button>
    <span></span>
  </div>
  <div id="hud-overlay" aria-live="polite">
    <div class="hud-title">
      <span>Terrain Telemetry Uplink // Horizon Sweep</span>
      <span>Orbital Metrics Stream — Vectors Locked</span>
    </div>
    <div class="hud-render-modes" role="group" aria-label="Rendering mode">
      <button type="button" class="render-mode-btn is-active" data-render-mode="default">Default</button>
      <button type="button" class="render-mode-btn" data-render-mode="wire">Wired Vectors</button>
    </div>
    <div class="hud-line"><span>Position</span><span class="hud-value" data-hud="position">0, 0, 0</span></div>
    <div class="hud-line"><span>Heading</span><span class="hud-value" data-hud="heading">0° / 0°</span></div>
    <div class="hud-line"><span>Chunk</span><span class="hud-value" data-hud="chunk">0, 0</span></div>
    <div class="hud-line"><span>Speed</span><span class="hud-value" data-hud="speed">0 m/s</span></div>
  </div>
  <div id="fps"></div>
  <div id="console-dock" class="folded">
    <div class="console-headline">
      <span class="console-title">Console Log</span>
      <div class="console-actions">
        <span id="console-status" class="console-status">Folded</span>
        <button id="console-fold-btn" type="button" aria-label="Expand console log" aria-expanded="false" aria-controls="console-log">
          <span class="fold-icon" aria-hidden="true">
            <svg viewBox="0 0 16 16" role="presentation" focusable="false">
              <path d="M4.2 2.8a1 1 0 0 1 1.6 0l4 5a1 1 0 0 1 0 1.2l-4 5a1 1 0 0 1-1.6-1.2L7.7 8 4.2 4a1 1 0 0 1 0-1.2z"></path>
            </svg>
          </span>
        </button>
      </div>
    </div>
    <div id="console-log" role="log" aria-live="polite"></div>
  </div>
  <div id="loader">
    <div class="loader-content">
      <div class="loader-text">Loading <span id="progress">0%</span></div>
      <div class="loader-logo" aria-hidden="true">
        <div class="loader-halo"></div>
        <canvas id="loader-canvas" width="220" height="220" aria-hidden="true"></canvas>
      </div>
      <div class="loader-meta">© 2025 Cyborgs Dream</div>
    </div>
  </div>
  <script type="module">
  import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';
  import { initConsoleLogs } from '../../shared/consolelogs.js';

  const consoleLogEl = document.getElementById('console-log');
  const consoleDock = document.getElementById('console-dock');
  const consoleFoldBtn = document.getElementById('console-fold-btn');
  const consoleStatus = document.getElementById('console-status');
  let setConsoleFolded = null;

  initConsoleLogs({ container: consoleLogEl, removeAfter: null });
  console.log('Console dock folded for minimal footprint.');

  if (consoleFoldBtn && consoleDock) {
    const syncConsoleFold = (folded) => {
      consoleDock.classList.toggle('folded', folded);
      consoleFoldBtn.setAttribute('aria-expanded', String(!folded));
      if (consoleStatus) {
        consoleStatus.textContent = folded ? 'Folded' : 'Expanded';
      }
      const label = folded ? 'Expand console log' : 'Collapse console log';
      consoleFoldBtn.setAttribute('aria-label', label);
    };
    setConsoleFolded = syncConsoleFold;
    consoleFoldBtn.addEventListener('click', () => {
      const next = !consoleDock.classList.contains('folded');
      syncConsoleFold(next);
      console.log(`Console log ${next ? 'folded' : 'expanded'}.`);
    });
    syncConsoleFold(consoleDock.classList.contains('folded'));
  }

  const hudElements = {
    position: document.querySelector('[data-hud="position"]'),
    heading: document.querySelector('[data-hud="heading"]'),
    chunk: document.querySelector('[data-hud="chunk"]'),
    speed: document.querySelector('[data-hud="speed"]')
  };
  console.log('HUD telemetry overlay online.');
  console.log('Compact terrain interface scaling engaged.');

  const renderModeButtons = document.querySelectorAll('[data-render-mode]');
  const renderModeDescriptions = {
    default: 'default shading',
    wire: 'wired vectors'
  };
  let currentRenderMode = 'default';
  const wireTerrainColor = new THREE.Color(0x8fd6ff);
  const wireBlockColor = new THREE.Color(0xffb86b);
  let defaultTerrainColor = null;

  const RESOLUTIONS = [
    { label: '144p', width: 256, height: 144 },
    { label: '240p', width: 426, height: 240 },
    { label: '360p', width: 640, height: 360 },
    { label: '480p', width: 854, height: 480 },
    { label: '720p', width: 1280, height: 720 },
    { label: '1080p', width: 1920, height: 1080 },
    { label: '1440p', width: 2560, height: 1440 },
    { label: '2160p', width: 3840, height: 2160 }
  ];

  function initLoaderVisualizer(canvas) {
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(32, 1, 0.1, 100);
    camera.position.set(0, 0, 8.5);

    const group = new THREE.Group();
    scene.add(group);

    const shellGeometry = new THREE.IcosahedronGeometry(2.6, 1);
    const faceMaterial = new THREE.MeshPhongMaterial({
      color: 0x1480c3,
      emissive: 0x07162b,
      specular: 0x7ad1ff,
      shininess: 46,
      transparent: true,
      opacity: 0.68,
      side: THREE.DoubleSide,
      depthWrite: false
    });
    faceMaterial.onBeforeCompile = (shader) => {
      shader.vertexShader = shader.vertexShader
        .replace('#include <common>', `#include <common>\nvarying vec3 vLoaderNormal;`)
        .replace('#include <beginnormal_vertex>', `#include <beginnormal_vertex>\n  vLoaderNormal = normalize( normalMatrix * objectNormal );`);
      shader.fragmentShader = shader.fragmentShader
        .replace('#include <common>', `#include <common>\nvarying vec3 vLoaderNormal;`)
        .replace('#include <dithering_fragment>', `#include <dithering_fragment>\n  vec3 viewDir = normalize(vViewPosition);\n  float fresnel = pow(1.0 - abs(dot(normalize(vLoaderNormal), viewDir)), 1.4);\n  gl_FragColor.rgb = mix(gl_FragColor.rgb, vec3(0.92, 0.98, 1.0), fresnel * 0.45);`);
    };
    const shellMesh = new THREE.Mesh(shellGeometry, faceMaterial);
    group.add(shellMesh);

    const wireMaterial = new THREE.LineBasicMaterial({
      color: 0xffb86b,
      transparent: true,
      opacity: 0.82
    });
    const wire = new THREE.LineSegments(new THREE.WireframeGeometry(shellGeometry), wireMaterial);
    wire.renderOrder = 1;
    group.add(wire);

    const coreGeometry = new THREE.IcosahedronGeometry(1.35, 0);
    const coreMaterial = new THREE.MeshBasicMaterial({
      color: 0x0b2748,
      transparent: true,
      opacity: 0.45
    });
    const core = new THREE.Mesh(coreGeometry, coreMaterial);
    group.add(core);

    const ambient = new THREE.AmbientLight(0x1a2744, 0.85);
    scene.add(ambient);
    const keyLight = new THREE.DirectionalLight(0xf0f7ff, 1.25);
    keyLight.position.set(4, 5, 6);
    scene.add(keyLight);
    const fillLight = new THREE.DirectionalLight(0x3fa8ff, 0.55);
    fillLight.position.set(-3, -4, -5);
    scene.add(fillLight);

    const clock = new THREE.Clock();
    let rafId = null;
    let running = true;
    const baseColor = new THREE.Color(0x1480c3);
    const accentColor = new THREE.Color(0xffcba4);

    const resizeIfNeeded = () => {
      const width = canvas.clientWidth;
      const height = canvas.clientHeight;
      if (width === 0 || height === 0) return;
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      if (canvas.width !== Math.round(width * dpr) || canvas.height !== Math.round(height * dpr)) {
        renderer.setPixelRatio(dpr);
        renderer.setSize(width, height, false);
        camera.aspect = width / height;
        camera.updateProjectionMatrix();
      }
    };

    const render = () => {
      if (!running) return;
      rafId = requestAnimationFrame(render);
      resizeIfNeeded();
      const t = clock.getElapsedTime();
      group.rotation.x = t * 0.52;
      group.rotation.y = t * 0.68;
      group.rotation.z = Math.sin(t * 0.37) * 0.4;

      const pulse = (Math.sin(t * 1.6) + 1) * 0.5;
      const mixStrength = 0.25 + pulse * 0.35;
      shellMesh.material.opacity = 0.52 + pulse * 0.2;
      wireMaterial.opacity = 0.7 + pulse * 0.2;
      core.scale.setScalar(0.92 + pulse * 0.08);
      core.material.opacity = 0.35 + pulse * 0.25;
      shellMesh.material.color.copy(baseColor).lerp(accentColor, mixStrength * 0.4);

      renderer.render(scene, camera);
    };
    render();

    const handleResize = () => resizeIfNeeded();
    window.addEventListener('resize', handleResize);

    return () => {
      running = false;
      if (rafId) cancelAnimationFrame(rafId);
      window.removeEventListener('resize', handleResize);
      shellGeometry.dispose();
      coreGeometry.dispose();
      faceMaterial.dispose();
      wireMaterial.dispose();
      coreMaterial.dispose();
      renderer.dispose();
    };
  }

  const loaderEl = document.getElementById('loader');
  const progressEl = document.getElementById('progress');
  function setProgress(p){ progressEl.textContent = Math.round(p) + '%'; }
  const loaderCanvas = document.getElementById('loader-canvas');
  let disposeLoaderVisual = () => {};
  if (loaderCanvas) {
    disposeLoaderVisual = initLoaderVisualizer(loaderCanvas);
  }

  const fpsHolder = document.getElementById('fps');

  class FpsMonitor {
    constructor(container) {
      this.dom = document.createElement('div');
      this.dom.id = 'fps-monitor';

      const iconMarkup = `
        <span class="ui-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="presentation">
            <polygon points="12,2 22,7 22,17 12,22 2,17 2,7" opacity="0.35"></polygon>
            <polygon points="12,4.5 19.5,8.2 19.5,15.8 12,19.5 4.5,15.8 4.5,8.2" fill="currentColor"></polygon>
            <path d="M8 15h2.5V9H8zm5-6v8h-2.5V9zm2.5 0H18v10h-2.5z" fill="var(--accent-orange)"></path>
          </svg>
        </span>`;

      this.titleEl = document.createElement('div');
      this.titleEl.className = 'panel-title';
      this.titleEl.innerHTML = `${iconMarkup}<span class="label">Performance</span>`;
      this.dom.appendChild(this.titleEl);

      this.styles = getComputedStyle(document.documentElement);

      this.readoutEl = document.createElement('div');
      this.readoutEl.className = 'fps-readout';

      this.labelEl = document.createElement('div');
      this.labelEl.className = 'fps-label';
      this.labelEl.textContent = 'fps';

      this.valueEl = document.createElement('div');
      this.valueEl.className = 'fps-value';
      this.valueEl.textContent = '000';

      this.readoutEl.appendChild(this.labelEl);
      this.readoutEl.appendChild(this.valueEl);

      this.graphCanvas = document.createElement('canvas');
      this.graphCanvas.width = 160;
      this.graphCanvas.height = 60;
      this.graphCanvas.className = 'fps-graph';
      this.graphCanvas.setAttribute('aria-hidden', 'true');
      this.graphCtx = this.graphCanvas.getContext('2d');

      this.maxSamples = this.graphCanvas.width;
      this.samples = new Array(this.maxSamples).fill(0);
      this.referenceFps = 120;

      this.sampleWindow = 250;
      this.frameCount = 0;
      this.lastSample = performance.now();
      this.smoothed = 0;

      this.dom.appendChild(this.readoutEl);
      this.dom.appendChild(this.graphCanvas);
      this.drawGraph();
      container.appendChild(this.dom);
    }

    begin() {}

    end() {
      const now = performance.now();
      this.frameCount += 1;
      if (now - this.lastSample >= this.sampleWindow) {
        const elapsed = now - this.lastSample;
        const fps = (this.frameCount * 1000) / elapsed;
        this.frameCount = 0;
        this.lastSample = now;
        this.update(fps);
      }
    }

    update(rawFps) {
      const fps = Math.max(0, rawFps);
      this.smoothed = this.smoothed === 0 ? fps : (this.smoothed * 0.7 + fps * 0.3);
      const rounded = Math.max(0, Math.round(this.smoothed));
      this.valueEl.textContent = `${rounded.toString().padStart(3, '0')}`;
      this.samples.push(fps);
      if (this.samples.length > this.maxSamples) {
        this.samples.shift();
      }
      this.drawGraph();
    }

    drawGraph() {
      const ctx = this.graphCtx;
      const width = this.graphCanvas.width;
      const height = this.graphCanvas.height;
      ctx.clearRect(0, 0, width, height);

      const background = this.styles.getPropertyValue('--navy-900').trim() || '#020817';
      const gridColor = this.styles.getPropertyValue('--graph-grid').trim() || 'rgba(255, 255, 255, 0.18)';
      const fillColor = this.styles.getPropertyValue('--graph-fill').trim() || 'rgba(255, 139, 47, 0.18)';
      const lineColor = this.styles.getPropertyValue('--graph-line').trim() || '#ff8b2f';

      ctx.fillStyle = background;
      ctx.fillRect(0, 0, width, height);

      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      const gridLines = 4;
      for (let i = 1; i < gridLines; i++) {
        const y = Math.round((height / gridLines) * i) + 0.5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      const highestSample = this.samples.reduce((max, value) => Math.max(max, value), 0);
      const scaleMax = Math.max(this.referenceFps, highestSample, 30);
      const verticalPadding = 2;
      const usableHeight = height - verticalPadding * 2;

      ctx.beginPath();
      ctx.moveTo(0, height - verticalPadding);
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(width, height - verticalPadding);
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();

      ctx.beginPath();
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  const fpsMonitor = new FpsMonitor(fpsHolder);

  const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setPixelRatio(1);
  const canvasWrap = document.getElementById('canvas-wrap');
  canvasWrap.appendChild(renderer.domElement);
  renderer.domElement.style.cursor = 'grab';
  renderer.domElement.style.touchAction = 'none';
  renderer.domElement.tabIndex = 0;
  renderer.domElement.setAttribute('aria-label', 'Interactive terrain viewport');

  const scene = new THREE.Scene();
  const fogColor = new THREE.Color(0x020817);
  scene.fog = new THREE.Fog(fogColor, 380, 760);
  renderer.setClearColor(fogColor);
  scene.add(new THREE.AmbientLight(0x666666));
  const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
  sunLight.position.set(260, 220, -500);
  scene.add(sunLight);
  scene.add(sunLight.target);
  const sunLightOffset = new THREE.Vector3(260, 220, -500);
  const sunLightDesired = new THREE.Vector3();
  const sunLightTargetDesired = new THREE.Vector3();

  function createSkyTexture(){
    const skyCanvas = document.createElement('canvas');
    skyCanvas.width = 96;
    skyCanvas.height = 48;
    const ctx = skyCanvas.getContext('2d');

    const palette = ['#23395d', '#2f4b7a', '#3f5f9d', '#6d8fce', '#9cc8ff'];

    ctx.fillStyle = palette[0];
    ctx.fillRect(0, 0, skyCanvas.width, skyCanvas.height);

    const bands = [
      { color: palette[1], height: 12 },
      { color: palette[2], height: 10 },
      { color: palette[3], height: 10 },
      { color: palette[4], height: 8 }
    ];

    let y = skyCanvas.height;
    for (const band of bands) {
      y -= band.height;
      ctx.fillStyle = band.color;
      ctx.fillRect(0, y, skyCanvas.width, band.height);
    }

    const cloudBlocks = [
      { x: 6, y: 8, w: 18, h: 8, color: '#bad8ff' },
      { x: 32, y: 12, w: 22, h: 10, color: '#cfe4ff' },
      { x: 60, y: 6, w: 18, h: 8, color: '#b0d0ff' },
      { x: 14, y: 20, w: 20, h: 9, color: '#d9ecff' },
      { x: 48, y: 24, w: 24, h: 10, color: '#c4dcff' },
      { x: 72, y: 18, w: 18, h: 8, color: '#d2e7ff' }
    ];

    cloudBlocks.forEach(block => {
      ctx.fillStyle = block.color;
      ctx.fillRect(block.x, block.y, block.w, block.h);
      ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
      ctx.fillRect(block.x, block.y, Math.floor(block.w * 0.5), Math.ceil(block.h * 0.5));
    });

    const texture = new THREE.CanvasTexture(skyCanvas);
    texture.generateMipmaps = false;
    texture.magFilter = THREE.NearestFilter;
    texture.minFilter = THREE.NearestFilter;
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    return texture;
  }

  function createSkyCeilingTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 128;
    canvas.height = 128;
    const ctx = canvas.getContext('2d');
    const gradient = ctx.createRadialGradient(64, 64, 12, 64, 64, 70);
    gradient.addColorStop(0, 'rgba(156, 200, 255, 0.55)');
    gradient.addColorStop(0.45, 'rgba(82, 126, 190, 0.7)');
    gradient.addColorStop(1, 'rgba(24, 46, 82, 0.9)');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    const texture = new THREE.CanvasTexture(canvas);
    texture.generateMipmaps = false;
    texture.magFilter = THREE.LinearFilter;
    texture.minFilter = THREE.LinearFilter;
    texture.wrapS = THREE.ClampToEdgeWrapping;
    texture.wrapT = THREE.ClampToEdgeWrapping;
    return texture;
  }

  const skyTexture = createSkyTexture();
  const skyMaterial = new THREE.MeshBasicMaterial({ map: skyTexture, depthWrite: false, depthTest: false, transparent: true, opacity: 0.96 });
  const skyGeometry = new THREE.PlaneGeometry(2200, 900, 1, 1);
  const skyMesh = new THREE.Mesh(skyGeometry, skyMaterial);
  skyMesh.position.set(0, 160, -900);
  scene.add(skyMesh);

  const skyCeilingTexture = createSkyCeilingTexture();
  const skyCeilingMaterial = new THREE.MeshBasicMaterial({ map: skyCeilingTexture, transparent: true, opacity: 0.85, side: THREE.DoubleSide, depthWrite: false, depthTest: false });
  const skyCeilingGeometry = new THREE.PlaneGeometry(2600, 2600, 1, 1);
  const skyCeiling = new THREE.Mesh(skyCeilingGeometry, skyCeilingMaterial);
  skyCeiling.rotation.x = -Math.PI / 2;
  skyCeiling.position.set(0, 420, 0);
  scene.add(skyCeiling);

  const camera = new THREE.PerspectiveCamera(50, 16 / 9, 0.1, 3000);
  const controls = {
    yaw: 0,
    pitch: -0.22,
    yawVelocity: 0,
    speed: 60,
    turnSpeed: Math.PI * 0.45,
    turnSmooth: 3,
    height: 60,
    minPitch: -Math.PI / 3,
    maxPitch: Math.PI / 4,
    dragSensitivity: 0.0024,
    touchDragSensitivity: 0.0042
  };
  let currentSpeed = 0;
  camera.position.set(0, controls.height, 160);
  camera.lookAt(0, 0, 0);

  const keyState = {};
  const horizontalForward = new THREE.Vector3();
  const moveVector = new THREE.Vector3();
  const lookVector = new THREE.Vector3();
  const skyTarget = new THREE.Vector3();
  window.addEventListener('keydown', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) { keyState[e.key] = true; e.preventDefault(); }
  });
  window.addEventListener('keyup', e => {
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) { keyState[e.key] = false; e.preventDefault(); }
  });

  const onscreenButtons = document.querySelectorAll('#control-pad button[data-key]');
  onscreenButtons.forEach(btn => {
    const key = btn.dataset.key;
    const activate = ev => { keyState[key] = true; ev.preventDefault(); };
    const deactivate = ev => { keyState[key] = false; ev.preventDefault(); };
    btn.addEventListener('mousedown', activate);
    btn.addEventListener('touchstart', activate, { passive: false });
    const endEvents = ['mouseleave','mouseup','touchend','touchcancel'];
    endEvents.forEach(evt => btn.addEventListener(evt, deactivate));
    window.addEventListener('mouseup', () => { keyState[key] = false; });
    window.addEventListener('touchend', () => { keyState[key] = false; });
    window.addEventListener('touchcancel', () => { keyState[key] = false; });
  });

  const pointerState = {
    active: false,
    pointerId: null,
    lastX: 0,
    lastY: 0,
    pointerType: null,
    hasLogged: false
  };

  function beginPointerDrag(event) {
    if (pointerState.active) return;
    if (event.button !== undefined && event.button !== 0) return;
    if (event.target.closest('#control-ui, #console-dock')) return;
    pointerState.active = true;
    pointerState.pointerId = event.pointerId;
    pointerState.lastX = event.clientX;
    pointerState.lastY = event.clientY;
    pointerState.pointerType = event.pointerType || 'mouse';
    renderer.domElement.setPointerCapture(event.pointerId);
    renderer.domElement.style.cursor = 'grabbing';
    if (!pointerState.hasLogged) {
      console.log(`Pointer look engaged (${pointerState.pointerType}).`);
      pointerState.hasLogged = true;
    }
    event.preventDefault();
  }

  function handlePointerMove(event) {
    if (!pointerState.active || event.pointerId !== pointerState.pointerId) return;
    const dx = event.clientX - pointerState.lastX;
    const dy = event.clientY - pointerState.lastY;
    pointerState.lastX = event.clientX;
    pointerState.lastY = event.clientY;
    const sensitivity = event.pointerType === 'touch' ? controls.touchDragSensitivity : controls.dragSensitivity;
    controls.yaw -= dx * sensitivity;
    controls.pitch = THREE.MathUtils.clamp(controls.pitch - dy * sensitivity, controls.minPitch, controls.maxPitch);
    event.preventDefault();
  }

  function endPointerDrag(event) {
    if (pointerState.active && (event.pointerId === pointerState.pointerId || event.type === 'pointerleave')) {
      if (event.pointerId != null && renderer.domElement.hasPointerCapture?.(event.pointerId)) {
        renderer.domElement.releasePointerCapture(event.pointerId);
      }
      pointerState.active = false;
      pointerState.pointerId = null;
      renderer.domElement.style.cursor = 'grab';
    }
  }

  renderer.domElement.addEventListener('pointerdown', beginPointerDrag);
  renderer.domElement.addEventListener('pointermove', handlePointerMove);
  renderer.domElement.addEventListener('pointerup', endPointerDrag);
  renderer.domElement.addEventListener('pointercancel', endPointerDrag);
  renderer.domElement.addEventListener('lostpointercapture', endPointerDrag);
  renderer.domElement.addEventListener('pointerleave', endPointerDrag);
  window.addEventListener('blur', () => { pointerState.active = false; renderer.domElement.style.cursor = 'grab'; });

  let touchStart = null;
  window.addEventListener('touchstart', e => {
    if (e.target.closest('#control-pad') || e.target.closest('#canvas-wrap')) return;
    touchStart = e.touches[0];
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchmove', e => {
    if (!touchStart || e.target.closest('#control-pad') || e.target.closest('#canvas-wrap')) return;
    const touch = e.touches[0];
    const dx = touch.clientX - touchStart.clientX;
    const dy = touch.clientY - touchStart.clientY;
    const threshold = 10;
    keyState['ArrowLeft'] = dx < -threshold;
    keyState['ArrowRight'] = dx > threshold;
    keyState['ArrowUp'] = dy < -threshold;
    keyState['ArrowDown'] = dy > threshold;
    e.preventDefault();
  }, { passive: false });
  window.addEventListener('touchend', e => {
    if (e.target.closest('#control-pad') || e.target.closest('#canvas-wrap')) return;
    touchStart = null;
    keyState['ArrowLeft'] = keyState['ArrowRight'] = keyState['ArrowUp'] = keyState['ArrowDown'] = false;
    e.preventDefault();
  });

  function hash(ix, iz){ const s = Math.sin(ix*127.1 + iz*311.7) * 43758.5453123; return s - Math.floor(s); }
  const lerp = (a,b,t)=> a + (b-a)*t; const smooth = t => t*t*(3-2*t);
  function noise2(x,z){ const ix=Math.floor(x), iz=Math.floor(z), fx=x-ix, fz=z-iz;
    const a=hash(ix,iz), b=hash(ix+1,iz), c=hash(ix,iz+1), d=hash(ix+1,iz+1);
    const ux=smooth(fx), uz=smooth(fz); return lerp( lerp(a,b,ux), lerp(c,d,ux), uz ); }
  function fbm(x,z,oct=5){ let amp=1,freq=0.02,sum=0,norm=0; for(let i=0;i<oct;i++){ sum+=amp*noise2(x*freq,z*freq); norm+=amp; amp*=0.5; freq*=2; } return sum/norm; }

  const terrainSize = 600;
  const terrainSegments = 120;
  const terrain = new THREE.PlaneGeometry(terrainSize, terrainSize, terrainSegments, terrainSegments);
  terrain.rotateX(-Math.PI/2);
  const pos = terrain.attributes.position;
  const basePositions = Float32Array.from(pos.array);
  const fadeAttribute = new Float32Array(pos.count);
  const halfSize = terrainSize / 2;
  const fadeWidth = terrainSize * 0.22;
  for (let i = 0; i < pos.count; i++) {
    const ix = i * 3;
    const x = basePositions[ix];
    const z = basePositions[ix + 2];
    const distX = halfSize - Math.abs(x);
    const distZ = halfSize - Math.abs(z);
    const edgeDistance = Math.max(0, Math.min(distX, distZ));
    const fadeStrength = THREE.MathUtils.clamp(edgeDistance / fadeWidth, 0, 1);
    fadeAttribute[i] = fadeStrength * fadeStrength;
  }
  terrain.setAttribute('edgeFade', new THREE.BufferAttribute(fadeAttribute, 1));
  const cellSize = terrainSize / terrainSegments;
  const chunkSize = cellSize * 10;
  const terrainState = { offsetX: 0, offsetZ: 0 };

  function refreshTerrain(offsetX, offsetZ) {
    for (let i = 0; i < pos.count; i++) {
      const ix = i * 3;
      const x = basePositions[ix];
      const z = basePositions[ix + 2];
      const worldX = x + offsetX;
      const worldZ = z + offsetZ;
      const y = fbm(worldX, worldZ) * 60 - 18;
      pos.setY(i, y);
    }
    pos.needsUpdate = true;
    terrain.computeVertexNormals();
  }
  refreshTerrain(terrainState.offsetX, terrainState.offsetZ);
  const terrainMaterial = new THREE.MeshStandardMaterial({
    color: 0x2a8a4b,
    flatShading: true,
    metalness: 0,
    roughness: 1
  });
  terrainMaterial.onBeforeCompile = shader => {
    shader.uniforms.edgeFadeColor = { value: fogColor.clone() };
    shader.vertexShader = shader.vertexShader
      .replace('#include <common>', `#include <common>\nattribute float edgeFade;\nvarying float vEdgeFade;`)
      .replace('#include <begin_vertex>', `#include <begin_vertex>\nvEdgeFade = edgeFade;`);
    shader.fragmentShader = shader.fragmentShader
      .replace('#include <common>', `#include <common>\nvarying float vEdgeFade;\nuniform vec3 edgeFadeColor;`)
      .replace('#include <dithering_fragment>', `#include <dithering_fragment>\n  gl_FragColor.rgb = mix(edgeFadeColor, gl_FragColor.rgb, vEdgeFade);`);
  };
  const terrainMesh = new THREE.Mesh(terrain, terrainMaterial);
  terrainMesh.position.set(terrainState.offsetX, 0, terrainState.offsetZ);
  scene.add(terrainMesh);
  defaultTerrainColor = terrainMesh.material.color.clone();
  function snapToChunk(value) { return Math.round(value / chunkSize) * chunkSize; }

  const groundRay = new THREE.Raycaster();
  const floatingBlocks = [];

  function updateRenderButtons(activeMode) {
    renderModeButtons.forEach(button => {
      const isActive = button.dataset.renderMode === activeMode;
      button.classList.toggle('is-active', isActive);
      button.setAttribute('aria-pressed', String(isActive));
    });
  }

  function applyRenderMode(mode, { announce = true } = {}) {
    const previousMode = currentRenderMode;
    currentRenderMode = mode;
    const isWire = mode === 'wire';
    if (defaultTerrainColor) {
      terrainMesh.material.wireframe = isWire;
      terrainMesh.material.color.copy(isWire ? wireTerrainColor : defaultTerrainColor);
      terrainMesh.material.needsUpdate = true;
    }
    floatingBlocks.forEach(block => {
      block.material.wireframe = isWire;
      if (isWire) {
        block.material.color.copy(wireBlockColor);
      } else if (block.userData.baseColor) {
        block.material.color.copy(block.userData.baseColor);
      }
      block.material.needsUpdate = true;
    });
    updateRenderButtons(mode);
    if (announce && previousMode !== mode) {
      const description = renderModeDescriptions[mode] || mode;
      console.log(`Render mode switched to ${description}.`);
    }
  }

  renderModeButtons.forEach(button => {
    button.addEventListener('click', () => {
      const mode = button.dataset.renderMode;
      if (!mode || mode === currentRenderMode) return;
      applyRenderMode(mode);
    });
  });

  applyRenderMode(currentRenderMode, { announce: false });

  function createBlock(x, z) {
    const size = 2;
    const color = new THREE.Color().setHSL(Math.random() * 0.15, 0.9, 0.5 + Math.random() * 0.1);
    const block = new THREE.Mesh(
      new THREE.BoxGeometry(size, size, size),
      new THREE.MeshStandardMaterial({ color })
    );
    groundRay.set(new THREE.Vector3(x, 100, z), new THREE.Vector3(0, -1, 0));
    const hit = groundRay.intersectObject(terrainMesh);
    const y = hit.length ? hit[0].point.y : 0;
    block.position.set(x, y + size / 2 + 8 * Math.random(), z);
    block.castShadow = true;
    block.receiveShadow = true;
    block.userData.baseColor = block.material.color.clone();
    if (currentRenderMode === 'wire') {
      block.material.wireframe = true;
      block.material.color.copy(wireBlockColor);
      block.material.needsUpdate = true;
    }
    block.userData.base = block.position.clone();
    block.userData.bobSpeed = 0.35 + Math.random() * 0.3;
    block.userData.bobAmp = 4 + Math.random() * 6;
    block.userData.phase = Math.random() * Math.PI * 2;
    block.userData.windSeed = Math.random() * Math.PI * 2;
    block.userData.windSpeed = 0.6 + Math.random() * 0.5;
    block.userData.windStrength = 10 + Math.random() * 6;
    block.userData.windOffset = new THREE.Vector3();
    block.userData.windVelocity = new THREE.Vector3();
    scene.add(block);
    floatingBlocks.push(block);
  }

  const blockSpread = terrainSize * 0.48;
  async function generateBlocks(count) {
    for (let i = 0; i < count; i++) {
      const x = Math.random() * blockSpread * 2 - blockSpread;
      const z = Math.random() * blockSpread * 2 - blockSpread;
      createBlock(x, z);
      if (i % 50 === 0) {
        setProgress((i / count) * 100);
        await new Promise(requestAnimationFrame);
      }
    }
    setProgress(100);
    disposeLoaderVisual();
    disposeLoaderVisual = () => {};
    if (loaderEl) loaderEl.remove();
    console.log(`Terrain populated with ${count} blocks.`);
  }

  function updateControls(dt){
    const yawInput = (keyState['ArrowRight'] ? 1 : 0) - (keyState['ArrowLeft'] ? 1 : 0);
    const targetYawVelocity = yawInput * controls.turnSpeed;
    controls.yawVelocity = THREE.MathUtils.damp(controls.yawVelocity, targetYawVelocity, controls.turnSmooth, dt);
    controls.yaw += controls.yawVelocity * dt;
    controls.yaw = THREE.MathUtils.euclideanModulo(controls.yaw, Math.PI * 2);

    horizontalForward.set(Math.sin(controls.yaw), 0, -Math.cos(controls.yaw));
    moveVector.set(0, 0, 0);
    if (keyState['ArrowUp']) moveVector.add(horizontalForward);
    if (keyState['ArrowDown']) moveVector.addScaledVector(horizontalForward, -1);

    let speedTarget = 0;
    if (moveVector.lengthSq() > 0) {
      moveVector.normalize().multiplyScalar(controls.speed * dt);
      speedTarget = controls.speed;
      camera.position.add(moveVector);
    }
    currentSpeed = THREE.MathUtils.damp(currentSpeed, speedTarget, 6, dt);

    const cosPitch = Math.cos(controls.pitch);
    lookVector.set(
      Math.sin(controls.yaw) * cosPitch,
      Math.sin(controls.pitch),
      -Math.cos(controls.yaw) * cosPitch
    );
    camera.position.y = controls.height;
    lookTargetScratch.copy(camera.position).add(lookVector);
    camera.lookAt(lookTargetScratch);
  }

  function updateSky(time, dt){
    const skyDistance = 1600;
    skyTarget.copy(camera.position).addScaledVector(lookVector, skyDistance);
    skyTarget.y = camera.position.y + 120;
    skyMesh.position.lerp(skyTarget, 0.08);
    skyMesh.lookAt(camera.position.x, camera.position.y + 40, camera.position.z);

    const desiredHeight = camera.position.y + 320;
    skyCeiling.position.x = camera.position.x;
    skyCeiling.position.z = camera.position.z;
    skyCeiling.position.y = THREE.MathUtils.damp(skyCeiling.position.y, desiredHeight, 4.2, dt);
    skyCeiling.rotation.z = Math.sin(time * 0.18) * 0.08;
    const ceilingOpacity = 0.7 + (Math.sin(time * 0.35) + 1) * 0.12;
    skyCeilingMaterial.opacity = THREE.MathUtils.damp(skyCeilingMaterial.opacity, ceilingOpacity, 2.5, dt);
  }

  function updateLighting(dt, time, isMoving) {
    sunLightDesired.copy(camera.position).add(sunLightOffset);
    sunLightDesired.x += Math.sin(time * 0.18) * 90;
    sunLightDesired.z += Math.cos(time * 0.16) * 110;
    const lerpFactor = THREE.MathUtils.clamp(dt * 3.6, 0, 1);
    sunLight.position.lerp(sunLightDesired, lerpFactor);

    sunLightTargetDesired.copy(camera.position).addScaledVector(lookVector, 60);
    sunLight.target.position.lerp(sunLightTargetDesired, lerpFactor);
    sunLight.target.updateMatrixWorld();

    const baseIntensity = 1.05 + Math.sin(time * 0.24) * 0.08;
    const targetIntensity = baseIntensity + (isMoving ? 0.18 : 0);
    sunLight.intensity = THREE.MathUtils.damp(sunLight.intensity, targetIntensity, 3.2, dt);
  }

  function updateTerrainFollow() {
    const snappedX = snapToChunk(camera.position.x);
    const snappedZ = snapToChunk(camera.position.z);
    if (snappedX !== terrainState.offsetX || snappedZ !== terrainState.offsetZ) {
      terrainState.offsetX = snappedX;
      terrainState.offsetZ = snappedZ;
      refreshTerrain(snappedX, snappedZ);
      terrainMesh.position.set(snappedX, 0, snappedZ);
      console.log(`Terrain recentered to chunk (${Math.round(snappedX / chunkSize)}, ${Math.round(snappedZ / chunkSize)}).`);
    }
  }

  const tempVec = new THREE.Vector3();
  const lookTargetScratch = new THREE.Vector3();
  const desiredBlock = new THREE.Vector3();
  const windScratch = new THREE.Vector3();
  function updateHud() {
    if (!hudElements.position) return;
    const pos = camera.position;
    hudElements.position.textContent = `${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}`;
    const yawDeg = THREE.MathUtils.euclideanModulo(THREE.MathUtils.radToDeg(controls.yaw), 360);
    const pitchDeg = THREE.MathUtils.radToDeg(controls.pitch);
    hudElements.heading.textContent = `${yawDeg.toFixed(1)}° / ${pitchDeg.toFixed(1)}°`;
    hudElements.chunk.textContent = `${Math.round(terrainState.offsetX / chunkSize)}, ${Math.round(terrainState.offsetZ / chunkSize)}`;
    hudElements.speed.textContent = `${currentSpeed.toFixed(1)} m/s`;
  }
  function updateBlocks(dt, time) {
    const cameraPos = camera.position;
    const influenceRadius = 60;
    const influenceRadiusSq = influenceRadius * influenceRadius;
    for (const block of floatingBlocks) {
      const data = block.userData;
      const bob = Math.sin(time * data.bobSpeed + data.phase) * data.bobAmp;
      desiredBlock.copy(data.base);
      desiredBlock.y += bob;
      tempVec.copy(cameraPos).sub(block.position);
      const distanceSq = tempVec.lengthSq();
      if (distanceSq < influenceRadiusSq) {
        const distance = Math.sqrt(distanceSq);
        const strength = (influenceRadius - distance) / influenceRadius;
        const windPhase = time * data.windSpeed + data.windSeed;
        windScratch.set(
          Math.sin(windPhase),
          Math.cos(windPhase * 0.8) * 0.3,
          Math.cos(windPhase * 1.1)
        );
        data.windVelocity.addScaledVector(windScratch, strength * data.windStrength * dt);
      }
      data.windVelocity.multiplyScalar(Math.max(0, 1 - dt * 2.2));
      data.windOffset.addScaledVector(data.windVelocity, dt);
      data.windOffset.multiplyScalar(0.92);
      desiredBlock.add(data.windOffset);
      block.position.lerp(desiredBlock, THREE.MathUtils.clamp(dt * 4, 0, 1));
    }
  }

  let last = performance.now();
  function animate(){
    fpsMonitor.begin();
    const now = performance.now();
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    updateControls(dt);
    const isCameraMoving = moveVector.lengthSq() > 1e-6 || currentSpeed > 0.5;
    updateTerrainFollow();
    updateHud();
    updateBlocks(dt, now / 1000);
    updateSky(now / 1000, dt);
    updateLighting(dt, now / 1000, isCameraMoving);
    renderer.render(scene, camera);
    fpsMonitor.end();
    requestAnimationFrame(animate);
  }

  console.log('Terrain initialising...');
  await generateBlocks(1000);
  applyRenderMode(currentRenderMode, { announce: false });
  console.log('Terrain ready.');
  animate();

  const resolutionSelect = document.getElementById('resolution-select');
  const resolutionDisplay = document.getElementById('resolution-display');
  const fullscreenBtn = document.getElementById('fullscreen-btn');
  const controlUi = document.getElementById('control-ui');
  const foldBtn = document.getElementById('ui-fold-btn');
  let setControlFolded = null;

  if (foldBtn && controlUi) {
    const syncControlFold = (folded) => {
      controlUi.classList.toggle('folded', folded);
      foldBtn.setAttribute('aria-expanded', String(!folded));
      const label = folded ? 'Expand control panel' : 'Collapse control panel';
      foldBtn.setAttribute('aria-label', label);
    };
    setControlFolded = syncControlFold;
    foldBtn.addEventListener('click', () => {
      const next = !controlUi.classList.contains('folded');
      syncControlFold(next);
      console.log(`Control interface ${next ? 'folded' : 'expanded'}.`);
    });
    syncControlFold(controlUi.classList.contains('folded'));
    console.log('Control interface initialised with animated fold icon.');
  }

  const isFullscreenActive = () => Boolean(
    document.fullscreenElement ||
    document.webkitFullscreenElement ||
    document.msFullscreenElement
  );

  let currentResolution = RESOLUTIONS[4];
  let vhsTimeoutId = null;
  const MOBILE_BREAKPOINT = 720;
  let isMobileLayout = null;

  function updateResponsiveState() {
    const isMobile = window.innerWidth <= MOBILE_BREAKPOINT;
    document.body.classList.toggle('is-mobile', isMobile);
    if (isMobile !== isMobileLayout) {
      if (isMobile) {
        setControlFolded?.(true);
        setConsoleFolded?.(true);
      }
      isMobileLayout = isMobile;
    }
  }

  const spawnVhsLines = () => {
    if (!canvasWrap) return;
    const clamp = (value, min, max) => Math.max(min, Math.min(max, value));
    const createLine = (topPercent) => {
      const line = document.createElement('div');
      line.classList.add('vhs-line');

      const isCluster = Math.random() < 0.45;
      if (isCluster) {
        line.classList.add('vhs-line--cluster');
        const clusterThickness = 2 + Math.random() * 3;
        line.style.setProperty('--cluster-thickness', `${clusterThickness}px`);
        const clusterHeight = 14 + Math.random() * 26;
        line.style.height = `${clusterHeight}px`;
      } else {
        const baseHeight = 4 + Math.random() * 10;
        line.style.height = `${baseHeight}px`;
      }

      const top = clamp(topPercent, 0, 100);
      line.style.top = `${top}%`;

      const shiftStart = (Math.random() - 0.5) * 140;
      const shiftMid = shiftStart + (Math.random() - 0.5) * 180;
      const shiftEnd = (Math.random() - 0.5) * 120;
      const shiftClear = (Math.random() - 0.5) * 20;
      line.style.setProperty('--shift-start', `${shiftStart}px`);
      line.style.setProperty('--shift-mid', `${shiftMid}px`);
      line.style.setProperty('--shift-end', `${shiftEnd}px`);
      line.style.setProperty('--shift-clear', `${shiftClear}px`);

      const skewStart = (Math.random() - 0.5) * 4;
      const skewMid = (Math.random() - 0.5) * 12;
      const skewEnd = (Math.random() - 0.5) * 4;
      line.style.setProperty('--skew-start', `${skewStart}deg`);
      line.style.setProperty('--skew-mid', `${skewMid}deg`);
      line.style.setProperty('--skew-end', `${skewEnd}deg`);

      line.style.setProperty('--line-opacity', `${0.5 + Math.random() * 0.4}`);
      line.style.setProperty('--line-brightness', `${0.85 + Math.random() * 0.6}`);
      line.style.setProperty('--line-hue', `${(Math.random() - 0.5) * 100}deg`);

      canvasWrap.appendChild(line);
      line.addEventListener('animationend', () => {
        line.remove();
      }, { once: true });
    };

    const groupCount = 3 + Math.floor(Math.random() * 4);
    for (let group = 0; group < groupCount; group++) {
      const baseTop = Math.random() * 100;
      const linesInGroup = 1 + Math.floor(Math.random() * 3);
      for (let i = 0; i < linesInGroup; i++) {
        createLine(baseTop + (Math.random() - 0.5) * 10);
      }
    }
  };

  const triggerVhsEffect = () => {
    if (!canvasWrap) return;
    canvasWrap.classList.remove('vhs-glitch');
    void canvasWrap.offsetWidth;
    canvasWrap.classList.add('vhs-glitch');
    spawnVhsLines();
    if (vhsTimeoutId) {
      clearTimeout(vhsTimeoutId);
    }
    vhsTimeoutId = setTimeout(() => {
      canvasWrap.classList.remove('vhs-glitch');
    }, 650);
  };

  function applyResolution(res) {
    currentResolution = res;
    renderer.setSize(res.width, res.height, false);
    renderer.domElement.width = res.width;
    renderer.domElement.height = res.height;
    camera.aspect = res.width / res.height;
    camera.updateProjectionMatrix();
    resolutionDisplay.textContent = `${res.label} — ${res.width} × ${res.height}`;
    updateCanvasLayout();
    console.log(`Resolution set to ${res.width}×${res.height} (${res.label}).`);
  }

  function parseResolution(value) {
    const [w, h] = value.split('x').map(Number);
    return RESOLUTIONS.find(r => r.width === w && r.height === h) || RESOLUTIONS[0];
  }

  function updateCanvasLayout() {
    const aspect = currentResolution.width / currentResolution.height;
    const availableWidth = Math.max(100, window.innerWidth);
    const availableHeight = Math.max(100, window.innerHeight);

    let displayWidth = availableWidth;
    let displayHeight = displayWidth / aspect;

    if (displayHeight > availableHeight) {
      const scale = availableHeight / displayHeight;
      displayWidth = Math.floor(displayWidth * scale);
      displayHeight = availableHeight;
    }

    renderer.domElement.style.width = `${displayWidth}px`;
    renderer.domElement.style.height = `${displayHeight}px`;
    canvasWrap.style.width = `${displayWidth}px`;
    canvasWrap.style.height = `${displayHeight}px`;
  }

  resolutionSelect.addEventListener('change', () => {
    applyResolution(parseResolution(resolutionSelect.value));
    triggerVhsEffect();
  });

  function updateFullscreenButton() {
    const isFullscreen = isFullscreenActive();
    const isMobile = document.body.classList.contains('is-mobile');
    const label = isFullscreen ? 'Exit Fullscreen' : (isMobile ? 'Fullscreen' : 'Enter Fullscreen');
    fullscreenBtn.textContent = label;
    const shouldShow = isFullscreen || window.innerWidth >= MOBILE_BREAKPOINT || isMobile;
    fullscreenBtn.style.display = shouldShow ? 'inline-flex' : 'none';
    document.body.classList.toggle('is-fullscreen', isFullscreen);
  }

  fullscreenBtn.addEventListener('click', () => {
    if (isFullscreenActive()) {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      } else if (document.webkitExitFullscreen) {
        document.webkitExitFullscreen();
      }
    } else {
      const target = document.documentElement;
      const request = target.requestFullscreen || target.webkitRequestFullscreen || target.msRequestFullscreen;
      if (request) request.call(target);
    }
  });

  document.addEventListener('fullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });
  document.addEventListener('webkitfullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });
  document.addEventListener('msfullscreenchange', () => {
    updateCanvasLayout();
    updateFullscreenButton();
  });

  window.addEventListener('resize', () => {
    updateResponsiveState();
    updateCanvasLayout();
    updateFullscreenButton();
  });

  window.addEventListener('orientationchange', () => {
    updateResponsiveState();
    updateCanvasLayout();
    updateFullscreenButton();
  });

  updateResponsiveState();
  applyResolution(currentResolution);
  updateFullscreenButton();
  updateCanvasLayout();
  </script>
</body>
</html>
