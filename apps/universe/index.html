<!--
/**
 * @version   v2.0.0
 * @codename  "CELESTIAL_TERRAIN_HYPERLUMINAL"
 * @author    Codex Prodigy
 * @date      2025-08-13
 * @log       Major visual upgrade: lensing, GRB system, nebulae, galaxy distancing & vertical drift
 * @changelog
 *   - [2025-08-13] Re-architected galaxy placement (Fibonacci sphere) to avoid clustering; added vertical oscillation
 *   - [2025-08-13] Added procedural nebulae (noise billboards) with Hubble-like palettes
 *   - [2025-08-13] Implemented gravitational lens arcs and micro-lenses near massive objects
 *   - [2025-08-13] Added Gamma-Ray Burst (GRB) event system: cones, sprites, relativistic particle shell
 *   - [2025-08-13] Enhanced BH disk thickness model; tuned flares; upgraded starfield seeding
 */
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Universe</title>
  <style>
    :root { --w: 1280; --h: 720; }
    html, body { height: 100%; }
    body {
      margin: 0; background: #000; color: #fff;
      display: grid; place-items: center; overflow: hidden;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    }
    #container { position: relative; line-height: 0; }
    #fps { position: absolute; top: 0; left: 0; z-index: 20; }
    #overlay-error { position: absolute; inset: 0; display: none; z-index: 30; background: rgba(0,0,0,0.85); color: #fff; padding: 16px; font-size: 14px; line-height: 1.4; overflow: auto; box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12); }
    #overlay-error pre { white-space: pre-wrap; }
    #note { position:absolute; bottom:6px; left:8px; opacity:.9; font-size:12px; letter-spacing:.2px; z-index: 10; }
    #placeholder { position: absolute; inset: 0; z-index: 5; display: grid; place-items: center; background: radial-gradient(ellipse at 60% 40%, #10202a 0%, #05070b 60%, #000 100%); color:#9cc7ff; font: 600 14px/1.2 system-ui, sans-serif; box-shadow: inset 0 0 120px rgba(0,0,0,0.8); }
    .hud { position:absolute; top:6px; right:8px; z-index:15; font:12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; opacity:.9; text-align:right;}
    kbd { background:#111; border:1px solid #333; border-bottom-color:#222; border-radius:4px; padding:.5px 4px; font-weight:600; }
    .stick{position:absolute;width:120px;height:120px;margin:-60px 0 0 -60px;border:1px solid rgba(255,255,255,.25);border-radius:50%;display:none;z-index:15;pointer-events:none}
    .stick .nub{position:absolute;left:50%;top:50%;width:36px;height:36px;margin:-18px 0 0 -18px;border-radius:50%;background:rgba(255,255,255,.2);box-shadow:0 0 12px rgba(255,255,255,.35) inset}
  </style>
</head>
<body>
  <div id="container" data-app-version="v2.0.0">
    <div id="fps"></div>
    <div class="hud">
      <div><kbd>G</kbd> GRB • <kbd>N</kbd> Nebula • <kbd>A</kbd> AutoCam • <kbd>↑↓←→</kbd> Manual • <kbd>R</kbd> Reset</div>
    </div>
    <div id="overlay-error"></div>
    <div id="note">v2.0.0 • Booting…</div>
    <div id="placeholder">Loading 3D scene…</div>
  </div>
  <noscript>This demo requires JavaScript enabled.</noscript>

  <script>
  // ===== Version =====
  const APP_VERSION  = 'v2.0.0';
  const APP_CODENAME = 'CELESTIAL_TERRAIN_HYPERLUMINAL';
  window.APP_VERSION = APP_VERSION; window.APP_CODENAME = APP_CODENAME;

  // ===== Error overlay =====
  const overlayError = document.getElementById('overlay-error');
  function showErrorOverlay(msg, error) {
    overlayError.style.display = 'block';
    overlayError.innerHTML = '<strong>Runtime Error</strong><br><br>' +
      '<pre>' + (msg || '') + (error ? ('\n' + (error.stack || error.message || error)) : '') + '</pre>' +
      '<p style="opacity:.75">Tip: If external CDNs are blocked, the built-in fallback renderer will take over.</p>';
    console.error(msg, error);
  }
  window.addEventListener('error', (e) => { try { showErrorOverlay(e.message || 'Error', e.error || e); } catch(err) { console.error(err); } }, true);
  window.addEventListener('unhandledrejection', (e) => { try { showErrorOverlay('Unhandled Promise Rejection', e.reason); } catch(err) { console.error(err); } });

  // ===== Loader with timeout =====
  function loadScript(url, timeoutMs = 9000) {
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      const t = setTimeout(() => { s.onload = s.onerror = null; reject(new Error('Timeout loading: ' + url)); }, timeoutMs);
      s.src = url; s.async = true; s.defer = true; s.crossOrigin = 'anonymous'; s.referrerPolicy = 'no-referrer';
      s.onload = () => { clearTimeout(t); resolve(url); };
      s.onerror = () => { clearTimeout(t); reject(new Error('Failed to load: ' + url)); };
      document.head.appendChild(s);
    });
  }
  async function loadFirstAvailable(urls) {
    let lastErr;
    for (const u of urls) {
      try { await loadScript(u); return u; }
      catch (e) { lastErr = e; console.warn(e.message); }
    }
    throw lastErr || new Error('All URLs failed: ' + urls.join(', '));
  }

  // ===== FPS fallback =====
  class MiniStats {
    constructor(){ this.dom=document.createElement('div'); this.dom.style.cssText='background:rgba(0,0,0,.6);padding:4px 6px;font:12px/1.2 monospace;'; this.label=document.createElement('div'); this.dom.appendChild(this.label); this._smoothing=0.9; this._fps=0; this._valid=false; this.begin(); }
    begin(){ this._tick=performance.now(); }
    end(){ const now=performance.now(); const dt=now-this._tick; const inst=1000/Math.max(dt,0.0001); this._fps=this._valid?(this._smoothing*this._fps+(1-this._smoothing)*inst):inst; this._valid=true; this.label.textContent=`FPS: ${this._fps.toFixed(1)} | ms: ${dt.toFixed(2)}`; }
    showPanel(){}
  }

  // ===== Scaling =====
  function applyScaleTo(el, W=1280, H=720){ if(!el) return; const scale=Math.min(window.innerWidth/W, window.innerHeight/H); el.style.width=(W*scale)+'px'; el.style.height=(H*scale)+'px'; }
  function applyScaleAll(){ const c=document.querySelector('#container>canvas'); applyScaleTo(c); applyScaleTo(document.getElementById('placeholder')); }
  window.addEventListener('resize', applyScaleAll); applyScaleAll();

  // ===== Boot =====
  (async function boot(){
    try {
      const threeURL = await loadFirstAvailable([
        'https://unpkg.com/three@0.160.0/build/three.min.js',
        'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js'
      ]); console.log('THREE loaded from:', threeURL);
      try {
        const statsURL = await loadFirstAvailable([
          'https://unpkg.com/stats.js@0.17.0/build/stats.min.js',
          'https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js',
          'https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js'
        ]); console.log('Stats loaded from:', statsURL);
      } catch(e){ console.warn('Stats unavailable, using MiniStats. Cause:', e.message); }
      initThreeScene();
    } catch (e) {
      console.warn('THREE failed to load, entering fallback mode.', e);
      initCanvasFallback(e);
    }
  })();

  // ===== Quality profile =====
  function chooseQuality(){
    const ua = (navigator.userAgent || '').toLowerCase();
    const isMobile = /android|iphone|ipad|ipod/.test(ua);
    return {
      isMobile,
      dpr: Math.min(window.devicePixelRatio || 1, isMobile ? 1.0 : 1.5),
      diskPoints: isMobile ? 2800 : 4200,
      galaxyPoints: isMobile ? 5200 : 8400,
      flarePairs: isMobile ? 14 : 20,
      flareScaleMin: isMobile ? 5 : 7,
      flareScaleMax: isMobile ? 11 : 14,
      jetSegments: isMobile ? 18 : 28,
      nebulaCount: isMobile ? 3 : 5
    };
  }

  // ===== Helpers =====
  function makeGlowTexture(size=64, inner='rgba(255,255,255,1)', mid='rgba(255,230,170,0.95)', outer='rgba(255,255,255,0)'){
    const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
    const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
    g.addColorStop(0, inner); g.addColorStop(0.35, mid); g.addColorStop(1, outer);
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(size/2,size/2,size/2,0,Math.PI*2); ctx.fill();
    const tex = new THREE.CanvasTexture(c); tex.center.set(0.5,0.5); return tex;
  }

  // === Procedural nebula texture (FBM noise to Hubble palette)
  function makeNebulaTexture(size=1024, palette='orion'){
    const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
    // Fast value noise: precompute grid, then bilinear sample (no getImageData in inner loop)
    const NX=128, NY=128; const vals=new Float32Array(NX*NY);
    for(let j=0;j<NY;j++){ for(let i=0;i<NX;i++){ vals[j*NX+i]=Math.random(); }}
    const smooth=t=>t*t*(3-2*t);
    function sample(x,y){ x=(x%NX+NX)%NX; y=(y%NY+NY)%NY; const ix=Math.floor(x), iy=Math.floor(y); const fx=x-ix, fy=y-iy; const ix1=(ix+1)%NX, iy1=(iy+1)%NY; const v00=vals[iy*NX+ix], v10=vals[iy*NX+ix1], v01=vals[iy1*NX+ix], v11=vals[iy1*NX+ix1]; const sx=smooth(fx), sy=smooth(fy); const a=v00*(1-sx)+v10*sx; const b=v01*(1-sx)+v11*sx; return a*(1-sy)+b*sy; }
    function fbm(x,y){ let amp=1,f=1,sum=0,norm=0; for(let i=0;i<5;i++){ sum+=amp*sample(x*f,y*f); norm+=amp; amp*=0.5; f*=2.1; } return sum/norm; }
    const img=ctx.createImageData(size,size);
    const palettes={
      orion:(t)=>{ const h=200*(1-t)+300*t; const s=0.65+0.25*t; const l=0.35+0.35*t; const col=new THREE.Color().setHSL(h/360,s,l); return [col.r*255,col.g*255,col.b*255]; },
      carina:(t)=>{ const h=210*(1-t)+30*t; const s=0.8; const l=0.48+0.25*(t*t); const col=new THREE.Color().setHSL(h/360,s,l); return [col.r*255,col.g*255,col.b*255]; }
    }; const map=palettes[palette]||palettes.orion;
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const nx=(x/size)*NX, ny=(y/size)*NY; const f=fbm(nx,ny);
        const edge=Math.hypot((x-size/2)/(size/2),(y-size/2)/(size/2));
        const alpha=Math.max(0,1-edge*edge*0.9)*Math.pow(f,1.5);
        const t=Math.pow(f,0.85); const [r,g,b]=map(t); const k=(y*size+x)*4;
        img.data[k]=r|0; img.data[k+1]=g|0; img.data[k+2]=b|0; img.data[k+3]=(alpha*255)|0;
      }
    }
    ctx.putImageData(img,0,0); const tex=new THREE.CanvasTexture(c); tex.center.set(0.5,0.5); tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping; return tex;
  }

  // ===== Black hole with enhanced lensing rings and disk thickness
  function buildBlackHole(q){
    const group = new THREE.Group();

    // Event horizon
    const horizon = new THREE.Mesh(new THREE.SphereGeometry(10, 64, 64), new THREE.MeshBasicMaterial({ color: 0x000000 }));
    group.add(horizon);

    // Lensing rings (Einstein rings approximation)
    function makeRing(R, tube, color, opacity){
      const m = new THREE.MeshBasicMaterial({ color, transparent:true, opacity, blending:THREE.AdditiveBlending });
      const t = new THREE.Mesh(new THREE.TorusGeometry(R, tube, 32, 512), m); t.rotation.x = Math.PI/2; return t;
    }
    const ring1 = makeRing(12.0, 0.65, 0xffdd99, 0.95);
    const ring2 = makeRing(14.0, 0.50, 0xffaa66, 0.75);
    const ring3 = makeRing(15.9, 0.40, 0x88ccff, 0.55);
    group.add(ring1, ring2, ring3);

    /**
     * Math (disk orbital angular velocity):
     * ω(r) = ω₀ (r₀ / r)^{3/2} for Keplerian disk.
     * Vertical scale-height H(r) ~ H₀ + H₁ ((r - r₀)/(r₁ - r₀))^{p}
     * We animate y(t) = y₀ + A·sin(φ + t·(a + b·√r))
     */
    const total = Math.max(3000, q.diskPoints);
    const layersDef = [
      { name:'inner',  r0:14, r1:28, count: Math.floor(total*0.35), hueA:0.02, hueB:0.00, lumA:0.65, lumB:0.45, size:2.0, shear:2.0, yAmp:2.0, H0:0.9, H1:1.5 },
      { name:'middle', r0:28, r1:56, count: Math.floor(total*0.40), hueA:0.06, hueB:0.02, lumA:0.60, lumB:0.40, size:2.1, shear:1.1, yAmp:3.0, H0:1.1, H1:2.6 },
      { name:'outer',  r0:56, r1:92, count: Math.floor(total*0.25), hueA:0.10, hueB:0.05, lumA:0.55, lumB:0.35, size:2.3, shear:0.7, yAmp:3.8, H0:1.3, H1:3.8 }
    ];

    const randN = ()=>{ const u=Math.random()||1e-6, v=Math.random()||1e-6; return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); };
    const layers = [];
    for (const L of layersDef){
      const N = L.count;
      const pos = new Float32Array(N*3);
      const col = new Float32Array(N*3);
      const rad = new Float32Array(N);
      const ang = new Float32Array(N);
      const omg = new Float32Array(N);
      const y0  = new Float32Array(N);
      const phs = new Float32Array(N);
      const C = new THREE.Color();
      for (let i=0;i<N;i++){
        const r = Math.sqrt(Math.random())*(L.r1 - L.r0) + L.r0;
        const a = Math.random()*Math.PI*2;
        rad[i]=r; ang[i]=a; phs[i]=Math.random()*Math.PI*2;
        const base=1.3; omg[i]= base * L.shear * Math.pow(L.r0 / r, 1.5);
        const H = L.H0 + L.H1 * Math.pow((r-L.r0)/(L.r1-L.r0), 1.2);
        const y = randN()*H; y0[i]=y;
        const k=i*3; pos[k  ]= r*Math.cos(a); pos[k+1]= y; pos[k+2]= r*Math.sin(a);
        const t=(r - L.r0)/(L.r1 - L.r0);
        C.setHSL((1-t)*L.hueA + t*L.hueB, 1.0, (1-t)*L.lumA + t*L.lumB);
        col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b;
      }
      const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3)); g.setAttribute('color', new THREE.Float32BufferAttribute(col,3));
      const mat = new THREE.PointsMaterial({ size: L.size, map: makeGlowTexture(64), transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true, alphaTest:0.06 });
      const pts = new THREE.Points(g, mat); group.add(pts);
      layers.push({def:L, points:pts, rad, ang, omg, y0, phs});
    }

    // Jets
    const jetMat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent:true, opacity:0.28, blending: THREE.AdditiveBlending, depthWrite:false, side: THREE.DoubleSide });
    const jetGeo = new THREE.ConeGeometry(4, 240, q.jetSegments, 1, true);
    const jetUp = new THREE.Mesh(jetGeo, jetMat);  jetUp.position.y = 130;
    const jetDn = new THREE.Mesh(jetGeo, jetMat);  jetDn.rotation.x = Math.PI; jetDn.position.y = -130;
    group.add(jetUp, jetDn);

    // Flares (gamma/lepton rich inner-disk flares)
    const flareTex = makeGlowTexture(96, 'rgba(140,200,255,1)', 'rgba(80,160,255,0.9)', 'rgba(80,160,255,0)');
    const flares = [];
    function makeFlare(dir){
      const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: flareTex, color: 0xa0d8ff, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, alphaTest: 0.08 }));
      s.position.set((Math.random()-0.5)*3, 0, (Math.random()-0.5)*3);
      s.scale.setScalar(q.flareScaleMin + Math.random()*(q.flareScaleMax-q.flareScaleMin));
      s.userData = { dir, y: 0, speed: 90 + Math.random()*170, life: 0, lifeMax: 0.6 + Math.random()*1.2 };
      group.add(s); return s;
    }
    for(let i=0;i<q.flarePairs;i++){ flares.push(makeFlare(+1)); flares.push(makeFlare(-1)); }

    group.rotation.z = 0.12; group.rotation.x = -0.35;
    group.userData = { layers, ring1, ring2, ring3, flares, t:0 };
    return group;
  }
  function updateBlackHole(bh, dt){
    const ud = bh.userData; ud.t += dt;
    for (const L of ud.layers){
      const pos = L.points.geometry.attributes.position.array;
      for (let i=0;i<L.ang.length;i++){
        L.ang[i] += L.omg[i]*dt; // ω(r) ~ r^{-3/2}
        const r=L.rad[i], a=L.ang[i]; const k=i*3;
        pos[k  ] = r*Math.cos(a);
        pos[k+2] = r*Math.sin(a);
        pos[k+1] = L.y0[i] + Math.sin(L.phs[i] + ud.t*(1.5 + 0.4*Math.sqrt(r))) * (0.25*L.def.yAmp);
      }
      L.points.geometry.attributes.position.needsUpdate = true;
    }
    ud.ring1.rotation.y += 0.24*dt; ud.ring2.rotation.y -= 0.18*dt; ud.ring3.rotation.y += 0.12*dt;
    bh.rotation.y += 0.022*dt;

    for (const s of ud.flares){
      s.userData.life += dt; if (s.userData.life > s.userData.lifeMax){
        s.userData.life = 0; s.userData.lifeMax = 0.6 + Math.random()*1.2; s.userData.speed = 90 + Math.random()*170;
        s.userData.dir = Math.random()<0.5 ? +1 : -1; s.userData.y = 0; s.scale.setScalar(s.scale.x*(0.7+Math.random()*0.6));
      }
      s.userData.y += s.userData.dir * s.userData.speed * dt; const clampY = 130; if (Math.abs(s.userData.y) > clampY) { s.userData.y = s.userData.dir * -clampY; s.userData.life = 0; }
      s.position.y = s.userData.y; const t = s.userData.life / s.userData.lifeMax; const op = Math.max(0, 1 - (t*t)); s.material.opacity = 0.78 * op;
    }
  }

  // ===== Andromeda (background) =====
  function buildAndromedaGalaxy(q){
    const group = new THREE.Group();
    const N = q.galaxyPoints; const Rmax = 360; const arms = 2; const b = 0.25;
    const pos = new Float32Array(N*3); const col = new Float32Array(N*3);
    const c = new THREE.Color();
    for (let i=0;i<N;i++){
      const arm = i % arms; const th = Math.random()*Math.PI*8 + arm*Math.PI;
      const r = Math.min(Rmax, (24 + Math.exp(b*th))) * (0.9 + Math.random()*0.2);
      const jitter = (Math.random()-0.5)*6.0;
      const x = (r + jitter) * Math.cos(th);
      const z = (r + jitter) * Math.sin(th);
      const y = (Math.random()-0.5) * 7.0;
      const k = i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z;
      const t = r / Rmax; c.setHSL(0.10 - 0.05*t, 0.85 - 0.35*t, 0.92 - 0.40*t);
      col[k]=c.r; col[k+1]=c.g; col[k+2]=c.b;
    }
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
    g.setAttribute('color',    new THREE.Float32BufferAttribute(col,3));
    const m = new THREE.PointsMaterial({ size: 5.7, map: makeGlowTexture(64), transparent:true, depthWrite:false, depthTest:false, blending: THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true, alphaTest: 0.05 });
    const points = new THREE.Points(g, m); points.renderOrder = -6; group.add(points);

    function makeGalaxyBillboardTex(){ const c=document.createElement('canvas'); c.width=c.height=512; const ctx=c.getContext('2d'); const grad=ctx.createRadialGradient(256,256,0,256,256,256); grad.addColorStop(0,'rgba(255,240,200,0.55)'); grad.addColorStop(0.40,'rgba(190,210,255,0.42)'); grad.addColorStop(1,'rgba(150,180,255,0)'); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(256,256,256,0,Math.PI*2); ctx.fill(); const t=new THREE.CanvasTexture(c); t.center.set(0.5,0.5); return t; }
    const bbMat = new THREE.MeshBasicMaterial({ map: makeGalaxyBillboardTex(), transparent:true, opacity:0.9, blending:THREE.AdditiveBlending, depthWrite:false, depthTest:false });
    const billboard = new THREE.Mesh(new THREE.PlaneGeometry(1,1), bbMat); billboard.renderOrder = -6; billboard.scale.set(1300,760,1); group.add(billboard);

    const coreGeo = new THREE.PlaneGeometry(380, 380);
    const coreTex = makeGlowTexture(256, 'rgba(255,240,200,1)', 'rgba(255,220,160,0.95)', 'rgba(255,200,140,0)');
    const coreMat = new THREE.MeshBasicMaterial({ map: coreTex, transparent:true, opacity:0.8, blending:THREE.AdditiveBlending, depthWrite:false, depthTest:false });
    const core = new THREE.Mesh(coreGeo, coreMat); core.renderOrder = -6; group.add(core);

    group.position.set(-300, 160, -820);
    group.rotation.set(Math.PI/2 - 0.15, 0.12, 0.02);
    group.scale.set(3.1, 1.0, 3.1);
    group.renderOrder = -6;

    group.userData = { points, core, billboard };
    return group;
  }
  function updateAndromeda(g, dt){ g.rotation.y += 0.006*dt; }

  // ===== Galaxy palettes & tiny galaxies =====
  function pickGalaxyPalette(){
    const types = ['E','S0','Sa','Sb','Sc','SBa','SBb','SBc','Ring','Irr'];
    const type = types[Math.floor(Math.random()*types.length)];
    const palettes = {
      E:   { coreH:0.06, armH:0.06, sat:0.5 },
      S0:  { coreH:0.10, armH:0.10, sat:0.7 },
      Sa:  { coreH:0.10, armH:0.58, sat:0.9 },
      Sb:  { coreH:0.10, armH:0.60, sat:0.9 },
      Sc:  { coreH:0.10, armH:0.64, sat:0.95 },
      SBa: { coreH:0.10, armH:0.58, sat:0.9 },
      SBb: { coreH:0.10, armH:0.60, sat:0.9 },
      SBc: { coreH:0.10, armH:0.64, sat:0.95 },
      Ring:{ coreH:0.10, armH:0.62, sat:0.9 },
      Irr: { coreH:0.12, armH:0.83, sat:0.95 }
    };
    return { type, ...palettes[type] };
  }

  function buildTinyGalaxy(palette, pts=1000, scale=1){
    const group = new THREE.Group();
    const type = palette.type; const HARM = palette.armH; const SAT = palette.sat;
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(pts*3), col = new Float32Array(pts*3);
    const C = new THREE.Color();
    const randN = ()=>{ const u=Math.random()||1e-6, v=Math.random()||1e-6; return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); };

    if (/^S(B)?[abc]$/.test(type) || type==='S0'){
      const tightness = (type.endsWith('a')?0.18:(type.endsWith('b')?0.24:0.32));
      const arms = (type==='Sc'||type==='SBc') ? 3 : 2; const Rmax = 95*scale;
      const hasBar = /^SB/.test(type); const isS0 = (type==='S0');
      for (let i=0;i<pts;i++){
        const arm=i%arms; const th=Math.random()*Math.PI*8 + arm*(2*Math.PI/arms);
        const rBase=Math.min(Rmax, 20 + Math.exp(tightness*th));
        const r=(0.85+0.3*Math.random())*rBase;
        const x=(r+(Math.random()-0.5)*2.4*scale)*Math.cos(th);
        const z=(r+(Math.random()-0.5)*2.4*scale)*Math.sin(th);
        const H = 0.8*scale + 1.9*scale*(r/Rmax);
        const y = randN()*H;
        const k=i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z;
        const t=r/Rmax; C.setHSL(HARM + (Math.random()-0.5)*0.02, SAT, 0.90 - 0.45*t); col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b;
      }
      if (hasBar){
        const barPts = Math.floor(pts*0.15); const barPos=new Float32Array(barPts*3), barCol=new Float32Array(barPts*3);
        for(let i=0;i<barPts;i++){ const t= (i/(barPts-1))*2-1; const x=t*0.55*Rmax; const z=randN()*4*scale; const y=randN()*2.2*scale; const k=i*3; barPos[k]=x; barPos[k+1]=y; barPos[k+2]=z; C.setHSL(0.10,0.9,0.92); barCol[k]=C.r; barCol[k+1]=C.g; barCol[k+2]=C.b; }
        const gb=new THREE.BufferGeometry(); gb.setAttribute('position', new THREE.Float32BufferAttribute(barPos,3)); gb.setAttribute('color', new THREE.Float32BufferAttribute(barCol,3));
        const mb=new THREE.PointsMaterial({ size:4.8*scale, map: makeGlowTexture(64), transparent:true, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true });
        const pb=new THREE.Points(gb,mb); pb.renderOrder=-7; group.add(pb);
      }
      if (isS0){
        const ringPts = Math.floor(pts*0.10); const ringPos=new Float32Array(ringPts*3), ringCol=new Float32Array(ringPts*3);
        for(let i=0;i<ringPts;i++){ const a=Math.random()*Math.PI*2; const R=72*scale; const x=(R+randN()*3)*Math.cos(a), z=(R+randN()*3)*Math.sin(a), y=randN()*1.2*scale; const k=i*3; ringPos[k]=x; ringPos[k+1]=y; ringPos[k+2]=z; C.setHSL(HARM, SAT*0.7, 0.8); ringCol[k]=C.r; ringCol[k+1]=C.g; ringCol[k+2]=C.b; }
        const gr=new THREE.BufferGeometry(); gr.setAttribute('position', new THREE.Float32BufferAttribute(ringPos,3)); gr.setAttribute('color', new THREE.Float32BufferAttribute(ringCol,3));
        const mr=new THREE.PointsMaterial({ size:4.3*scale, map: makeGlowTexture(64), transparent:true, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true });
        group.add(new THREE.Points(gr,mr));
      }
    } else if (type==='E'){
      const a=124*scale, b=86*scale, c=62*scale;
      for (let i=0;i<pts;i++){ const x=randN()*a*0.4, y=randN()*c*0.6, z=randN()*b*0.4; const k=i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z; C.setHSL(HARM, SAT*0.7, 0.86 - 0.3*Math.random()); col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b; }
    } else if (type==='Ring'){
      const R0=112*scale, r=21*scale;
      for(let i=0;i<pts;i++){ const u=Math.random()*Math.PI*2, v=Math.random()*Math.PI*2; const cu=Math.cos(u), su=Math.sin(u), cv=Math.cos(v), sv=Math.sin(v); const x=(R0 + r*cv)*cu, y=r*sv*1.2, z=(R0 + r*cv)*su; const k=i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z; C.setHSL(HARM + (Math.random()-0.5)*0.03, SAT, 0.85 - 0.25*(1+cv)/2); col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b; }
    } else { // Irr
      const clumps = 3 + Math.floor(Math.random()*3);
      const centers = Array.from({length:clumps}, ()=>({ x:(Math.random()-0.5)*120*scale, y:(Math.random()-0.5)*80*scale, z:(Math.random()-0.5)*120*scale }));
      for(let i=0;i<pts;i++){ const c0=centers[i%clumps]; const x=c0.x+randN()*18*scale, y=c0.y+randN()*14*scale, z=c0.z+randN()*18*scale; const k=i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z; C.setHSL(HARM + (Math.random()-0.5)*0.05, SAT, 0.8 - 0.3*Math.random()); col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b; }
    }

    g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
    g.setAttribute('color',    new THREE.Float32BufferAttribute(col,3));
    const m = new THREE.PointsMaterial({ size: 4.3*scale, map: makeGlowTexture(64), transparent:true, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true, alphaTest:0.05 });
    const points = new THREE.Points(g,m); points.renderOrder = -7; group.add(points);

    const coreTex = makeGlowTexture(196*scale, 'rgba(255,240,200,0.9)','rgba(255,220,160,0.75)','rgba(255,210,160,0)');
    const core = new THREE.Mesh(new THREE.PlaneGeometry(120*scale,120*scale), new THREE.MeshBasicMaterial({ map: coreTex, transparent:true, opacity:0.62, blending:THREE.AdditiveBlending, depthWrite:false, depthTest:false }));
    core.renderOrder = -7; group.add(core);

    group.userData = { points, core, type, driftPhi: Math.random()*Math.PI*2, driftAmp: 80 + Math.random()*120, driftSpeed: 0.08 + Math.random()*0.12 };
    return group;
  }

  // === Galaxy field (Fibonacci sphere to avoid closeness)
  function fibonacciSphere(n, radius){
    const pts=[];
    const phi = Math.PI * (3 - Math.sqrt(5));
    for(let i=0;i<n;i++){
      const y = 1 - (i + 0.5) * (2 / n);
      const r = Math.sqrt(1 - y*y);
      const theta = phi * i;
      pts.push({x: radius*r*Math.cos(theta), y: radius*y, z: radius*r*Math.sin(theta)});
    }
    return pts;
  }

  function buildGalaxyField(q, count=16){
    const field = new THREE.Group(); field.renderOrder = -7;
    const dist = 1300; // scaled further out
    const ptsPer = q.isMobile ? 700 : 1000;
    const shell = fibonacciSphere(count, dist);
    for (let i=0;i<count;i++){
      const pal = pickGalaxyPalette();
      const scale = 0.9 + Math.random()*0.7;
      const gal = buildTinyGalaxy(pal, ptsPer, scale);
      const s = shell[i];
      gal.position.set(s.x, s.y + (Math.random()-0.5)*260, s.z);
      gal.lookAt(0,0,0);
      gal.rotateX(Math.PI/2 - 0.12);
      gal.rotateZ((Math.random()-0.5)*0.45);
      field.add(gal);
    }
    field.userData = { dist, rotateSpeed: 0.02, t:0 };
    return field;
  }
  function updateGalaxyField(field, dt){
    if(!field) return; field.userData.t += dt;
    for(const g of field.children){
      g.rotation.z += 0.004*dt;
      // Vertical harmonic drift: y(t)=A·sin(ωt+φ)
      const A = g.userData.driftAmp || 100; const w = g.userData.driftSpeed || 0.1; const ph = g.userData.driftPhi || 0;
      const baseY = g.position.y; // keep base; we modulate around initial
      const dy = A * Math.sin(w*field.userData.t + ph);
      g.position.y = (g.userData.baseY ?? (g.userData.baseY = baseY)) + dy;
    }
  }

  // ===== Gravitational lens arcs near random "massive lenses"
  function buildLensArcs(count=5, radius=220){
    const group = new THREE.Group();
    for(let i=0;i<count;i++){
      const theta = Math.random()*Math.PI*2;
      const r = radius*(0.8+0.5*Math.random());
      const x=r*Math.cos(theta), z=r*Math.sin(theta), y = -10 + Math.random()*20;
      const arcs = Math.floor(2+Math.random()*3);
      for(let j=0;j<arcs;j++){
        const len = Math.PI*0.35*(0.7+Math.random()*0.6);
        const start = Math.random()*Math.PI*2;
        const inner = 16 + Math.random()*64;
        const outer = inner + 1.5 + Math.random()*2.5; // guarantee outer > inner
        const ring = new THREE.RingGeometry(inner, outer, 128, 1, start, len);
        const mat = new THREE.MeshBasicMaterial({ color: 0x8fd3ff, transparent:true, opacity:0.45, blending:THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false });
        const mesh = new THREE.Mesh(ring,mat); mesh.position.set(x,y,z); mesh.lookAt(0,0,0); mesh.rotateZ(Math.random()*Math.PI*2);
        group.add(mesh);
      }
    }
    group.userData = { pulse: 0 };
    return group;
  }
  function updateLensArcs(group, dt){
    if(!group) return; group.userData.pulse += dt;
    const s = 1.0 + 0.03*Math.sin(group.userData.pulse*1.7);
    for(const m of group.children){ m.scale.setScalar(s); }
  }

  // ===== Nebulae
  function buildNebulae(q){
    const group = new THREE.Group();
    const palettes=['orion','carina'];
    for(let i=0;i<q.nebulaCount;i++){
      const tex = makeNebulaTexture(768, palettes[i%palettes.length]);
      const w = 900 + Math.random()*700, h = 600 + Math.random()*400;
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(w,h),
        new THREE.MeshBasicMaterial({ map: tex, transparent:true, opacity: 0.75, depthWrite:false, blending:THREE.AdditiveBlending })
      );
      const theta = Math.random()*Math.PI*2, r = 480 + Math.random()*520, y = -60 + Math.random()*140;
      plane.position.set(r*Math.cos(theta), y, r*Math.sin(theta));
      plane.lookAt(0,0,0);
      plane.rotateZ((Math.random()-0.5)*0.5);
      group.add(plane);
    }
    group.userData = { wobble: 0, enabled: true };
    return group;
  }
  function updateNebulae(group, dt){
    if(!group || !group.userData.enabled) return; group.userData.wobble += dt;
    const wob = 0.015*Math.sin(group.userData.wobble*0.7);
    for(const n of group.children){ n.rotation.z += wob*dt; }
  }

  // ===== Gamma-Ray Burst (GRB) system
  function createGRBSystem(scene){
    const flashTex = makeGlowTexture(256, 'rgba(255,255,255,1)','rgba(255,220,160,0.9)','rgba(255,180,120,0)');
    const particlesGeo = new THREE.BufferGeometry();
    const P = 800; const ppos = new Float32Array(P*3), pvel = new Float32Array(P*3), plife=new Float32Array(P), pmax=new Float32Array(P);
    particlesGeo.setAttribute('position', new THREE.Float32BufferAttribute(ppos,3));
    const pmat = new THREE.PointsMaterial({ size: 6.0, map: makeGlowTexture(64,'rgba(255,255,255,1)','rgba(180,200,255,0.9)','rgba(180,200,255,0)'), transparent:true, depthWrite:false, blending:THREE.AdditiveBlending });
    const points = new THREE.Points(particlesGeo, pmat); points.visible=false; scene.add(points);

    const flash = new THREE.Sprite(new THREE.SpriteMaterial({ map: flashTex, color: 0xffffff, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false })); flash.visible=false; scene.add(flash);

    const coneMat = new THREE.MeshBasicMaterial({ color:0xfff0aa, transparent:true, opacity:0.45, blending:THREE.AdditiveBlending, depthWrite:false, side:THREE.DoubleSide });
    const cone = new THREE.Mesh(new THREE.ConeGeometry(12, 600, 24, 1, true), coneMat); cone.visible=false; scene.add(cone);

    const state = { active:false, t:0, origin:new THREE.Vector3(), dir:new THREE.Vector3(0,1,0), lastTime:0 };

    function trigger(pos, dir){
      state.active=true; state.t=0; state.origin.copy(pos); state.dir.copy(dir).normalize(); state.lastTime=performance.now();
      flash.position.copy(pos); flash.scale.setScalar(220); flash.material.opacity=1; flash.visible=true;

      cone.position.copy(pos); const q=new THREE.Quaternion(); q.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize()); cone.setRotationFromQuaternion(q); cone.visible=true;

      // Seed particles isotropically around the jet axis (relativistic shell approx.)
      for(let i=0;i<P;i++){
        const theta = (Math.random()**0.3) * 0.35; // concentrated within small angle
        const phi = Math.random()*Math.PI*2;
        const vx = Math.sin(theta)*Math.cos(phi), vy = Math.cos(theta), vz = Math.sin(theta)*Math.sin(phi);
        const v = new THREE.Vector3(vx,vy,vz).applyQuaternion(q).normalize().multiplyScalar(260 + Math.random()*180);
        const k=i*3; ppos[k]=pos.x; ppos[k+1]=pos.y; ppos[k+2]=pos.z; pvel[k]=v.x; pvel[k+1]=v.y; pvel[k+2]=v.z; plife[i]=0; pmax[i]=0.8+Math.random()*1.2;
      }
      particlesGeo.attributes.position.needsUpdate=true; points.visible=true;
    }

    function update(dt){
      if(!state.active) return;
      state.t += dt;
      // Flash fade & expand
      flash.material.opacity = Math.max(0, 1 - state.t*1.8);
      const s = 220 + state.t*500; flash.scale.set(s,s,1); if (flash.material.opacity<=0.02) flash.visible=false;

      // Cone fade
      cone.material.opacity = Math.max(0, 0.45 - state.t*0.5);
      if (cone.material.opacity<=0.02) cone.visible=false;

      // Particles
      const pos = particlesGeo.attributes.position.array;
      for(let i=0;i<plife.length;i++){
        plife[i]+=dt; const k=i*3;
        pos[k]   += pvel[k]*dt;
        pos[k+1] += pvel[k+1]*dt;
        pos[k+2] += pvel[k+2]*dt;
      }
      particlesGeo.attributes.position.needsUpdate=true;
      pmat.opacity = Math.max(0, 1 - state.t*0.9);

      if (state.t > 2.2){ // end event
        state.active=false; points.visible=false; cone.visible=false; flash.visible=false;
      }
    }

    return { trigger, update, state };
  }

  // ===== Main Three.js app =====
  function initThreeScene(){
    if (typeof THREE === 'undefined') throw new Error('Three.js not present after loader.');
    const WIDTH=1280, HEIGHT=720, ASPECT=WIDTH/HEIGHT; const q = chooseQuality();
    const container = document.getElementById('container'); const fpsHolder = document.getElementById('fps'); const note = document.getElementById('note'); const placeholder = document.getElementById('placeholder');
    note.textContent = `${APP_VERSION} • ${APP_CODENAME}`;

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(WIDTH, HEIGHT, false); renderer.setPixelRatio(q.dpr);
    container.appendChild(renderer.domElement); applyScaleAll(); placeholder.style.display='none';

    const StatsCtor = (typeof window !== 'undefined' && window.Stats) ? window.Stats : MiniStats; const stats = new StatsCtor(); if (stats.showPanel) stats.showPanel(0); fpsHolder.appendChild(stats.dom);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, ASPECT, 0.1, 4000); camera.position.set(0, 72, 180);
    window._camera = camera;

    // Star background
    function makeStarTexture(size=2048){ const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size); const n=3800; for(let i=0;i<n;i++){ const x=Math.random()*size, y=Math.random()*size; const r=Math.random()*1.8+0.2; const l=72+Math.random()*28; const hue = Math.random()<0.75 ? (200+Math.random()*40) : (40+Math.random()*20); ctx.fillStyle=`hsl(${hue},100%,${l}%)`; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); } return new THREE.CanvasTexture(c); }
    const skyTex = makeStarTexture(1024);
    const sky = new THREE.Mesh(new THREE.SphereGeometry(1800,64,64), new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide, depthWrite:false })); scene.add(sky); sky.renderOrder = -10;

    const andromeda = buildAndromedaGalaxy(q); scene.add(andromeda); window._andromeda = andromeda;
    const galaxyField = buildGalaxyField(q, 18); scene.add(galaxyField); window._galaxyField = galaxyField;

    const lensArcs = buildLensArcs(6, 260); scene.add(lensArcs); window._lensArcs = lensArcs;
    const nebulae = buildNebulae(q); scene.add(nebulae); window._nebulae = nebulae;

    scene.add(new THREE.AmbientLight(0x333333));
    const terrain = new THREE.Mesh(new THREE.PlaneGeometry(1200,1200,1,1).rotateX(-Math.PI/2), new THREE.MeshStandardMaterial({ color:0x101c12, flatShading:true, metalness:0, roughness:1 })); scene.add(terrain);

    const blackHole = buildBlackHole(q); blackHole.position.set(0, 62, 0); scene.add(blackHole); window._blackHole = blackHole;

    // Controls
    const keyState = Object.create(null); window._keyState = keyState;
    window.addEventListener('keydown', (e) => { keyState[e.key]=true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault(); });
    window.addEventListener('keyup',   (e) => { keyState[e.key]=false; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault(); });

    const touches = new Map(); let touchAgg = { yaw: 0, throttle: 0 }; let touchYawSm=0, touchThrottleSm=0; const maxR=140, dead=12;
    const stickL = document.createElement('div'); stickL.className='stick'; const nubL = document.createElement('div'); nubL.className='nub'; stickL.appendChild(nubL); container.appendChild(stickL);
    const stickR = document.createElement('div'); stickR.className='stick'; const nubR = document.createElement('div'); nubR.className='nub'; stickR.appendChild(nubR); container.appendChild(stickR);
    function updateStickUI(){ let leftTouch=null,rightTouch=null; for (const t of touches.values()){ if (t.zone==='left' && !leftTouch) leftTouch=t; if (t.zone==='right' && !rightTouch) rightTouch=t; } const upd=(t,stick,nub)=>{ if(!t){ stick.style.display='none'; return; } stick.style.display='block'; stick.style.left=t.ox+'px'; stick.style.top=t.oy+'px'; const dx=t.x-t.ox, dy=t.y-t.oy; const r=Math.hypot(dx,dy), m=r>maxR?maxR/r:1; nub.style.transform=`translate(${dx*m}px, ${dy*m}px)`; }; upd(leftTouch,stickL,nubL); upd(rightTouch,stickR,nubR); }
    function recomputeAgg(){ let yaw=0,yc=0,thr=0,tc=0; for (const t of touches.values()){ const dx=t.x-t.ox, dy=t.y-t.oy; const ndx=(Math.abs(dx)<dead?0:dx)/maxR; const ndy=(Math.abs(dy)<dead?0:dy)/maxR; if(t.zone==='right'){ yaw += ndx; yc++; } else { thr += -ndy; tc++; } } touchAgg.yaw=Math.max(-1,Math.min(1,yc?yaw/yc:0)); touchAgg.throttle=Math.max(-1,Math.min(1,tc?thr/tc:0)); }
    renderer.domElement.style.touchAction='none'; const canvasEl = renderer.domElement; function zoneFor(e){ const r=canvasEl.getBoundingClientRect(); return (e.clientX < r.left + r.width/2) ? 'left':'right'; }
    canvasEl.addEventListener('pointerdown', (e)=>{ if(!e.isPrimary) return; if(e.pointerType!=='touch' && e.pointerType!=='pen') return; const z=zoneFor(e); touches.set(e.pointerId,{id:e.pointerId,zone:z,ox:e.clientX,oy:e.clientY,x:e.clientX,y:e.clientY}); if (canvasEl.setPointerCapture) { try { canvasEl.setPointerCapture(e.pointerId); } catch(err){} } recomputeAgg(); updateStickUI(); e.preventDefault(); }, {passive:false});
    canvasEl.addEventListener('pointermove', (e)=>{ const t=touches.get(e.pointerId); if(!t) return; t.x=e.clientX; t.y=e.clientY; recomputeAgg(); updateStickUI(); e.preventDefault(); }, {passive:false});
    function endTouch(e){ const t=touches.get(e.pointerId); if(!t) return; touches.delete(e.pointerId); recomputeAgg(); updateStickUI(); if (canvasEl.releasePointerCapture) { try { canvasEl.releasePointerCapture(e.pointerId); } catch(err){} } e.preventDefault(); }
    canvasEl.addEventListener('pointerup', (e)=>{ if(e.pointerType!=='touch' && e.pointerType!=='pen') return; endTouch(e); }, {passive:false});
    canvasEl.addEventListener('pointercancel', (e)=>{ if(e.pointerType!=='touch' && e.pointerType!=='pen') return; endTouch(e); }, {passive:false});
    canvasEl.addEventListener('pointerleave', (e)=>{ if(e.pointerType!=='touch' && e.pointerType!=='pen') return; endTouch(e); }, {passive:false});
    window._touches = touches; function getTouchInput(){ return { yaw: touchYawSm, throttle: touchThrottleSm }; } window._getTouchInput = getTouchInput;

    const auto = { enabled: true, theta: 0, speed: 0.38, radiusBase: 260, radiusAmp: 170, heightBase: 95, heightAmp: 32, bobAmp: 12, bobSpeed: 0.85, lookAtOffset: new THREE.Vector3(0,8,0) };
    window._auto = auto;

    const controls = { yaw: 0, speed: 68, turnSpeed: Math.PI, height: 72, bounds: 560 };
    camera.position.set(0, controls.height, 180); camera.lookAt(0,0,0);
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function updateControls(dt){
      if (auto.enabled){
        auto.theta += auto.speed * dt;
        const target = blackHole.position.clone().add(auto.lookAtOffset);
        const r = Math.max(110, auto.radiusBase + auto.radiusAmp * Math.sin(auto.theta * 0.33));
        const camX = target.x + r * Math.cos(auto.theta);
        const camZ = target.z + r * Math.sin(auto.theta);
        const camY = auto.heightBase + auto.heightAmp * Math.cos(auto.theta * 0.42) + Math.sin(auto.theta * auto.bobSpeed * 2.0) * auto.bobAmp;
        camera.position.set(camX, camY, camZ);
        camera.lookAt(target);
        controls.yaw = Math.atan2(target.x - camX, camZ - target.z);
        return;
      }

      let yawInput = 0; if (keyState['ArrowLeft']) yawInput += 1; if (keyState['ArrowRight']) yawInput -= 1;
      let throttleInput = 0; if (keyState['ArrowUp']) throttleInput += 1; if (keyState['ArrowDown']) throttleInput -= 1;
      const k = 1 - Math.exp(-dt * 12); touchYawSm += (touchAgg.yaw - touchYawSm) * k; touchThrottleSm += (touchAgg.throttle - touchThrottleSm) * k;
      yawInput = Math.max(-1, Math.min(1, yawInput + touchYawSm));
      throttleInput = Math.max(-1, Math.min(1, throttleInput + touchThrottleSm));
      controls.yaw += controls.turnSpeed * dt * yawInput;
      const forward = new THREE.Vector3(Math.sin(controls.yaw), 0, -Math.cos(controls.yaw));
      if (Math.abs(throttleInput) > 1e-3) { const move = forward.clone().multiplyScalar(controls.speed * dt * throttleInput); const p = camera.position.clone().add(move); p.y=controls.height; p.x=clamp(p.x,-controls.bounds,controls.bounds); p.z=clamp(p.z,-controls.bounds,controls.bounds); camera.position.copy(p); }
      camera.lookAt(camera.position.clone().add(forward));
    }
    window._updateControls = updateControls;

    // GRB system
    const grb = createGRBSystem(scene); window._grb = grb;

    // Key actions
    window.addEventListener('keydown', (e)=>{
      if (e.key==='A' || e.key==='a'){ auto.enabled = !auto.enabled; }
      if (e.key==='N' || e.key==='n'){ nebulae.userData.enabled = !nebulae.userData.enabled; nebulae.visible = nebulae.userData.enabled; }
      if (e.key==='G' || e.key==='g'){ const target = blackHole.position.clone(); const dir = new THREE.Vector3(Math.random()-0.5,1,Math.random()-0.5).normalize(); grb.trigger(target.clone().add(new THREE.Vector3(0,60,0)), dir); }
      if (e.key==='R' || e.key==='r'){ camera.position.set(0, controls.height, 180); controls.yaw=0; auto.enabled=true; }
    });

    let _lastTime = performance.now();
    function animate(){
      const now = performance.now(); const dt = Math.min(0.05, (now - _lastTime) / 1000); _lastTime = now;
      if (stats.begin) stats.begin();
      // Smooth touch input
      const k = 1 - Math.exp(-dt * 12); touchYawSm += (touchAgg.yaw - touchYawSm) * k; touchThrottleSm += (touchAgg.throttle - touchThrottleSm) * k;

      updateControls(dt); updateBlackHole(blackHole, dt); updateAndromeda(andromeda, dt); updateGalaxyField(galaxyField, dt); updateLensArcs(lensArcs, dt); updateNebulae(nebulae, dt); grb.update(dt);
      renderer.render(scene, camera);
      if (stats.end) stats.end();
      requestAnimationFrame(animate);
    }

    animate();

    // === Self-tests
    setTimeout(()=>{
      try{
        console.assert(window._andromeda, 'Andromeda exists');
        console.assert(window._blackHole?.userData?.flares?.length >= 20, 'Gamma flares present');
        console.assert(window._galaxyField && window._galaxyField.children.length >= 14, 'Galaxy field size OK');
        console.assert(window._lensArcs && window._lensArcs.children.length > 0, 'Lens arcs present');
        console.assert(window._nebulae && window._nebulae.children.length >= 3, 'Nebulae present');
        console.assert(document.getElementById('container').dataset.appVersion === APP_VERSION, 'data-app-version matches');
      }catch(e){ console.warn('Self-tests failed:', e); }
    }, 1200);
  }

  // ===== Fallback (Canvas 2D) — minimal but pretty
  function initCanvasFallback(cause){
    const container = document.getElementById('container'); const fpsHolder = document.getElementById('fps'); const note = document.getElementById('note'); note.textContent = `${APP_VERSION} • Fallback: Canvas space`; const placeholder = document.getElementById('placeholder'); placeholder.style.display='none';
    const canvas = document.createElement('canvas'); const WIDTH=1280, HEIGHT=720; canvas.width=WIDTH; canvas.height=HEIGHT; container.appendChild(canvas); applyScaleAll();
    const stats = new MiniStats(); fpsHolder.appendChild(stats.dom); const ctx = canvas.getContext('2d');
    const stars = Array.from({length: 1600}, ()=>({ x: Math.random()*WIDTH, y: Math.random()*HEIGHT, z: Math.random()*2+0.2 }));
    let t=0;
    function frame(){ stats.begin(); t+=1/60; ctx.fillStyle='#000'; ctx.fillRect(0,0,WIDTH,HEIGHT);
      for(const s of stars){ s.x -= s.z*0.3; if(s.x<0) s.x += WIDTH; const b = 150 + Math.floor(s.z*50); ctx.fillStyle=`rgb(${b},${b},${b})`; ctx.fillRect(s.x, s.y, 2, 2);} 
      const cx=WIDTH*0.5, cy=HEIGHT*0.52;
      ctx.save(); ctx.translate(cx-180, cy-120); ctx.rotate(0.2); ctx.globalCompositeOperation='lighter'; ctx.fillStyle='rgba(255,230,180,0.10)'; for(let r=40;r<240;r+=14){ ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.fill(); } ctx.restore(); ctx.globalCompositeOperation='source-over';
      ctx.fillStyle='#000'; ctx.beginPath(); ctx.arc(cx,cy,28,0,Math.PI*2); ctx.fill();
      ctx.save(); ctx.translate(cx,cy); ctx.rotate(t*0.2); ctx.globalCompositeOperation='lighter'; ctx.strokeStyle='rgba(255,200,100,0.9)'; ctx.lineWidth=3; ctx.beginPath(); ctx.ellipse(0,0,34,34,0,0,Math.PI*2); ctx.stroke();
      ctx.strokeStyle='rgba(255,170,80,0.35)'; ctx.lineWidth=2; for(let i=0;i<20;i++){ const r=36+Math.random()*46; ctx.beginPath(); ctx.arc(0,0,r,0,Math.PI*2); ctx.stroke(); }
      for(let i=0;i<22;i++){ const life=(t*0.7+i*0.1)%1.6; const dir=i%2?1:-1; const y=(life*180-90)*dir; const op=Math.max(0,1-(life*life)); ctx.fillStyle=`rgba(120,180,255,${0.9*op})`; ctx.beginPath(); ctx.ellipse(0,y,7+10*(1-life),7+5*(1-life),0,0,Math.PI*2); ctx.fill(); }
      ctx.restore(); stats.end(); requestAnimationFrame(frame); }
    frame();
    showErrorOverlay('Three.js failed to load — running fallback renderer.', cause);
  }
  </script>
</body>
</html>
