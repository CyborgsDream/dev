<!--
/**
 * @version   v1.9.1
 * @codename  "CELESTIAL_TERRAIN_HYPERLUMINAL"
 * @author    Codex Prodigy
 * @date      2025-08-13
 * @log       Major visual upgrade: lensing, GRB system, nebulae, galaxy distancing & vertical drift
 * @changelog
 *   - [2025-08-13] Re-architected galaxy placement (Fibonacci sphere) to avoid clustering; added vertical oscillation
 *   - [2025-08-13] Added procedural nebulae (noise billboards) with Hubble-like palettes
 *   - [2025-08-13] Implemented gravitational lens arcs and micro-lenses near massive objects
 *   - [2025-08-13] Added Gamma-Ray Burst (GRB) event system: cones, sprites, relativistic particle shell
 *   - [2025-08-13] Enhanced BH disk thickness model; tuned flares; upgraded starfield seeding
 */
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>The Universe</title>
  <style>
    :root {
      --panel-bg: rgba(7, 14, 28, 0.72);
      --panel-bg-folded: rgba(7, 14, 28, 0.45);
      --panel-border: rgba(120, 188, 255, 0.32);
      --panel-border-light: rgba(180, 220, 255, 0.18);
      --accent: #78c2ff;
      --accent-strong: #9ce6ff;
      --text-white: #ffffff;
      --text-soft: rgba(210, 230, 255, 0.78);
      --graph-grid: rgba(140, 200, 255, 0.25);
      --graph-fill: rgba(120, 194, 255, 0.18);
      --graph-line: #7ed1ff;
    }
    *, *::before, *::after { box-sizing: border-box; }
    html, body {
      height: 100%;
      width: 100%;
    }
    body {
      margin: 0;
      background: radial-gradient(ellipse at 65% 35%, rgba(20, 60, 112, 0.35), rgba(4, 10, 18, 0.92) 55%, #000 100%);
      color: var(--text-white);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      overflow: hidden;
      min-height: 100vh;
      min-height: 100svh;
    }
    #container {
      position: fixed;
      inset: 0;
      overflow: hidden;
      line-height: 0;
    }
    #container canvas {
      display: block;
      width: 100%;
      height: 100%;
      touch-action: none;
    }
    #placeholder {
      position: absolute;
      inset: 0;
      z-index: 5;
      display: grid;
      place-items: center;
      background: radial-gradient(ellipse at 60% 40%, #10202a 0%, #05070b 55%, #000 100%);
      color: #9cc7ff;
      font: 600 14px/1.2 system-ui, sans-serif;
      box-shadow: inset 0 0 120px rgba(0,0,0,0.8);
    }
    #overlay-error {
      position: absolute;
      inset: 0;
      display: none;
      z-index: 30;
      background: rgba(0,0,0,0.85);
      color: #fff;
      padding: 16px;
      font-size: 14px;
      line-height: 1.4;
      overflow: auto;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.12);
    }
    #overlay-error pre { white-space: pre-wrap; }
    #note {
      position: fixed;
      bottom: calc(10px + env(safe-area-inset-bottom));
      left: calc(14px + env(safe-area-inset-left));
      opacity: .85;
      font-size: 12px;
      letter-spacing: .2px;
      z-index: 10;
      text-transform: uppercase;
      pointer-events: none;
    }
    #fps {
      position: fixed;
      top: calc(16px + env(safe-area-inset-top));
      left: calc(16px + env(safe-area-inset-left));
      z-index: 40;
      pointer-events: none;
    }
    #control-ui {
      position: fixed;
      top: calc(16px + env(safe-area-inset-top));
      right: calc(16px + env(safe-area-inset-right));
      background: var(--panel-bg);
      border: 1px solid var(--panel-border);
      box-shadow: inset 0 0 0 1px var(--panel-border-light), 0 18px 36px rgba(0,0,0,0.55);
      padding: 16px 18px 20px;
      display: grid;
      row-gap: 12px;
      width: min(240px, 82vw);
      z-index: 38;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--text-white);
      backdrop-filter: blur(16px);
      transition: background 0.35s ease, border-color 0.35s ease, box-shadow 0.35s ease;
    }
    #control-ui.folded {
      background: var(--panel-bg-folded);
      border-color: rgba(126, 180, 255, 0.22);
      box-shadow: inset 0 0 0 1px rgba(180, 220, 255, 0.12), 0 12px 24px rgba(0,0,0,0.45);
    }
    #control-ui.resolution-updated {
      box-shadow: inset 0 0 0 1px rgba(180, 220, 255, 0.28), 0 22px 48px rgba(70, 150, 255, 0.45);
    }
    #control-ui .ui-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 10px;
    }
    #control-ui h2 {
      margin: 0;
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.66rem;
      letter-spacing: 0.18em;
      color: var(--accent);
    }
    #control-ui h2 span:last-child {
      color: var(--text-white);
      letter-spacing: 0.24em;
    }
    #ui-fold-btn {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      border: 1px solid rgba(142, 198, 255, 0.42);
      background: rgba(10, 20, 38, 0.55);
      color: var(--text-white);
      font-size: 0.52rem;
      letter-spacing: 0.18em;
      padding: 5px 10px;
      cursor: pointer;
      text-transform: uppercase;
      transition: background 0.2s ease, border-color 0.2s ease, transform 0.2s ease, opacity 0.2s ease;
    }
    #ui-fold-btn:hover {
      background: rgba(120, 194, 255, 0.28);
      border-color: rgba(126, 200, 255, 0.7);
      transform: translateY(-1px);
    }
    #ui-fold-btn:active {
      transform: translateY(1px);
    }
    #ui-fold-btn .fold-icon {
      width: 16px;
      height: 16px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.35s ease;
    }
    #ui-fold-btn .fold-icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
      transform-origin: center;
      transition: transform 0.35s ease;
    }
    #control-ui.folded #ui-fold-btn .fold-icon svg {
      transform: rotate(-90deg);
    }
    .fold-body {
      display: grid;
      row-gap: 12px;
      max-height: 400px;
      overflow: hidden;
      transition: max-height 0.35s ease, opacity 0.25s ease;
    }
    #control-ui.folded .fold-body {
      max-height: 0;
      opacity: 0;
      pointer-events: none;
    }
    .ui-icon {
      width: 22px;
      height: 22px;
      display: grid;
      place-items: center;
      perspective: 400px;
    }
    .ui-icon svg {
      width: 100%;
      height: 100%;
      fill: currentColor;
      filter: drop-shadow(0 0 6px rgba(120, 194, 255, 0.45));
    }
    #resolution-display {
      font-size: 0.74rem;
      font-weight: 700;
      color: var(--text-white);
      text-shadow: 0 0 12px rgba(120, 194, 255, 0.4);
    }
    label[for="resolution-select"] {
      font-size: 0.62rem;
      color: var(--text-soft);
    }
    .select-wrap {
      position: relative;
    }
    .select-wrap .native-select {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      opacity: 0;
      pointer-events: none;
    }
    .resolution-dropdown {
      position: relative;
    }
    .resolution-dropdown-button {
      width: 100%;
      padding: 6px 28px 6px 10px;
      border-radius: 0;
      border: 1px solid rgba(120, 194, 255, 0.3);
      background: rgba(6, 14, 28, 0.7);
      color: var(--text-white);
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      text-align: left;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      box-shadow: inset 0 0 0 1px rgba(180, 220, 255, 0.22);
      transition: border-color 0.2s ease, box-shadow 0.2s ease, background 0.2s ease;
    }
    .resolution-dropdown-button::after {
      content: '';
      width: 8px;
      height: 8px;
      border-right: 2px solid var(--accent-strong);
      border-bottom: 2px solid var(--accent-strong);
      transform: rotate(45deg);
      flex-shrink: 0;
    }
    .resolution-dropdown-button:focus-visible,
    .resolution-dropdown-button:hover {
      border-color: rgba(126, 200, 255, 0.85);
      box-shadow: 0 0 0 1px rgba(126, 200, 255, 0.5), 0 0 0 4px rgba(126, 200, 255, 0.2);
      background: rgba(10, 20, 38, 0.7);
    }
    .resolution-dropdown-button[aria-expanded="true"]::after {
      transform: rotate(225deg);
    }
    .resolution-dropdown-list {
      list-style: none;
      margin: 4px 0 0;
      padding: 4px 0;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background: rgba(5, 12, 24, 0.95);
      border: 1px solid rgba(120, 194, 255, 0.32);
      box-shadow: 0 16px 28px rgba(0, 0, 0, 0.45);
      max-height: 182px;
      overflow-y: auto;
      z-index: 10;
      display: none;
    }
    .resolution-dropdown-list.is-open {
      display: block;
    }
    .resolution-dropdown-option {
      padding: 6px 12px;
      font-size: 0.64rem;
      letter-spacing: 0.05em;
      cursor: pointer;
      color: var(--text-white);
      display: flex;
      align-items: center;
    }
    .resolution-dropdown-option:hover,
    .resolution-dropdown-option.is-active {
      background: rgba(120, 194, 255, 0.18);
    }
    .resolution-dropdown-option.is-selected {
      color: var(--accent-strong);
    }
    .resolution-dropdown-option.is-disabled {
      opacity: 0.5;
      cursor: default;
    }
    .select-wrap.enhanced-dropdown::after {
      display: none;
    }
    .select-wrap::after {
      content: '';
      position: absolute;
      top: 50%;
      right: 12px;
      width: 8px;
      height: 8px;
      border-right: 2px solid var(--accent-strong);
      border-bottom: 2px solid var(--accent-strong);
      transform: translateY(-50%) rotate(45deg);
      pointer-events: none;
    }
    #resolution-select {
      width: 100%;
      padding: 6px 28px 6px 10px;
      border-radius: 0;
      border: 1px solid rgba(120, 194, 255, 0.3);
      background: rgba(6, 14, 28, 0.7);
      color: var(--text-white);
      font-size: 0.66rem;
      font-weight: 700;
      letter-spacing: 0.05em;
      appearance: none;
      outline: none;
      box-shadow: inset 0 0 0 1px rgba(180, 220, 255, 0.22);
    }
    #resolution-select:focus {
      border-color: rgba(126, 200, 255, 0.85);
      box-shadow: 0 0 0 1px rgba(126, 200, 255, 0.5), 0 0 0 4px rgba(126, 200, 255, 0.2);
    }
    #fps-monitor {
      pointer-events: none;
      min-width: 180px;
      padding: 14px 16px;
      background: rgba(6, 12, 26, 0.62);
      border: 1px solid rgba(120, 194, 255, 0.32);
      box-shadow: inset 0 0 0 1px rgba(180, 220, 255, 0.18), 0 12px 26px rgba(0,0,0,0.45);
      display: grid;
      row-gap: 8px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
    }
    #fps-monitor .panel-title {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.64rem;
      color: var(--accent);
    }
    #fps-monitor .panel-title .label {
      color: var(--text-white);
      letter-spacing: 0.18em;
    }
    #fps-monitor .fps-readout {
      display: flex;
      align-items: baseline;
      gap: 6px;
      font-family: 'Lucida Console', 'Courier New', monospace;
      color: var(--text-white);
    }
    #fps-monitor .fps-label {
      font-size: 0.58rem;
      color: var(--accent);
    }
    #fps-monitor .fps-value {
      font-size: 1.4rem;
      font-weight: 700;
      min-width: 3.6em;
      text-shadow: 0 0 14px rgba(126, 200, 255, 0.35);
    }
    #fps-monitor .fps-graph {
      width: 100%;
      height: 48px;
      border: 1px solid rgba(120, 194, 255, 0.32);
      background: rgba(3, 8, 18, 0.9);
      box-shadow: inset 0 0 0 1px rgba(180, 220, 255, 0.12);
    }
    .hud {
      position: fixed;
      top: calc(70px + env(safe-area-inset-top));
      right: calc(18px + env(safe-area-inset-right));
      z-index: 15;
      font: 12px/1.2 ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      opacity: .88;
      text-align: right;
      letter-spacing: 0.08em;
    }
    .stick{
      position:absolute;
      width:120px;
      height:120px;
      margin:-60px 0 0 -60px;
      border:1px solid rgba(255,255,255,.25);
      border-radius:50%;
      display:none;
      z-index:15;
      pointer-events:none;
      backdrop-filter: blur(4px);
      background: rgba(10, 20, 38, 0.2);
    }
    .stick .nub{
      position:absolute;
      left:50%;
      top:50%;
      width:36px;
      height:36px;
      margin:-18px 0 0 -18px;
      border-radius:50%;
      background:rgba(255,255,255,.18);
      box-shadow:0 0 12px rgba(126,200,255,0.4) inset;
    }
    kbd {
      background:#0b1528;
      border:1px solid rgba(126,200,255,0.35);
      border-bottom-color:rgba(80,150,220,0.35);
      border-radius:4px;
      padding:.5px 4px;
      font-weight:600;
      color:#d6ecff;
    }
    @media (max-width: 600px) {
      #control-ui {
        width: min(280px, 92vw);
        row-gap: 10px;
        font-size: 0.95em;
      }
      #fps-monitor {
        min-width: 0;
        width: min(220px, 80vw);
      }
      .hud {
        top: calc(110px + env(safe-area-inset-top));
        right: calc(12px + env(safe-area-inset-right));
        text-align: left;
      }
    }
  </style>
</head>
<body>
  <div id="container" data-app-version="v1.9.1">
    <div id="fps"></div>
    <div id="control-ui">
      <div class="ui-header">
        <h2>
          <span class="ui-icon" aria-hidden="true">
            <svg viewBox="0 0 24 24" role="presentation">
              <circle cx="12" cy="12" r="10" opacity="0.35"></circle>
              <path d="M12 4.5l2.9 5 5.6.8-4.1 4 1 5.7L12 17.8 6.6 20l1-5.7-4.1-4 5.6-.8z" fill="currentColor" opacity="0.85"></path>
              <circle cx="12" cy="12" r="2.4" fill="var(--accent)"></circle>
            </svg>
          </span>
          <span>Observatory</span>
          <span>Control</span>
        </h2>
        <button id="ui-fold-btn" type="button" aria-label="Collapse control panel" aria-expanded="true" aria-controls="ui-foldable">
          <span class="fold-icon" aria-hidden="true">
            <svg viewBox="0 0 16 16" role="presentation" focusable="false">
              <path d="M4.2 2.8a1 1 0 0 1 1.6 0l4 5a1 1 0 0 1 0 1.2l-4 5a1 1 0 0 1-1.6-1.2L7.7 8 4.2 4a1 1 0 0 1 0-1.2z"></path>
            </svg>
          </span>
        </button>
      </div>
      <div id="ui-foldable" class="fold-body">
        <div id="resolution-display">—</div>
        <label for="resolution-select">Resolution</label>
        <div class="select-wrap">
          <select id="resolution-select" aria-label="Resolution selector">
            <option value="256x144">144p — 256 × 144</option>
            <option value="426x240">240p — 426 × 240</option>
            <option value="640x360">360p — 640 × 360</option>
            <option value="854x480">480p — 854 × 480</option>
            <option value="1280x720" selected>720p — 1280 × 720</option>
            <option value="1920x1080">1080p — 1920 × 1080</option>
            <option value="2560x1440">1440p — 2560 × 1440</option>
            <option value="3840x2160">2160p — 3840 × 2160</option>
          </select>
        </div>
      </div>
    </div>
    <div class="hud">
      <div><kbd>G</kbd> GRB • <kbd>N</kbd> Nebula • <kbd>A</kbd> AutoCam • <kbd>↑↓←→</kbd> Manual • <kbd>R</kbd> Reset</div>
    </div>
    <div id="overlay-error"></div>
    <div id="note">v1.9.1 • Booting…</div>
    <div id="placeholder">Loading 3D scene…</div>
  </div>
  <noscript>This demo requires JavaScript enabled.</noscript>

  <script>
  // ===== Version =====
  const APP_VERSION  = 'v1.9.1';
  const APP_CODENAME = 'CELESTIAL_TERRAIN_HYPERLUMINAL';
  window.APP_VERSION = APP_VERSION; window.APP_CODENAME = APP_CODENAME;

  // ===== Error overlay =====
  const overlayError = document.getElementById('overlay-error');
  function showErrorOverlay(msg, error) {
    overlayError.style.display = 'block';
    overlayError.innerHTML = '<strong>Runtime Error</strong><br><br>' +
      '<pre>' + (msg || '') + (error ? ('\n' + (error.stack || error.message || error)) : '') + '</pre>' +
      '<p style="opacity:.75">Tip: If external CDNs are blocked, the built-in fallback renderer will take over.</p>';
    console.error(msg, error);
  }
  window.addEventListener('error', (e) => { try { showErrorOverlay(e.message || 'Error', e.error || e); } catch(err) { console.error(err); } }, true);
  window.addEventListener('unhandledrejection', (e) => { try { showErrorOverlay('Unhandled Promise Rejection', e.reason); } catch(err) { console.error(err); } });

  // ===== Loader with timeout =====
  function loadScript(url, timeoutMs = 9000) {
    return new Promise((resolve, reject) => {
      const s = document.createElement('script');
      const t = setTimeout(() => { s.onload = s.onerror = null; reject(new Error('Timeout loading: ' + url)); }, timeoutMs);
      s.src = url; s.async = true; s.defer = true; s.crossOrigin = 'anonymous'; s.referrerPolicy = 'no-referrer';
      s.onload = () => { clearTimeout(t); resolve(url); };
      s.onerror = () => { clearTimeout(t); reject(new Error('Failed to load: ' + url)); };
      document.head.appendChild(s);
    });
  }
  async function loadFirstAvailable(urls) {
    let lastErr;
    for (const u of urls) {
      try { await loadScript(u); return u; }
      catch (e) { lastErr = e; console.warn(e.message); }
    }
    throw lastErr || new Error('All URLs failed: ' + urls.join(', '));
  }

  // ===== FPS fallback =====
  class MiniStats {
    constructor(){ this.dom=document.createElement('div'); this.dom.style.cssText='background:rgba(0,0,0,.6);padding:4px 6px;font:12px/1.2 monospace;'; this.label=document.createElement('div'); this.dom.appendChild(this.label); this._smoothing=0.9; this._fps=0; this._valid=false; this.begin(); }
    begin(){ this._tick=performance.now(); }
    end(){ const now=performance.now(); const dt=now-this._tick; const inst=1000/Math.max(dt,0.0001); this._fps=this._valid?(this._smoothing*this._fps+(1-this._smoothing)*inst):inst; this._valid=true; this.label.textContent=`FPS: ${this._fps.toFixed(1)} | ms: ${dt.toFixed(2)}`; }
    showPanel(){}
  }

  const RESOLUTION_PRESETS = [
    { label: '144p', width: 256, height: 144 },
    { label: '240p', width: 426, height: 240 },
    { label: '360p', width: 640, height: 360 },
    { label: '480p', width: 854, height: 480 },
    { label: '720p', width: 1280, height: 720 },
    { label: '1080p', width: 1920, height: 1080 },
    { label: '1440p', width: 2560, height: 1440 },
    { label: '2160p', width: 3840, height: 2160 }
  ];
  const RESOLUTION_BASE_HEIGHT = 720;

  function parseResolutionValue(value){
    if (!value || typeof value !== 'string') return RESOLUTION_PRESETS[4];
    const parts = value.split('x');
    if (parts.length !== 2) return RESOLUTION_PRESETS[4];
    const w = Number(parts[0]);
    const h = Number(parts[1]);
    const preset = RESOLUTION_PRESETS.find(p => p.width === w && p.height === h);
    return preset || RESOLUTION_PRESETS[4];
  }

  function computeScaledDimensions(preset, viewportWidth, viewportHeight){
    const scale = preset.height / RESOLUTION_BASE_HEIGHT;
    const width = Math.max(1, Math.round(Math.max(1, viewportWidth) * scale));
    const height = Math.max(1, Math.round(Math.max(1, viewportHeight) * scale));
    return { width, height, scale };
  }

  function formatResolutionText(preset, dims){
    return `${preset.label} — ${dims.width} × ${dims.height}`;
  }

  class FpsMonitor {
    constructor(container) {
      this.dom = document.createElement('div');
      this.dom.id = 'fps-monitor';

      const iconMarkup = `
        <span class="ui-icon" aria-hidden="true">
          <svg viewBox="0 0 24 24" role="presentation">
            <circle cx="12" cy="12" r="10" opacity="0.35"></circle>
            <path d="M5 13.2l3.4-2.6L11 14l2.9-5.6L19 15" fill="none" stroke="currentColor" stroke-width="1.8" stroke-linecap="round" stroke-linejoin="round"></path>
          </svg>
        </span>`;

      this.titleEl = document.createElement('div');
      this.titleEl.className = 'panel-title';
      this.titleEl.innerHTML = `${iconMarkup}<span class="label">Performance</span>`;
      this.dom.appendChild(this.titleEl);

      this.styles = getComputedStyle(document.documentElement);

      this.readoutEl = document.createElement('div');
      this.readoutEl.className = 'fps-readout';

      this.labelEl = document.createElement('div');
      this.labelEl.className = 'fps-label';
      this.labelEl.textContent = 'fps';

      this.valueEl = document.createElement('div');
      this.valueEl.className = 'fps-value';
      this.valueEl.textContent = '000';

      this.readoutEl.appendChild(this.labelEl);
      this.readoutEl.appendChild(this.valueEl);

      this.graphCanvas = document.createElement('canvas');
      this.graphCanvas.width = 160;
      this.graphCanvas.height = 60;
      this.graphCanvas.className = 'fps-graph';
      this.graphCanvas.setAttribute('aria-hidden', 'true');
      this.graphCtx = this.graphCanvas.getContext('2d');

      this.maxSamples = this.graphCanvas.width;
      this.samples = new Array(this.maxSamples).fill(0);
      this.referenceFps = 120;
      this.sampleWindow = 250;
      this.frameCount = 0;
      this.lastSample = performance.now();
      this.smoothed = 0;

      this.dom.appendChild(this.readoutEl);
      this.dom.appendChild(this.graphCanvas);
      this.drawGraph();
      if (container) container.appendChild(this.dom);
    }

    begin() {}

    end() {
      const now = performance.now();
      this.frameCount += 1;
      if (now - this.lastSample >= this.sampleWindow) {
        const elapsed = now - this.lastSample;
        const fps = (this.frameCount * 1000) / elapsed;
        this.frameCount = 0;
        this.lastSample = now;
        this.update(fps);
      }
    }

    update(rawFps) {
      const fps = Math.max(0, rawFps);
      this.smoothed = this.smoothed === 0 ? fps : (this.smoothed * 0.7 + fps * 0.3);
      const rounded = Math.max(0, Math.round(this.smoothed));
      this.valueEl.textContent = `${rounded.toString().padStart(3, '0')}`;
      this.samples.push(fps);
      if (this.samples.length > this.maxSamples) {
        this.samples.shift();
      }
      this.drawGraph();
    }

    drawGraph() {
      const ctx = this.graphCtx;
      const width = this.graphCanvas.width;
      const height = this.graphCanvas.height;
      ctx.clearRect(0, 0, width, height);

      const background = this.styles.getPropertyValue('--panel-bg-folded').trim() || 'rgba(7,14,28,0.45)';
      const gridColor = this.styles.getPropertyValue('--graph-grid').trim() || 'rgba(140, 200, 255, 0.25)';
      const fillColor = this.styles.getPropertyValue('--graph-fill').trim() || 'rgba(120, 194, 255, 0.18)';
      const lineColor = this.styles.getPropertyValue('--graph-line').trim() || '#7ed1ff';

      ctx.fillStyle = background;
      ctx.fillRect(0, 0, width, height);

      ctx.strokeStyle = gridColor;
      ctx.lineWidth = 1;
      const gridLines = 4;
      for (let i = 1; i < gridLines; i++) {
        const y = Math.round((height / gridLines) * i) + 0.5;
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(width, y);
        ctx.stroke();
      }

      const highestSample = this.samples.reduce((max, value) => Math.max(max, value), 0);
      const scaleMax = Math.max(this.referenceFps, highestSample, 30);
      const verticalPadding = 2;
      const usableHeight = height - verticalPadding * 2;

      ctx.beginPath();
      ctx.moveTo(0, height - verticalPadding);
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        ctx.lineTo(x, y);
      }
      ctx.lineTo(width, height - verticalPadding);
      ctx.closePath();
      ctx.fillStyle = fillColor;
      ctx.fill();

      ctx.beginPath();
      for (let i = 0; i < this.samples.length; i++) {
        const value = this.samples[i];
        const x = (i / (this.samples.length - 1 || 1)) * width;
        const normalized = Math.min(1, value / scaleMax);
        const y = height - verticalPadding - normalized * usableHeight;
        if (i === 0) {
          ctx.moveTo(x, y);
        } else {
          ctx.lineTo(x, y);
        }
      }
      ctx.strokeStyle = lineColor;
      ctx.lineWidth = 1.5;
      ctx.stroke();
    }
  }

  const controlUiEl = document.getElementById('control-ui');
  const foldBtn = document.getElementById('ui-fold-btn');
  if (foldBtn && controlUiEl) {
    const updateFoldState = (folded) => {
      const label = folded ? 'Expand control panel' : 'Collapse control panel';
      foldBtn.setAttribute('aria-label', label);
    };
    foldBtn.addEventListener('click', () => {
      const isFolded = controlUiEl.classList.toggle('folded');
      foldBtn.setAttribute('aria-expanded', String(!isFolded));
      updateFoldState(isFolded);
      console.log(`Control panel ${isFolded ? 'collapsed' : 'expanded'}.`);
    });
    updateFoldState(controlUiEl.classList.contains('folded'));
    foldBtn.setAttribute('aria-expanded', String(!controlUiEl.classList.contains('folded')));
  }

  let resolutionFlashTimeout = null;
  function flashResolutionPanel(){
    const control = document.getElementById('control-ui');
    if (!control) return;
    control.classList.add('resolution-updated');
    if (resolutionFlashTimeout) clearTimeout(resolutionFlashTimeout);
    resolutionFlashTimeout = setTimeout(() => {
      control.classList.remove('resolution-updated');
    }, 480);
  }

  function enhanceResolutionSelect(select){
    if (!select || select.dataset.enhanced === 'true') return;
    const wrap = select.closest('.select-wrap');
    if (!wrap) return;

    wrap.classList.add('enhanced-dropdown');
    select.dataset.enhanced = 'true';
    select.classList.add('native-select');
    select.setAttribute('aria-hidden', 'true');
    select.tabIndex = -1;

    const dropdown = document.createElement('div');
    dropdown.className = 'resolution-dropdown';

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'resolution-dropdown-button';
    button.setAttribute('aria-haspopup', 'listbox');
    button.setAttribute('aria-expanded', 'false');

    const list = document.createElement('ul');
    list.className = 'resolution-dropdown-list';
    list.setAttribute('role', 'listbox');
    list.setAttribute('tabindex', '-1');
    list.setAttribute('aria-hidden', 'true');

    const selectOptions = Array.from(select.options);
    const items = selectOptions.map((opt, idx) => {
      const li = document.createElement('li');
      li.className = 'resolution-dropdown-option';
      li.dataset.value = opt.value;
      li.textContent = opt.textContent;
      li.setAttribute('role', 'option');
      li.setAttribute('tabindex', '-1');
      if (opt.disabled) {
        li.setAttribute('aria-disabled', 'true');
        li.classList.add('is-disabled');
      }
      if (opt.selected) {
        li.classList.add('is-selected');
        li.setAttribute('aria-selected', 'true');
      }
      if (!li.id) {
        li.id = `resolution-option-${idx}`;
      }
      list.appendChild(li);
      return li;
    });

    const updateButtonLabel = () => {
      const selectedOpt = selectOptions.find((opt) => opt.selected) || selectOptions[0];
      button.textContent = selectedOpt ? selectedOpt.textContent : 'Select';
    };
    updateButtonLabel();

    dropdown.appendChild(button);
    dropdown.appendChild(list);
    wrap.appendChild(dropdown);

    let open = false;
    let activeIndex = Math.max(0, items.findIndex((item) => item.classList.contains('is-selected')));

    const ensureItemVisible = (item) => {
      if (!open) return;
      const itemTop = item.offsetTop;
      const itemBottom = itemTop + item.offsetHeight;
      if (itemTop < list.scrollTop) {
        list.scrollTop = itemTop;
      } else if (itemBottom > list.scrollTop + list.clientHeight) {
        list.scrollTop = itemBottom - list.clientHeight;
      }
    };

    const setActive = (index) => {
      if (!items.length) return;
      if (index < 0) index = items.length - 1;
      if (index >= items.length) index = 0;
      activeIndex = index;
      items.forEach((item, idx) => {
        const isActive = idx === activeIndex;
        item.classList.toggle('is-active', isActive);
        item.setAttribute('tabindex', isActive ? '0' : '-1');
        if (isActive && open) {
          item.focus({ preventScroll: true });
          ensureItemVisible(item);
        }
      });
      const activeItem = items[activeIndex];
      if (activeItem) {
        list.setAttribute('aria-activedescendant', activeItem.id);
      }
    };

    const updateSelection = (indexOrValue, triggerChange = true) => {
      let index = typeof indexOrValue === 'number'
        ? indexOrValue
        : items.findIndex((item) => item.dataset.value === indexOrValue);
      if (index < 0 || index >= items.length) return;

      items.forEach((item, idx) => {
        const isSelected = idx === index;
        item.classList.toggle('is-selected', isSelected);
        item.setAttribute('aria-selected', isSelected ? 'true' : 'false');
      });

      selectOptions.forEach((opt, idx) => {
        opt.selected = idx === index;
      });
      select.value = selectOptions[index] ? selectOptions[index].value : select.value;
      updateButtonLabel();
      setActive(index);

      if (triggerChange) {
        const evt = new Event('change', { bubbles: true });
        select.dispatchEvent(evt);
      }
    };

    const closeList = (focusButton = true) => {
      if (!open) return;
      open = false;
      list.classList.remove('is-open');
      list.setAttribute('aria-hidden', 'true');
      button.setAttribute('aria-expanded', 'false');
      document.removeEventListener('pointerdown', handleOutsidePointer, true);
      document.removeEventListener('keydown', handleGlobalKeyDown, true);
      items.forEach((item) => item.setAttribute('tabindex', '-1'));
      if (focusButton) {
        button.focus({ preventScroll: true });
      }
    };

    const openList = () => {
      if (open) return;
      open = true;
      list.classList.add('is-open');
      list.setAttribute('aria-hidden', 'false');
      button.setAttribute('aria-expanded', 'true');
      setActive(Math.max(0, items.findIndex((item) => item.classList.contains('is-selected'))));
      requestAnimationFrame(() => {
        const activeItem = items[activeIndex];
        if (activeItem) {
          activeItem.focus({ preventScroll: true });
          ensureItemVisible(activeItem);
        } else {
          list.focus({ preventScroll: true });
        }
      });
      document.addEventListener('pointerdown', handleOutsidePointer, true);
      document.addEventListener('keydown', handleGlobalKeyDown, true);
    };

    const handleOutsidePointer = (event) => {
      if (!wrap.contains(event.target)) {
        closeList(false);
      }
    };

    const handleGlobalKeyDown = (event) => {
      if (!open) return;
      if (event.key === 'Escape') {
        event.preventDefault();
        closeList();
      } else if (event.key === 'ArrowDown') {
        event.preventDefault();
        setActive(activeIndex + 1);
      } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        setActive(activeIndex - 1);
      } else if (event.key === 'Enter' || event.key === ' ') {
        const activeItem = items[activeIndex];
        if (activeItem) {
          event.preventDefault();
          activeItem.click();
        }
      }
    };

    button.addEventListener('click', () => {
      if (open) {
        closeList();
      } else {
        openList();
      }
    });

    button.addEventListener('keydown', (event) => {
      if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
        event.preventDefault();
        openList();
      } else if (event.key === 'Enter' || event.key === ' ') {
        event.preventDefault();
        openList();
      }
    });

    items.forEach((item, idx) => {
      item.addEventListener('click', () => {
        if (item.classList.contains('is-disabled')) return;
        updateSelection(idx, true);
        closeList();
      });
    });

    select.addEventListener('change', () => {
      updateSelection(select.value, false);
    });

    const label = document.querySelector('label[for="resolution-select"]');
    if (label) {
      label.addEventListener('click', (event) => {
        event.preventDefault();
        button.focus({ preventScroll: true });
        openList();
      });
    }

    setActive(activeIndex);
  }

  // ===== Boot =====
  (async function boot(){
    try {
      const threeURL = await loadFirstAvailable([
        'https://unpkg.com/three@0.160.0/build/three.min.js',
        'https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js',
        'https://cdnjs.cloudflare.com/ajax/libs/three.js/r160/three.min.js'
      ]); console.log('THREE loaded from:', threeURL);
      try {
        const statsURL = await loadFirstAvailable([
          'https://unpkg.com/stats.js@0.17.0/build/stats.min.js',
          'https://cdn.jsdelivr.net/npm/stats.js@0.17.0/build/stats.min.js',
          'https://cdnjs.cloudflare.com/ajax/libs/stats.js/r17/Stats.min.js'
        ]); console.log('Stats loaded from:', statsURL);
      } catch(e){ console.warn('Stats unavailable, using MiniStats. Cause:', e.message); }
      initThreeScene();
    } catch (e) {
      console.warn('THREE failed to load, entering fallback mode.', e);
      initCanvasFallback(e);
    }
  })();

  // ===== Quality profile =====
  function chooseQuality(){
    const ua = (navigator.userAgent || '').toLowerCase();
    const isMobile = /android|iphone|ipad|ipod/.test(ua);
    return {
      isMobile,
      dpr: Math.min(window.devicePixelRatio || 1, isMobile ? 1.0 : 1.5),
      diskPoints: isMobile ? 2800 : 4200,
      galaxyPoints: isMobile ? 5200 : 8400,
      flarePairs: isMobile ? 14 : 20,
      flareScaleMin: isMobile ? 5 : 7,
      flareScaleMax: isMobile ? 11 : 14,
      jetSegments: isMobile ? 18 : 28,
      nebulaCount: isMobile ? 3 : 5
    };
  }

  // ===== Helpers =====
  function makeGlowTexture(size=64, inner='rgba(255,255,255,1)', mid='rgba(255,230,170,0.95)', outer='rgba(255,255,255,0)'){
    const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
    const g=ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
    g.addColorStop(0, inner); g.addColorStop(0.35, mid); g.addColorStop(1, outer);
    ctx.fillStyle=g; ctx.beginPath(); ctx.arc(size/2,size/2,size/2,0,Math.PI*2); ctx.fill();
    const tex = new THREE.CanvasTexture(c); tex.center.set(0.5,0.5); return tex;
  }

  // === Procedural nebula texture (FBM noise to Hubble palette)
  function makeNebulaTexture(size=1024, palette='orion'){
    const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d');
    // Fast value noise: precompute grid, then bilinear sample (no getImageData in inner loop)
    const NX=128, NY=128; const vals=new Float32Array(NX*NY);
    for(let j=0;j<NY;j++){ for(let i=0;i<NX;i++){ vals[j*NX+i]=Math.random(); }}
    const smooth=t=>t*t*(3-2*t);
    function sample(x,y){ x=(x%NX+NX)%NX; y=(y%NY+NY)%NY; const ix=Math.floor(x), iy=Math.floor(y); const fx=x-ix, fy=y-iy; const ix1=(ix+1)%NX, iy1=(iy+1)%NY; const v00=vals[iy*NX+ix], v10=vals[iy*NX+ix1], v01=vals[iy1*NX+ix], v11=vals[iy1*NX+ix1]; const sx=smooth(fx), sy=smooth(fy); const a=v00*(1-sx)+v10*sx; const b=v01*(1-sx)+v11*sx; return a*(1-sy)+b*sy; }
    function fbm(x,y){ let amp=1,f=1,sum=0,norm=0; for(let i=0;i<5;i++){ sum+=amp*sample(x*f,y*f); norm+=amp; amp*=0.5; f*=2.1; } return sum/norm; }
    const img=ctx.createImageData(size,size);
    const palettes={
      orion:(t)=>{ const h=200*(1-t)+300*t; const s=0.65+0.25*t; const l=0.35+0.35*t; const col=new THREE.Color().setHSL(h/360,s,l); return [col.r*255,col.g*255,col.b*255]; },
      carina:(t)=>{ const h=210*(1-t)+30*t; const s=0.8; const l=0.48+0.25*(t*t); const col=new THREE.Color().setHSL(h/360,s,l); return [col.r*255,col.g*255,col.b*255]; }
    }; const map=palettes[palette]||palettes.orion;
    for(let y=0;y<size;y++){
      for(let x=0;x<size;x++){
        const nx=(x/size)*NX, ny=(y/size)*NY; const f=fbm(nx,ny);
        const edge=Math.hypot((x-size/2)/(size/2),(y-size/2)/(size/2));
        const alpha=Math.max(0,1-edge*edge*0.9)*Math.pow(f,1.5);
        const t=Math.pow(f,0.85); const [r,g,b]=map(t); const k=(y*size+x)*4;
        img.data[k]=r|0; img.data[k+1]=g|0; img.data[k+2]=b|0; img.data[k+3]=(alpha*255)|0;
      }
    }
    ctx.putImageData(img,0,0); const tex=new THREE.CanvasTexture(c); tex.center.set(0.5,0.5); tex.wrapS=tex.wrapT=THREE.ClampToEdgeWrapping; return tex;
  }

  // ===== Black hole with enhanced lensing rings and disk thickness
  function buildBlackHole(q){
    const group = new THREE.Group();

    // Event horizon
    const horizon = new THREE.Mesh(new THREE.SphereGeometry(10, 64, 64), new THREE.MeshBasicMaterial({ color: 0x000000 }));
    group.add(horizon);

    // Lensing rings (Einstein rings approximation)
    function makeRing(R, tube, color, opacity){
      const m = new THREE.MeshBasicMaterial({ color, transparent:true, opacity, blending:THREE.AdditiveBlending });
      const t = new THREE.Mesh(new THREE.TorusGeometry(R, tube, 32, 512), m); t.rotation.x = Math.PI/2; return t;
    }
    const ring1 = makeRing(12.0, 0.65, 0xffdd99, 0.95);
    const ring2 = makeRing(14.0, 0.50, 0xffaa66, 0.75);
    const ring3 = makeRing(15.9, 0.40, 0x88ccff, 0.55);
    group.add(ring1, ring2, ring3);

    /**
     * Math (disk orbital angular velocity):
     * ω(r) = ω₀ (r₀ / r)^{3/2} for Keplerian disk.
     * Vertical scale-height H(r) ~ H₀ + H₁ ((r - r₀)/(r₁ - r₀))^{p}
     * We animate y(t) = y₀ + A·sin(φ + t·(a + b·√r))
     */
    const total = Math.max(3000, q.diskPoints);
    const layersDef = [
      { name:'inner',  r0:14, r1:28, count: Math.floor(total*0.35), hueA:0.02, hueB:0.00, lumA:0.65, lumB:0.45, size:2.0, shear:2.0, yAmp:2.0, H0:0.9, H1:1.5 },
      { name:'middle', r0:28, r1:56, count: Math.floor(total*0.40), hueA:0.06, hueB:0.02, lumA:0.60, lumB:0.40, size:2.1, shear:1.1, yAmp:3.0, H0:1.1, H1:2.6 },
      { name:'outer',  r0:56, r1:92, count: Math.floor(total*0.25), hueA:0.10, hueB:0.05, lumA:0.55, lumB:0.35, size:2.3, shear:0.7, yAmp:3.8, H0:1.3, H1:3.8 }
    ];

    const randN = ()=>{ const u=Math.random()||1e-6, v=Math.random()||1e-6; return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); };
    const layers = [];
    for (const L of layersDef){
      const N = L.count;
      const pos = new Float32Array(N*3);
      const col = new Float32Array(N*3);
      const rad = new Float32Array(N);
      const ang = new Float32Array(N);
      const omg = new Float32Array(N);
      const y0  = new Float32Array(N);
      const phs = new Float32Array(N);
      const C = new THREE.Color();
      for (let i=0;i<N;i++){
        const r = Math.sqrt(Math.random())*(L.r1 - L.r0) + L.r0;
        const a = Math.random()*Math.PI*2;
        rad[i]=r; ang[i]=a; phs[i]=Math.random()*Math.PI*2;
        const base=1.3; omg[i]= base * L.shear * Math.pow(L.r0 / r, 1.5);
        const H = L.H0 + L.H1 * Math.pow((r-L.r0)/(L.r1-L.r0), 1.2);
        const y = randN()*H; y0[i]=y;
        const k=i*3; pos[k  ]= r*Math.cos(a); pos[k+1]= y; pos[k+2]= r*Math.sin(a);
        const t=(r - L.r0)/(L.r1 - L.r0);
        C.setHSL((1-t)*L.hueA + t*L.hueB, 1.0, (1-t)*L.lumA + t*L.lumB);
        col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b;
      }
      const g = new THREE.BufferGeometry(); g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3)); g.setAttribute('color', new THREE.Float32BufferAttribute(col,3));
      const mat = new THREE.PointsMaterial({ size: L.size, map: makeGlowTexture(64), transparent:true, depthWrite:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true, alphaTest:0.06 });
      const pts = new THREE.Points(g, mat); group.add(pts);
      layers.push({def:L, points:pts, rad, ang, omg, y0, phs});
    }

    // Jets
    const jetMat = new THREE.MeshBasicMaterial({ color: 0x66ccff, transparent:true, opacity:0.28, blending: THREE.AdditiveBlending, depthWrite:false, side: THREE.DoubleSide });
    const jetGeo = new THREE.ConeGeometry(4, 240, q.jetSegments, 1, true);
    const jetUp = new THREE.Mesh(jetGeo, jetMat);  jetUp.position.y = 130;
    const jetDn = new THREE.Mesh(jetGeo, jetMat);  jetDn.rotation.x = Math.PI; jetDn.position.y = -130;
    group.add(jetUp, jetDn);

    // Flares (gamma/lepton rich inner-disk flares)
    const flareTex = makeGlowTexture(96, 'rgba(140,200,255,1)', 'rgba(80,160,255,0.9)', 'rgba(80,160,255,0)');
    const flares = [];
    function makeFlare(dir){
      const s = new THREE.Sprite(new THREE.SpriteMaterial({ map: flareTex, color: 0xa0d8ff, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false, alphaTest: 0.08 }));
      s.position.set((Math.random()-0.5)*3, 0, (Math.random()-0.5)*3);
      s.scale.setScalar(q.flareScaleMin + Math.random()*(q.flareScaleMax-q.flareScaleMin));
      s.userData = { dir, y: 0, speed: 90 + Math.random()*170, life: 0, lifeMax: 0.6 + Math.random()*1.2 };
      group.add(s); return s;
    }
    for(let i=0;i<q.flarePairs;i++){ flares.push(makeFlare(+1)); flares.push(makeFlare(-1)); }

    group.rotation.z = 0.12; group.rotation.x = -0.35;
    group.userData = { layers, ring1, ring2, ring3, flares, t:0 };
    return group;
  }
  function updateBlackHole(bh, dt){
    const ud = bh.userData; ud.t += dt;
    for (const L of ud.layers){
      const pos = L.points.geometry.attributes.position.array;
      for (let i=0;i<L.ang.length;i++){
        L.ang[i] += L.omg[i]*dt; // ω(r) ~ r^{-3/2}
        const r=L.rad[i], a=L.ang[i]; const k=i*3;
        pos[k  ] = r*Math.cos(a);
        pos[k+2] = r*Math.sin(a);
        pos[k+1] = L.y0[i] + Math.sin(L.phs[i] + ud.t*(1.5 + 0.4*Math.sqrt(r))) * (0.25*L.def.yAmp);
      }
      L.points.geometry.attributes.position.needsUpdate = true;
    }
    ud.ring1.rotation.y += 0.24*dt; ud.ring2.rotation.y -= 0.18*dt; ud.ring3.rotation.y += 0.12*dt;
    bh.rotation.y += 0.022*dt;

    for (const s of ud.flares){
      s.userData.life += dt; if (s.userData.life > s.userData.lifeMax){
        s.userData.life = 0; s.userData.lifeMax = 0.6 + Math.random()*1.2; s.userData.speed = 90 + Math.random()*170;
        s.userData.dir = Math.random()<0.5 ? +1 : -1; s.userData.y = 0; s.scale.setScalar(s.scale.x*(0.7+Math.random()*0.6));
      }
      s.userData.y += s.userData.dir * s.userData.speed * dt; const clampY = 130; if (Math.abs(s.userData.y) > clampY) { s.userData.y = s.userData.dir * -clampY; s.userData.life = 0; }
      s.position.y = s.userData.y; const t = s.userData.life / s.userData.lifeMax; const op = Math.max(0, 1 - (t*t)); s.material.opacity = 0.78 * op;
    }
  }

  // ===== Andromeda (background) =====
  function buildAndromedaGalaxy(q){
    const group = new THREE.Group();
    const N = q.galaxyPoints; const Rmax = 360; const arms = 2; const b = 0.25;
    const pos = new Float32Array(N*3); const col = new Float32Array(N*3);
    const c = new THREE.Color();
    for (let i=0;i<N;i++){
      const arm = i % arms; const th = Math.random()*Math.PI*8 + arm*Math.PI;
      const r = Math.min(Rmax, (24 + Math.exp(b*th))) * (0.9 + Math.random()*0.2);
      const jitter = (Math.random()-0.5)*6.0;
      const x = (r + jitter) * Math.cos(th);
      const z = (r + jitter) * Math.sin(th);
      const y = (Math.random()-0.5) * 7.0;
      const k = i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z;
      const t = r / Rmax; c.setHSL(0.10 - 0.05*t, 0.85 - 0.35*t, 0.92 - 0.40*t);
      col[k]=c.r; col[k+1]=c.g; col[k+2]=c.b;
    }
    const g = new THREE.BufferGeometry();
    g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
    g.setAttribute('color',    new THREE.Float32BufferAttribute(col,3));
    const m = new THREE.PointsMaterial({ size: 5.7, map: makeGlowTexture(64), transparent:true, depthWrite:false, depthTest:false, blending: THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true, alphaTest: 0.05 });
    const points = new THREE.Points(g, m); points.renderOrder = -6; group.add(points);

    function makeGalaxyBillboardTex(){ const c=document.createElement('canvas'); c.width=c.height=512; const ctx=c.getContext('2d'); const grad=ctx.createRadialGradient(256,256,0,256,256,256); grad.addColorStop(0,'rgba(255,240,200,0.55)'); grad.addColorStop(0.40,'rgba(190,210,255,0.42)'); grad.addColorStop(1,'rgba(150,180,255,0)'); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(256,256,256,0,Math.PI*2); ctx.fill(); const t=new THREE.CanvasTexture(c); t.center.set(0.5,0.5); return t; }
    const bbMat = new THREE.MeshBasicMaterial({ map: makeGalaxyBillboardTex(), transparent:true, opacity:0.9, blending:THREE.AdditiveBlending, depthWrite:false, depthTest:false });
    const billboard = new THREE.Mesh(new THREE.PlaneGeometry(1,1), bbMat); billboard.renderOrder = -6; billboard.scale.set(1300,760,1); group.add(billboard);

    const coreGeo = new THREE.PlaneGeometry(380, 380);
    const coreTex = makeGlowTexture(256, 'rgba(255,240,200,1)', 'rgba(255,220,160,0.95)', 'rgba(255,200,140,0)');
    const coreMat = new THREE.MeshBasicMaterial({ map: coreTex, transparent:true, opacity:0.8, blending:THREE.AdditiveBlending, depthWrite:false, depthTest:false });
    const core = new THREE.Mesh(coreGeo, coreMat); core.renderOrder = -6; group.add(core);

    group.position.set(-300, 160, -820);
    group.rotation.set(Math.PI/2 - 0.15, 0.12, 0.02);
    group.scale.set(3.1, 1.0, 3.1);
    group.renderOrder = -6;

    group.userData = { points, core, billboard };
    return group;
  }
  function updateAndromeda(g, dt){ g.rotation.y += 0.006*dt; }

  // ===== Galaxy palettes & tiny galaxies =====
  function pickGalaxyPalette(){
    const types = ['E','S0','Sa','Sb','Sc','SBa','SBb','SBc','Ring','Irr'];
    const type = types[Math.floor(Math.random()*types.length)];
    const palettes = {
      E:   { coreH:0.06, armH:0.06, sat:0.5 },
      S0:  { coreH:0.10, armH:0.10, sat:0.7 },
      Sa:  { coreH:0.10, armH:0.58, sat:0.9 },
      Sb:  { coreH:0.10, armH:0.60, sat:0.9 },
      Sc:  { coreH:0.10, armH:0.64, sat:0.95 },
      SBa: { coreH:0.10, armH:0.58, sat:0.9 },
      SBb: { coreH:0.10, armH:0.60, sat:0.9 },
      SBc: { coreH:0.10, armH:0.64, sat:0.95 },
      Ring:{ coreH:0.10, armH:0.62, sat:0.9 },
      Irr: { coreH:0.12, armH:0.83, sat:0.95 }
    };
    return { type, ...palettes[type] };
  }

  function buildTinyGalaxy(palette, pts=1000, scale=1){
    const group = new THREE.Group();
    const type = palette.type; const HARM = palette.armH; const SAT = palette.sat;
    const g = new THREE.BufferGeometry();
    const pos = new Float32Array(pts*3), col = new Float32Array(pts*3);
    const C = new THREE.Color();
    const randN = ()=>{ const u=Math.random()||1e-6, v=Math.random()||1e-6; return Math.sqrt(-2*Math.log(u))*Math.cos(2*Math.PI*v); };

    if (/^S(B)?[abc]$/.test(type) || type==='S0'){
      const tightness = (type.endsWith('a')?0.18:(type.endsWith('b')?0.24:0.32));
      const arms = (type==='Sc'||type==='SBc') ? 3 : 2; const Rmax = 95*scale;
      const hasBar = /^SB/.test(type); const isS0 = (type==='S0');
      for (let i=0;i<pts;i++){
        const arm=i%arms; const th=Math.random()*Math.PI*8 + arm*(2*Math.PI/arms);
        const rBase=Math.min(Rmax, 20 + Math.exp(tightness*th));
        const r=(0.85+0.3*Math.random())*rBase;
        const x=(r+(Math.random()-0.5)*2.4*scale)*Math.cos(th);
        const z=(r+(Math.random()-0.5)*2.4*scale)*Math.sin(th);
        const H = 0.8*scale + 1.9*scale*(r/Rmax);
        const y = randN()*H;
        const k=i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z;
        const t=r/Rmax; C.setHSL(HARM + (Math.random()-0.5)*0.02, SAT, 0.90 - 0.45*t); col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b;
      }
      if (hasBar){
        const barPts = Math.floor(pts*0.15); const barPos=new Float32Array(barPts*3), barCol=new Float32Array(barPts*3);
        for(let i=0;i<barPts;i++){ const t= (i/(barPts-1))*2-1; const x=t*0.55*Rmax; const z=randN()*4*scale; const y=randN()*2.2*scale; const k=i*3; barPos[k]=x; barPos[k+1]=y; barPos[k+2]=z; C.setHSL(0.10,0.9,0.92); barCol[k]=C.r; barCol[k+1]=C.g; barCol[k+2]=C.b; }
        const gb=new THREE.BufferGeometry(); gb.setAttribute('position', new THREE.Float32BufferAttribute(barPos,3)); gb.setAttribute('color', new THREE.Float32BufferAttribute(barCol,3));
        const mb=new THREE.PointsMaterial({ size:4.8*scale, map: makeGlowTexture(64), transparent:true, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true });
        const pb=new THREE.Points(gb,mb); pb.renderOrder=-7; group.add(pb);
      }
      if (isS0){
        const ringPts = Math.floor(pts*0.10); const ringPos=new Float32Array(ringPts*3), ringCol=new Float32Array(ringPts*3);
        for(let i=0;i<ringPts;i++){ const a=Math.random()*Math.PI*2; const R=72*scale; const x=(R+randN()*3)*Math.cos(a), z=(R+randN()*3)*Math.sin(a), y=randN()*1.2*scale; const k=i*3; ringPos[k]=x; ringPos[k+1]=y; ringPos[k+2]=z; C.setHSL(HARM, SAT*0.7, 0.8); ringCol[k]=C.r; ringCol[k+1]=C.g; ringCol[k+2]=C.b; }
        const gr=new THREE.BufferGeometry(); gr.setAttribute('position', new THREE.Float32BufferAttribute(ringPos,3)); gr.setAttribute('color', new THREE.Float32BufferAttribute(ringCol,3));
        const mr=new THREE.PointsMaterial({ size:4.3*scale, map: makeGlowTexture(64), transparent:true, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true });
        group.add(new THREE.Points(gr,mr));
      }
    } else if (type==='E'){
      const a=124*scale, b=86*scale, c=62*scale;
      for (let i=0;i<pts;i++){ const x=randN()*a*0.4, y=randN()*c*0.6, z=randN()*b*0.4; const k=i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z; C.setHSL(HARM, SAT*0.7, 0.86 - 0.3*Math.random()); col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b; }
    } else if (type==='Ring'){
      const R0=112*scale, r=21*scale;
      for(let i=0;i<pts;i++){ const u=Math.random()*Math.PI*2, v=Math.random()*Math.PI*2; const cu=Math.cos(u), su=Math.sin(u), cv=Math.cos(v), sv=Math.sin(v); const x=(R0 + r*cv)*cu, y=r*sv*1.2, z=(R0 + r*cv)*su; const k=i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z; C.setHSL(HARM + (Math.random()-0.5)*0.03, SAT, 0.85 - 0.25*(1+cv)/2); col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b; }
    } else { // Irr
      const clumps = 3 + Math.floor(Math.random()*3);
      const centers = Array.from({length:clumps}, ()=>({ x:(Math.random()-0.5)*120*scale, y:(Math.random()-0.5)*80*scale, z:(Math.random()-0.5)*120*scale }));
      for(let i=0;i<pts;i++){ const c0=centers[i%clumps]; const x=c0.x+randN()*18*scale, y=c0.y+randN()*14*scale, z=c0.z+randN()*18*scale; const k=i*3; pos[k]=x; pos[k+1]=y; pos[k+2]=z; C.setHSL(HARM + (Math.random()-0.5)*0.05, SAT, 0.8 - 0.3*Math.random()); col[k]=C.r; col[k+1]=C.g; col[k+2]=C.b; }
    }

    g.setAttribute('position', new THREE.Float32BufferAttribute(pos,3));
    g.setAttribute('color',    new THREE.Float32BufferAttribute(col,3));
    const m = new THREE.PointsMaterial({ size: 4.3*scale, map: makeGlowTexture(64), transparent:true, depthWrite:false, depthTest:false, blending:THREE.AdditiveBlending, vertexColors:true, sizeAttenuation:true, alphaTest:0.05 });
    const points = new THREE.Points(g,m); points.renderOrder = -7; group.add(points);

    const coreTex = makeGlowTexture(196*scale, 'rgba(255,240,200,0.9)','rgba(255,220,160,0.75)','rgba(255,210,160,0)');
    const core = new THREE.Mesh(new THREE.PlaneGeometry(120*scale,120*scale), new THREE.MeshBasicMaterial({ map: coreTex, transparent:true, opacity:0.62, blending:THREE.AdditiveBlending, depthWrite:false, depthTest:false }));
    core.renderOrder = -7; group.add(core);

    group.userData = { points, core, type, driftPhi: Math.random()*Math.PI*2, driftAmp: 80 + Math.random()*120, driftSpeed: 0.08 + Math.random()*0.12 };
    return group;
  }

  // === Galaxy field (Fibonacci sphere to avoid closeness)
  function fibonacciSphere(n, radius){
    const pts=[];
    const phi = Math.PI * (3 - Math.sqrt(5));
    for(let i=0;i<n;i++){
      const y = 1 - (i + 0.5) * (2 / n);
      const r = Math.sqrt(1 - y*y);
      const theta = phi * i;
      pts.push({x: radius*r*Math.cos(theta), y: radius*y, z: radius*r*Math.sin(theta)});
    }
    return pts;
  }

  function buildGalaxyField(q, count=16){
    const field = new THREE.Group(); field.renderOrder = -7;
    const dist = 1300; // scaled further out
    const ptsPer = q.isMobile ? 700 : 1000;
    const shell = fibonacciSphere(count, dist);
    for (let i=0;i<count;i++){
      const pal = pickGalaxyPalette();
      const scale = 0.9 + Math.random()*0.7;
      const gal = buildTinyGalaxy(pal, ptsPer, scale);
      const s = shell[i];
      gal.position.set(s.x, s.y + (Math.random()-0.5)*260, s.z);
      gal.lookAt(0,0,0);
      gal.rotateX(Math.PI/2 - 0.12);
      gal.rotateZ((Math.random()-0.5)*0.45);
      field.add(gal);
    }
    field.userData = { dist, rotateSpeed: 0.02, t:0 };
    return field;
  }
  function updateGalaxyField(field, dt){
    if(!field) return; field.userData.t += dt;
    for(const g of field.children){
      g.rotation.z += 0.004*dt;
      // Vertical harmonic drift: y(t)=A·sin(ωt+φ)
      const A = g.userData.driftAmp || 100; const w = g.userData.driftSpeed || 0.1; const ph = g.userData.driftPhi || 0;
      const baseY = g.position.y; // keep base; we modulate around initial
      const dy = A * Math.sin(w*field.userData.t + ph);
      g.position.y = (g.userData.baseY ?? (g.userData.baseY = baseY)) + dy;
    }
  }

  // ===== Gravitational lens arcs near random "massive lenses"
  function buildLensArcs(count=5, radius=220){
    const group = new THREE.Group();
    for(let i=0;i<count;i++){
      const theta = Math.random()*Math.PI*2;
      const r = radius*(0.8+0.5*Math.random());
      const x=r*Math.cos(theta), z=r*Math.sin(theta), y = -10 + Math.random()*20;
      const arcs = Math.floor(2+Math.random()*3);
      for(let j=0;j<arcs;j++){
        const len = Math.PI*0.35*(0.7+Math.random()*0.6);
        const start = Math.random()*Math.PI*2;
        const inner = 16 + Math.random()*64;
        const outer = inner + 1.5 + Math.random()*2.5; // guarantee outer > inner
        const ring = new THREE.RingGeometry(inner, outer, 128, 1, start, len);
        const mat = new THREE.MeshBasicMaterial({ color: 0x8fd3ff, transparent:true, opacity:0.45, blending:THREE.AdditiveBlending, side:THREE.DoubleSide, depthWrite:false });
        const mesh = new THREE.Mesh(ring,mat); mesh.position.set(x,y,z); mesh.lookAt(0,0,0); mesh.rotateZ(Math.random()*Math.PI*2);
        group.add(mesh);
      }
    }
    group.userData = { pulse: 0 };
    return group;
  }
  function updateLensArcs(group, dt){
    if(!group) return; group.userData.pulse += dt;
    const s = 1.0 + 0.03*Math.sin(group.userData.pulse*1.7);
    for(const m of group.children){ m.scale.setScalar(s); }
  }

  // ===== Nebulae
  function buildNebulae(q){
    const group = new THREE.Group();
    const palettes=['orion','carina'];
    for(let i=0;i<q.nebulaCount;i++){
      const tex = makeNebulaTexture(768, palettes[i%palettes.length]);
      const w = 900 + Math.random()*700, h = 600 + Math.random()*400;
      const plane = new THREE.Mesh(
        new THREE.PlaneGeometry(w,h),
        new THREE.MeshBasicMaterial({ map: tex, transparent:true, opacity: 0.75, depthWrite:false, blending:THREE.AdditiveBlending })
      );
      const theta = Math.random()*Math.PI*2, r = 480 + Math.random()*520, y = -60 + Math.random()*140;
      plane.position.set(r*Math.cos(theta), y, r*Math.sin(theta));
      plane.lookAt(0,0,0);
      plane.rotateZ((Math.random()-0.5)*0.5);
      group.add(plane);
    }
    group.userData = { wobble: 0, enabled: true };
    return group;
  }
  function updateNebulae(group, dt){
    if(!group || !group.userData.enabled) return; group.userData.wobble += dt;
    const wob = 0.015*Math.sin(group.userData.wobble*0.7);
    for(const n of group.children){ n.rotation.z += wob*dt; }
  }

  // ===== Gamma-Ray Burst (GRB) system
  function createGRBSystem(scene){
    const flashTex = makeGlowTexture(256, 'rgba(255,255,255,1)','rgba(255,220,160,0.9)','rgba(255,180,120,0)');
    const particlesGeo = new THREE.BufferGeometry();
    const P = 800; const ppos = new Float32Array(P*3), pvel = new Float32Array(P*3), plife=new Float32Array(P), pmax=new Float32Array(P);
    particlesGeo.setAttribute('position', new THREE.Float32BufferAttribute(ppos,3));
    const pmat = new THREE.PointsMaterial({ size: 6.0, map: makeGlowTexture(64,'rgba(255,255,255,1)','rgba(180,200,255,0.9)','rgba(180,200,255,0)'), transparent:true, depthWrite:false, blending:THREE.AdditiveBlending });
    const points = new THREE.Points(particlesGeo, pmat); points.visible=false; scene.add(points);

    const flash = new THREE.Sprite(new THREE.SpriteMaterial({ map: flashTex, color: 0xffffff, transparent:true, blending:THREE.AdditiveBlending, depthWrite:false })); flash.visible=false; scene.add(flash);

    const coneMat = new THREE.MeshBasicMaterial({ color:0xfff0aa, transparent:true, opacity:0.45, blending:THREE.AdditiveBlending, depthWrite:false, side:THREE.DoubleSide });
    const cone = new THREE.Mesh(new THREE.ConeGeometry(12, 600, 24, 1, true), coneMat); cone.visible=false; scene.add(cone);

    const state = { active:false, t:0, origin:new THREE.Vector3(), dir:new THREE.Vector3(0,1,0), lastTime:0 };

    function trigger(pos, dir){
      state.active=true; state.t=0; state.origin.copy(pos); state.dir.copy(dir).normalize(); state.lastTime=performance.now();
      flash.position.copy(pos); flash.scale.setScalar(220); flash.material.opacity=1; flash.visible=true;

      cone.position.copy(pos); const q=new THREE.Quaternion(); q.setFromUnitVectors(new THREE.Vector3(0,1,0), dir.clone().normalize()); cone.setRotationFromQuaternion(q); cone.visible=true;

      // Seed particles isotropically around the jet axis (relativistic shell approx.)
      for(let i=0;i<P;i++){
        const theta = (Math.random()**0.3) * 0.35; // concentrated within small angle
        const phi = Math.random()*Math.PI*2;
        const vx = Math.sin(theta)*Math.cos(phi), vy = Math.cos(theta), vz = Math.sin(theta)*Math.sin(phi);
        const v = new THREE.Vector3(vx,vy,vz).applyQuaternion(q).normalize().multiplyScalar(260 + Math.random()*180);
        const k=i*3; ppos[k]=pos.x; ppos[k+1]=pos.y; ppos[k+2]=pos.z; pvel[k]=v.x; pvel[k+1]=v.y; pvel[k+2]=v.z; plife[i]=0; pmax[i]=0.8+Math.random()*1.2;
      }
      particlesGeo.attributes.position.needsUpdate=true; points.visible=true;
    }

    function update(dt){
      if(!state.active) return;
      state.t += dt;
      // Flash fade & expand
      flash.material.opacity = Math.max(0, 1 - state.t*1.8);
      const s = 220 + state.t*500; flash.scale.set(s,s,1); if (flash.material.opacity<=0.02) flash.visible=false;

      // Cone fade
      cone.material.opacity = Math.max(0, 0.45 - state.t*0.5);
      if (cone.material.opacity<=0.02) cone.visible=false;

      // Particles
      const pos = particlesGeo.attributes.position.array;
      for(let i=0;i<plife.length;i++){
        plife[i]+=dt; const k=i*3;
        pos[k]   += pvel[k]*dt;
        pos[k+1] += pvel[k+1]*dt;
        pos[k+2] += pvel[k+2]*dt;
      }
      particlesGeo.attributes.position.needsUpdate=true;
      pmat.opacity = Math.max(0, 1 - state.t*0.9);

      if (state.t > 2.2){ // end event
        state.active=false; points.visible=false; cone.visible=false; flash.visible=false;
      }
    }

    return { trigger, update, state };
  }

  // ===== Main Three.js app =====
  function initThreeScene(){
    if (typeof THREE === 'undefined') throw new Error('Three.js not present after loader.');
    const q = chooseQuality();
    const container = document.getElementById('container');
    const fpsHolder = document.getElementById('fps');
    const note = document.getElementById('note');
    const placeholder = document.getElementById('placeholder');
    const resolutionSelect = document.getElementById('resolution-select');
    const resolutionDisplay = document.getElementById('resolution-display');

    enhanceResolutionSelect(resolutionSelect);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setPixelRatio(q.dpr);
    container.appendChild(renderer.domElement);
    placeholder.style.display = 'none';

    const StatsCtor = (typeof window !== 'undefined' && window.Stats) ? window.Stats : MiniStats;
    const stats = new StatsCtor();
    if (stats.showPanel) stats.showPanel(0);
    if (stats.dom) stats.dom.style.display = 'none';
    const fpsMonitor = new FpsMonitor(fpsHolder);

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(60, 1, 0.1, 4000);
    camera.position.set(0, 72, 180);
    window._camera = camera;

    const defaultResValue = q.isMobile ? '854x480' : '1280x720';
    if (resolutionSelect && resolutionSelect.querySelector(`option[value="${defaultResValue}"]`)) {
      resolutionSelect.value = defaultResValue;
      resolutionSelect.dispatchEvent(new Event('change', { bubbles: true }));
    }
    let currentResolution = parseResolutionValue(resolutionSelect ? resolutionSelect.value : defaultResValue);

    function syncResolution({ announce = false } = {}){
      const dims = computeScaledDimensions(currentResolution, window.innerWidth, window.innerHeight);
      renderer.setSize(dims.width, dims.height, false);
      camera.aspect = Math.max(0.1, window.innerWidth / Math.max(1, window.innerHeight));
      camera.updateProjectionMatrix();
      if (resolutionDisplay) {
        resolutionDisplay.textContent = formatResolutionText(currentResolution, dims);
      }
      if (note) {
        note.textContent = `${APP_VERSION} • ${APP_CODENAME} • ${currentResolution.label}`;
      }
      if (announce) {
        console.log(`Resolution set to ${dims.width}×${dims.height} (${currentResolution.label}).`);
      }
    }

    let resizeRaf = 0;
    let pendingAnnounce = false;
    function scheduleResize({ announce = false } = {}){
      pendingAnnounce = pendingAnnounce || announce;
      if (resizeRaf) cancelAnimationFrame(resizeRaf);
      resizeRaf = requestAnimationFrame(() => {
        resizeRaf = 0;
        syncResolution({ announce: pendingAnnounce });
        pendingAnnounce = false;
      });
    }

    const resizeListener = () => scheduleResize();
    window.addEventListener('resize', resizeListener);
    if (window.visualViewport) window.visualViewport.addEventListener('resize', resizeListener);
    window.addEventListener('orientationchange', resizeListener);

    syncResolution();
    scheduleResize({ announce: true });

    if (resolutionSelect) {
      resolutionSelect.addEventListener('change', () => {
        currentResolution = parseResolutionValue(resolutionSelect.value);
        scheduleResize({ announce: true });
        flashResolutionPanel();
      });
    }

    // Star background
    function makeStarTexture(size=2048){ const c=document.createElement('canvas'); c.width=c.height=size; const ctx=c.getContext('2d'); ctx.fillStyle='#000'; ctx.fillRect(0,0,size,size); const n=3800; for(let i=0;i<n;i++){ const x=Math.random()*size, y=Math.random()*size; const r=Math.random()*1.8+0.2; const l=72+Math.random()*28; const hue = Math.random()<0.75 ? (200+Math.random()*40) : (40+Math.random()*20); ctx.fillStyle=`hsl(${hue},100%,${l}%)`; ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); } return new THREE.CanvasTexture(c); }
    const skyTex = makeStarTexture(1024);
    const sky = new THREE.Mesh(new THREE.SphereGeometry(1800,64,64), new THREE.MeshBasicMaterial({ map: skyTex, side: THREE.BackSide, depthWrite:false })); scene.add(sky); sky.renderOrder = -10;

    const andromeda = buildAndromedaGalaxy(q); scene.add(andromeda); window._andromeda = andromeda;
    const galaxyField = buildGalaxyField(q, 18); scene.add(galaxyField); window._galaxyField = galaxyField;

    const lensArcs = buildLensArcs(6, 260); scene.add(lensArcs); window._lensArcs = lensArcs;
    const nebulae = buildNebulae(q); scene.add(nebulae); window._nebulae = nebulae;

    scene.add(new THREE.AmbientLight(0x333333));
    const terrain = new THREE.Mesh(new THREE.PlaneGeometry(1200,1200,1,1).rotateX(-Math.PI/2), new THREE.MeshStandardMaterial({ color:0x101c12, flatShading:true, metalness:0, roughness:1 })); scene.add(terrain);

    const blackHole = buildBlackHole(q); blackHole.position.set(0, 62, 0); scene.add(blackHole); window._blackHole = blackHole;

    // Controls
    const keyState = Object.create(null); window._keyState = keyState;
    window.addEventListener('keydown', (e) => { keyState[e.key]=true; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault(); });
    window.addEventListener('keyup',   (e) => { keyState[e.key]=false; if(['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(e.key)) e.preventDefault(); });

    const touches = new Map(); let touchAgg = { yaw: 0, throttle: 0 }; let touchYawSm=0, touchThrottleSm=0; const maxR=140, dead=12;
    const stickL = document.createElement('div'); stickL.className='stick'; const nubL = document.createElement('div'); nubL.className='nub'; stickL.appendChild(nubL); container.appendChild(stickL);
    const stickR = document.createElement('div'); stickR.className='stick'; const nubR = document.createElement('div'); nubR.className='nub'; stickR.appendChild(nubR); container.appendChild(stickR);
    function updateStickUI(){ let leftTouch=null,rightTouch=null; for (const t of touches.values()){ if (t.zone==='left' && !leftTouch) leftTouch=t; if (t.zone==='right' && !rightTouch) rightTouch=t; } const upd=(t,stick,nub)=>{ if(!t){ stick.style.display='none'; return; } stick.style.display='block'; stick.style.left=t.ox+'px'; stick.style.top=t.oy+'px'; const dx=t.x-t.ox, dy=t.y-t.oy; const r=Math.hypot(dx,dy), m=r>maxR?maxR/r:1; nub.style.transform=`translate(${dx*m}px, ${dy*m}px)`; }; upd(leftTouch,stickL,nubL); upd(rightTouch,stickR,nubR); }
    function recomputeAgg(){ let yaw=0,yc=0,thr=0,tc=0; for (const t of touches.values()){ const dx=t.x-t.ox, dy=t.y-t.oy; const ndx=(Math.abs(dx)<dead?0:dx)/maxR; const ndy=(Math.abs(dy)<dead?0:dy)/maxR; if(t.zone==='right'){ yaw += ndx; yc++; } else { thr += -ndy; tc++; } } touchAgg.yaw=Math.max(-1,Math.min(1,yc?yaw/yc:0)); touchAgg.throttle=Math.max(-1,Math.min(1,tc?thr/tc:0)); }
    renderer.domElement.style.touchAction='none'; const canvasEl = renderer.domElement; function zoneFor(e){ const r=canvasEl.getBoundingClientRect(); return (e.clientX < r.left + r.width/2) ? 'left':'right'; }
    canvasEl.addEventListener('pointerdown', (e)=>{ if(!e.isPrimary) return; if(e.pointerType!=='touch' && e.pointerType!=='pen') return; const z=zoneFor(e); touches.set(e.pointerId,{id:e.pointerId,zone:z,ox:e.clientX,oy:e.clientY,x:e.clientX,y:e.clientY}); if (canvasEl.setPointerCapture) { try { canvasEl.setPointerCapture(e.pointerId); } catch(err){} } recomputeAgg(); updateStickUI(); e.preventDefault(); }, {passive:false});
    canvasEl.addEventListener('pointermove', (e)=>{ const t=touches.get(e.pointerId); if(!t) return; t.x=e.clientX; t.y=e.clientY; recomputeAgg(); updateStickUI(); e.preventDefault(); }, {passive:false});
    function endTouch(e){ const t=touches.get(e.pointerId); if(!t) return; touches.delete(e.pointerId); recomputeAgg(); updateStickUI(); if (canvasEl.releasePointerCapture) { try { canvasEl.releasePointerCapture(e.pointerId); } catch(err){} } e.preventDefault(); }
    canvasEl.addEventListener('pointerup', (e)=>{ if(e.pointerType!=='touch' && e.pointerType!=='pen') return; endTouch(e); }, {passive:false});
    canvasEl.addEventListener('pointercancel', (e)=>{ if(e.pointerType!=='touch' && e.pointerType!=='pen') return; endTouch(e); }, {passive:false});
    canvasEl.addEventListener('pointerleave', (e)=>{ if(e.pointerType!=='touch' && e.pointerType!=='pen') return; endTouch(e); }, {passive:false});
    window._touches = touches; function getTouchInput(){ return { yaw: touchYawSm, throttle: touchThrottleSm }; } window._getTouchInput = getTouchInput;

    const auto = { enabled: true, theta: 0, speed: 0.38, radiusBase: 260, radiusAmp: 170, heightBase: 95, heightAmp: 32, bobAmp: 12, bobSpeed: 0.85, lookAtOffset: new THREE.Vector3(0,8,0) };
    window._auto = auto;

    const controls = { yaw: 0, speed: 68, turnSpeed: Math.PI, height: 72, bounds: 560 };
    camera.position.set(0, controls.height, 180); camera.lookAt(0,0,0);
    function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
    function updateControls(dt){
      if (auto.enabled){
        auto.theta += auto.speed * dt;
        const target = blackHole.position.clone().add(auto.lookAtOffset);
        const r = Math.max(110, auto.radiusBase + auto.radiusAmp * Math.sin(auto.theta * 0.33));
        const camX = target.x + r * Math.cos(auto.theta);
        const camZ = target.z + r * Math.sin(auto.theta);
        const camY = auto.heightBase + auto.heightAmp * Math.cos(auto.theta * 0.42) + Math.sin(auto.theta * auto.bobSpeed * 2.0) * auto.bobAmp;
        camera.position.set(camX, camY, camZ);
        camera.lookAt(target);
        controls.yaw = Math.atan2(target.x - camX, camZ - target.z);
        return;
      }

      let yawInput = 0; if (keyState['ArrowLeft']) yawInput += 1; if (keyState['ArrowRight']) yawInput -= 1;
      let throttleInput = 0; if (keyState['ArrowUp']) throttleInput += 1; if (keyState['ArrowDown']) throttleInput -= 1;
      const k = 1 - Math.exp(-dt * 12); touchYawSm += (touchAgg.yaw - touchYawSm) * k; touchThrottleSm += (touchAgg.throttle - touchThrottleSm) * k;
      yawInput = Math.max(-1, Math.min(1, yawInput + touchYawSm));
      throttleInput = Math.max(-1, Math.min(1, throttleInput + touchThrottleSm));
      controls.yaw += controls.turnSpeed * dt * yawInput;
      const forward = new THREE.Vector3(Math.sin(controls.yaw), 0, -Math.cos(controls.yaw));
      if (Math.abs(throttleInput) > 1e-3) { const move = forward.clone().multiplyScalar(controls.speed * dt * throttleInput); const p = camera.position.clone().add(move); p.y=controls.height; p.x=clamp(p.x,-controls.bounds,controls.bounds); p.z=clamp(p.z,-controls.bounds,controls.bounds); camera.position.copy(p); }
      camera.lookAt(camera.position.clone().add(forward));
    }
    window._updateControls = updateControls;

    // GRB system
    const grb = createGRBSystem(scene); window._grb = grb;

    // Key actions
    window.addEventListener('keydown', (e)=>{
      if (e.key==='A' || e.key==='a'){ auto.enabled = !auto.enabled; }
      if (e.key==='N' || e.key==='n'){ nebulae.userData.enabled = !nebulae.userData.enabled; nebulae.visible = nebulae.userData.enabled; }
      if (e.key==='G' || e.key==='g'){ const target = blackHole.position.clone(); const dir = new THREE.Vector3(Math.random()-0.5,1,Math.random()-0.5).normalize(); grb.trigger(target.clone().add(new THREE.Vector3(0,60,0)), dir); }
      if (e.key==='R' || e.key==='r'){ camera.position.set(0, controls.height, 180); controls.yaw=0; auto.enabled=true; }
    });

    let _lastTime = performance.now();
    function animate(){
      const now = performance.now(); const dt = Math.min(0.05, (now - _lastTime) / 1000); _lastTime = now;
      fpsMonitor.begin();
      if (stats.begin) stats.begin();
      // Smooth touch input
      const k = 1 - Math.exp(-dt * 12); touchYawSm += (touchAgg.yaw - touchYawSm) * k; touchThrottleSm += (touchAgg.throttle - touchThrottleSm) * k;

      updateControls(dt); updateBlackHole(blackHole, dt); updateAndromeda(andromeda, dt); updateGalaxyField(galaxyField, dt); updateLensArcs(lensArcs, dt); updateNebulae(nebulae, dt); grb.update(dt);
      renderer.render(scene, camera);
      if (stats.end) stats.end();
      fpsMonitor.end();
      requestAnimationFrame(animate);
    }

    animate();

    // === Self-tests
    setTimeout(()=>{
      try{
        console.assert(window._andromeda, 'Andromeda exists');
        console.assert(window._blackHole?.userData?.flares?.length >= 20, 'Gamma flares present');
        console.assert(window._galaxyField && window._galaxyField.children.length >= 14, 'Galaxy field size OK');
        console.assert(window._lensArcs && window._lensArcs.children.length > 0, 'Lens arcs present');
        console.assert(window._nebulae && window._nebulae.children.length >= 3, 'Nebulae present');
        console.assert(document.getElementById('container').dataset.appVersion === APP_VERSION, 'data-app-version matches');
      }catch(e){ console.warn('Self-tests failed:', e); }
    }, 1200);
  }

  // ===== Fallback (Canvas 2D) — minimal but pretty
  function initCanvasFallback(cause){
    const container = document.getElementById('container');
    const fpsHolder = document.getElementById('fps');
    const note = document.getElementById('note');
    const placeholder = document.getElementById('placeholder');
    const resolutionSelect = document.getElementById('resolution-select');
    const resolutionDisplay = document.getElementById('resolution-display');
    enhanceResolutionSelect(resolutionSelect);
    placeholder.style.display = 'none';

    const canvas = document.createElement('canvas');
    container.appendChild(canvas);
    const ctx = canvas.getContext('2d');

    const stats = new MiniStats();
    if (stats.dom) stats.dom.style.display = 'none';
    const fpsMonitor = new FpsMonitor(fpsHolder);

    const q = chooseQuality();
    const defaultResValue = q.isMobile ? '854x480' : '1280x720';
    if (resolutionSelect && resolutionSelect.querySelector(`option[value="${defaultResValue}"]`)) {
      resolutionSelect.value = defaultResValue;
      resolutionSelect.dispatchEvent(new Event('change', { bubbles: true }));
    }
    let currentResolution = parseResolutionValue(resolutionSelect ? resolutionSelect.value : defaultResValue);
    let stars = [];

    function syncResolution({ announce = false } = {}){
      const dims = computeScaledDimensions(currentResolution, window.innerWidth, window.innerHeight);
      canvas.width = dims.width;
      canvas.height = dims.height;
      stars = Array.from({ length: 1600 }, () => ({ x: Math.random() * canvas.width, y: Math.random() * canvas.height, z: Math.random() * 2 + 0.2 }));
      if (resolutionDisplay) {
        resolutionDisplay.textContent = formatResolutionText(currentResolution, dims);
      }
      if (note) {
        note.textContent = `${APP_VERSION} • Fallback: Canvas space • ${currentResolution.label}`;
      }
      if (announce) {
        console.log(`Fallback resolution set to ${dims.width}×${dims.height} (${currentResolution.label}).`);
      }
    }

    let resizeRaf = 0;
    let pendingAnnounce = false;
    function scheduleResize({ announce = false } = {}){
      pendingAnnounce = pendingAnnounce || announce;
      if (resizeRaf) cancelAnimationFrame(resizeRaf);
      resizeRaf = requestAnimationFrame(() => {
        resizeRaf = 0;
        syncResolution({ announce: pendingAnnounce });
        pendingAnnounce = false;
      });
    }

    syncResolution({ announce: true });

    const resizeListener = () => scheduleResize();
    window.addEventListener('resize', resizeListener);
    if (window.visualViewport) window.visualViewport.addEventListener('resize', resizeListener);
    window.addEventListener('orientationchange', resizeListener);

    if (resolutionSelect) {
      resolutionSelect.addEventListener('change', () => {
        currentResolution = parseResolutionValue(resolutionSelect.value);
        scheduleResize({ announce: true });
        flashResolutionPanel();
      });
    }

    let t = 0;
    function frame(){
      fpsMonitor.begin();
      stats.begin();
      t += 1/60;
      const WIDTH = canvas.width;
      const HEIGHT = canvas.height;
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, WIDTH, HEIGHT);
      for (const s of stars) {
        s.x -= s.z * 0.3;
        if (s.x < 0) s.x += WIDTH;
        const b = 150 + Math.floor(s.z * 50);
        ctx.fillStyle = `rgb(${b},${b},${b})`;
        ctx.fillRect(s.x, s.y, 2, 2);
      }
      const cx = WIDTH * 0.5;
      const cy = HEIGHT * 0.52;
      ctx.save();
      ctx.translate(cx - 180, cy - 120);
      ctx.rotate(0.2);
      ctx.globalCompositeOperation = 'lighter';
      ctx.fillStyle = 'rgba(255,230,180,0.10)';
      for (let r = 40; r < 240; r += 14) {
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
      ctx.globalCompositeOperation = 'source-over';
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.arc(cx, cy, 28, 0, Math.PI * 2);
      ctx.fill();
      ctx.save();
      ctx.translate(cx, cy);
      ctx.rotate(t * 0.2);
      ctx.globalCompositeOperation = 'lighter';
      ctx.strokeStyle = 'rgba(255,200,100,0.9)';
      ctx.lineWidth = 3;
      ctx.beginPath();
      ctx.ellipse(0, 0, 34, 34, 0, 0, Math.PI * 2);
      ctx.stroke();
      ctx.strokeStyle = 'rgba(255,170,80,0.35)';
      ctx.lineWidth = 2;
      for (let i = 0; i < 20; i++) {
        const r = 36 + Math.random() * 46;
        ctx.beginPath();
        ctx.arc(0, 0, r, 0, Math.PI * 2);
        ctx.stroke();
      }
      for (let i = 0; i < 22; i++) {
        const life = (t * 0.7 + i * 0.1) % 1.6;
        const dir = i % 2 ? 1 : -1;
        const y = (life * 180 - 90) * dir;
        const op = Math.max(0, 1 - (life * life));
        ctx.fillStyle = `rgba(120,180,255,${0.9 * op})`;
        ctx.beginPath();
        ctx.ellipse(0, y, 7 + 10 * (1 - life), 7 + 5 * (1 - life), 0, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
      stats.end();
      fpsMonitor.end();
      requestAnimationFrame(frame);
    }
    frame();
    showErrorOverlay('Three.js failed to load — running fallback renderer.', cause);
  }
  </script>
</body>
</html>
